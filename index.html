<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø³ÛŒØ³ØªÙ… Ø¬Ø§Ù…Ø¹ ØªØ­Ù„ÛŒÙ„ Ùˆ Ù…Ø¹Ø§Ù…Ù„Ù‡â€ŒÚ¯Ø±ÛŒ Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ Ø§ÛŒØ±Ø§Ù†</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.0/axios.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="ai_models.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        :root {
            --primary: #1e3c72;
            --secondary: #2a5298;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --info: #17a2b8;
            --light: #f8f9fa;
            --dark: #343a40;
            --sidebar-width: 300px;
        }
        
        body {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
        }
        
        .sidebar {
            width: var(--sidebar-width);
            background: rgba(255, 255, 255, 0.98);
            height: 100vh;
            position: fixed;
            right: 0;
            top: 0;
            padding: 20px;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            z-index: 1000;
        }
        
        .main-content {
            flex: 1;
            margin-right: var(--sidebar-width);
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
        }
        
        h1 {
            color: var(--primary);
            margin-bottom: 10px;
            font-size: 2.2rem;
            font-weight: 700;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 25px;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }
        
        .card h2 {
            color: var(--primary);
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
            font-size: 1.4rem;
            font-weight: 600;
        }
        
        .market-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .market-item {
            background: var(--light);
            border-radius: 12px;
            padding: 18px;
            border-left: 5px solid var(--primary);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .market-item:hover {
            background: #e9ecef;
            transform: translateX(8px);
        }
        
        .market-name {
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        
        .market-price {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 8px;
            color: var(--dark);
        }
        
        .market-change {
            font-size: 0.95rem;
            padding: 5px 12px;
            border-radius: 8px;
            display: inline-block;
            font-weight: 600;
        }
        
        .positive {
            background: #d4edda;
            color: #155724;
        }
        
        .negative {
            background: #f8d7da;
            color: #721c24;
        }
        
        .chart-container {
            height: 400px;
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
            background: rgba(255, 255, 255, 0.98);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        
        .control-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        select, button, input {
            padding: 12px 18px;
            border-radius: 10px;
            border: 1px solid #ddd;
            background: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:focus, button:focus, input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(30, 60, 114, 0.2);
        }
        
        button {
            background: var(--primary);
            color: white;
            border: none;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        button:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .analysis-section {
            margin-top: 25px;
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .analysis-item {
            background: var(--light);
            border-radius: 12px;
            padding: 20px;
            border-left: 5px solid var(--success);
            transition: all 0.3s ease;
        }
        
        .risk-item {
            border-left-color: var(--danger);
        }
        
        .opportunity-item {
            border-left-color: var(--success);
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 1.1rem;
        }
        
        .tab-container {
            margin-bottom: 20px;
        }
        
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tab {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px 10px 0 0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .tab.active {
            background: white;
            color: var(--primary);
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .sidebar-section {
            margin-bottom: 30px;
        }
        
        .sidebar-section h3 {
            color: var(--primary);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .api-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: var(--light);
            border-radius: 8px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }
        
        .api-status.connected {
            border-right: 4px solid var(--success);
        }
        
        .api-status.disconnected {
            border-right: 4px solid var(--danger);
            animation: pulse 2s infinite;
        }
        
        .api-status.warning {
            border-right: 4px solid var(--warning);
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 8px;
        }
        
        .status-connected {
            background: var(--success);
        }
        
        .status-disconnected {
            background: var(--danger);
        }
        
        .status-warning {
            background: var(--warning);
        }
        
        .notification {
            position: fixed;
            top: 20px;
            left: 20px;
            right: calc(var(--sidebar-width) + 20px);
            background: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slideIn 0.5s ease;
            border-right: 4px solid var(--danger);
        }
        
        .notification.success {
            border-right-color: var(--success);
        }
        
        .notification.warning {
            border-right-color: var(--warning);
        }
        
        @keyframes slideIn {
            from { transform: translateY(-100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .close-notification {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: #666;
            padding: 5px;
        }
        
        .connection-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .stat-item {
            background: var(--light);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--primary);
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: #666;
        }

        /* Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø¨Ø®Ø´ Ø§Ù…Ù†ÛŒØª */
        .security-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-left: 5px;
        }
        
        .security-high { background: var(--success); color: white; }
        .security-medium { background: var(--warning); color: black; }
        .security-low { background: var(--danger); color: white; }
        
        .encrypted-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
            color: var(--success);
            margin-bottom: 10px;
        }
        
        .performance-meter {
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            margin: 5px 0;
            overflow: hidden;
        }
        
        .performance-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.5s ease;
        }
        
        .model-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: var(--light);
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .model-status.active {
            border-right: 4px solid var(--success);
        }
        
        .technical-indicators {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .indicator {
            background: var(--light);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .indicator-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--primary);
        }
        
        .indicator-name {
            font-size: 0.9rem;
            color: #666;
        }
        
        .risk-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric {
            background: var(--light);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.4rem;
            font-weight: bold;
        }
        
        .metric-high {
            color: var(--danger);
        }
        
        .metric-medium {
            color: var(--warning);
        }
        
        .metric-low {
            color: var(--success);
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .feature-item {
            background: var(--light);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .feature-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .feature-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            color: var(--primary);
        }
        
        @media (max-width: 1200px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                width: 280px;
            }
            
            .main-content {
                margin-right: 280px;
            }
        }
        
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(100%);
                transition: transform 0.3s ease;
            }
            
            .sidebar.active {
                transform: translateX(0);
            }
            
            .main-content {
                margin-right: 0;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .control-group {
                width: 100%;
                justify-content: center;
            }
            
            select, button {
                flex: 1;
                min-width: 150px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
        }
        
        .menu-toggle {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
        }
        
        @media (max-width: 768px) {
            .menu-toggle {
                display: block;
            }
        }
    </style>
</head>
<body>
    <button class="menu-toggle" onclick="FinancialAnalysisApp.getInstance().uiManager.toggleSidebar()">â˜°</button>
    
    <div class="sidebar" id="sidebar">
        <div class="sidebar-section">
            <h3>ğŸ” ÙˆØ¶Ø¹ÛŒØª Ø§ØªØµØ§Ù„ APIÙ‡Ø§</h3>
            <div id="apiStatusContainer">
                <!-- ÙˆØ¶Ø¹ÛŒØª APIÙ‡Ø§ Ø§ÛŒÙ†Ø¬Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯ -->
            </div>
            
            <div class="connection-stats">
                <div class="stat-item">
                    <div class="stat-value" id="connectedCount">0</div>
                    <div class="stat-label">Ù…ØªØµÙ„</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="disconnectedCount">0</div>
                    <div class="stat-label">Ù‚Ø·Ø¹</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalCount">0</div>
                    <div class="stat-label">Ú©Ù„</div>
                </div>
            </div>
        </div>
        
        <div class="sidebar-section">
            <h3>ğŸ¤– ÙˆØ¶Ø¹ÛŒØª Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</h3>
            <div class="model-status active">
                <span>AdvancedDecisionExplainer</span>
                <span class="status-indicator status-connected"></span>
            </div>
            <div class="model-status active">
                <span>MarketSentimentTransformer</span>
                <span class="status-indicator status-connected"></span>
            </div>
            <div class="model-status active">
                <span>PricePredictionTransformer</span>
                <span class="status-indicator status-connected"></span>
            </div>
            <div class="model-status active">
                <span>RiskAssessorAgent</span>
                <span class="status-indicator status-connected"></span>
            </div>
        </div>
        
        <div class="sidebar-section">
            <h3>ğŸ“Š Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ ÙÙ†ÛŒ</h3>
            <div class="technical-indicators" id="technicalIndicators">
                <!-- ØªÙˆØ³Ø· JavaScript Ù¾Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯ -->
            </div>
        </div>
        
        <div class="sidebar-section">
            <h3>âš ï¸ Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§ÛŒ Ø±ÛŒØ³Ú©</h3>
            <div class="risk-metrics" id="riskMetrics">
                <!-- ØªÙˆØ³Ø· JavaScript Ù¾Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯ -->
            </div>
        </div>
        
        <div class="sidebar-section">
            <h3>ğŸ›¡ï¸ Ø§Ù…Ù†ÛŒØª Ø³ÛŒØ³ØªÙ…</h3>
            <div class="encrypted-indicator">
                <span>ğŸ”’</span>
                <span>ØªÙ…Ø§Ù…ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ø´Ø¯Ù‡</span>
            </div>
            <div class="performance-meter">
                <div class="performance-fill" id="performanceMeter" style="width: 95%; background: var(--success);"></div>
            </div>
            <small>Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø³ÛŒØ³ØªÙ…: <span id="performanceText">Ø¹Ø§Ù„ÛŒ</span></small>
        </div>
    </div>
    
    <div class="main-content">
        <div class="container">
            <header>
                <h1>Ø³ÛŒØ³ØªÙ… Ø¬Ø§Ù…Ø¹ ØªØ­Ù„ÛŒÙ„ Ùˆ Ù…Ø¹Ø§Ù…Ù„Ù‡â€ŒÚ¯Ø±ÛŒ Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ Ø§ÛŒØ±Ø§Ù†</h1>
                <p class="subtitle">ØªØ­Ù„ÛŒÙ„ ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡ Ø¨ÙˆØ±Ø³ØŒ Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„ØŒ Ø·Ù„Ø§ Ùˆ Ø§Ø±Ø² Ø¨Ø§ Ù†Ø¸Ø§Ø±Øª Ù‡ÙˆØ´Ù…Ù†Ø¯ API</p>
                <div>
                    <span class="security-badge security-high">Ø§Ù…Ù†ÛŒØª Ø¨Ø§Ù„Ø§</span>
                    <span class="security-badge security-high">Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø²Ù†Ø¯Ù‡</span>
                    <span class="security-badge security-medium">Ù†Ø³Ø®Ù‡ Ø¢Ø²Ù…Ø§ÛŒØ´ÛŒ</span>
                </div>
            </header>
            
            <div class="controls">
                <div class="control-group">
                    <select id="marketType">
                        <option value="all">Ù‡Ù…Ù‡ Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§</option>
                        <option value="stock">Ø¨ÙˆØ±Ø³ Ø§ÙˆØ±Ø§Ù‚ Ø¨Ù‡Ø§Ø¯Ø§Ø±</option>
                        <option value="crypto">Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„</option>
                        <option value="gold">Ø·Ù„Ø§ Ùˆ Ø³Ú©Ù‡</option>
                        <option value="currency">Ø§Ø±Ø²</option>
                        <option value="commodity">Ú©Ø§Ù…ÙˆØ¯ÛŒØªÛŒ</option>
                    </select>
                    
                    <select id="timeFrame">
                        <option value="1d">Û± Ø±ÙˆØ²</option>
                        <option value="1w">Û± Ù‡ÙØªÙ‡</option>
                        <option value="1m">Û± Ù…Ø§Ù‡</option>
                        <option value="3m">Û³ Ù…Ø§Ù‡</option>
                        <option value="1y">Û± Ø³Ø§Ù„</option>
                    </select>
                    
                    <button id="refreshBtn">
                        <span>ğŸ”„</span> Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
                    </button>
                </div>
                
                <div class="control-group">
                    <button id="analyzeBtn">
                        <span>ğŸ¤–</span> ØªØ­Ù„ÛŒÙ„ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ
                    </button>
                    <button id="riskBtn">
                        <span>âš ï¸</span> Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø±ÛŒØ³Ú©
                    </button>
                    <button id="tradeBtn">
                        <span>ğŸ’¼</span> Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù…Ø¹Ø§Ù…Ù„Ù‡
                    </button>
                    <button id="monitorBtn">
                        <span>ğŸ”</span> ØªØ³Øª Ø§ØªØµØ§Ù„ APIÙ‡Ø§
                    </button>
                    <button id="securityBtn">
                        <span>ğŸ›¡ï¸</span> ØªØ³Øª Ø§Ù…Ù†ÛŒØª
                    </button>
                </div>
            </div>
            
            <div class="tab-container">
                <div class="tabs">
                    <div class="tab active" data-tab="dashboard">Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ø§ØµÙ„ÛŒ</div>
                    <div class="tab" data-tab="analysis">ØªØ­Ù„ÛŒÙ„ Ù¾ÛŒØ´Ø±ÙØªÙ‡</div>
                    <div class="tab" data-tab="explanations">ØªÙˆØ¶ÛŒØ­â€ŒÙ¾Ø°ÛŒØ±ÛŒ AI</div>
                    <div class="tab" data-tab="trading">Ù…Ø¹Ø§Ù…Ù„Ø§Øª</div>
                    <div class="tab" data-tab="reports">Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§</div>
                    <div class="tab" data-tab="transformer">Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Transformer</div>
                    <div class="tab" data-tab="monitoring">Ù†Ø¸Ø§Ø±Øª API</div>
                    <div class="tab" data-tab="security">Ø§Ù…Ù†ÛŒØª Ùˆ Ù†Ø¸Ø§Ø±Øª</div>
                    <div class="tab" data-tab="feature-importance">ØªØ­Ù„ÛŒÙ„ Ø§Ù‡Ù…ÛŒØª ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§</div>
                    <div class="tab" data-tab="model-interpretability">Ù‚Ø§Ø¨Ù„ÛŒØª ØªÙØ³ÛŒØ± Ù…Ø¯Ù„</div>
                    <div class="tab" data-tab="advanced-sentiment">ØªØ­Ù„ÛŒÙ„ Ø§Ø­Ø³Ø§Ø³Ø§Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡</div>
                </div>
                
                <div class="tab-content active" id="dashboard-tab">
                    <div class="dashboard">
                        <div class="card">
                            <h2>ÙˆØ¶Ø¹ÛŒØª Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§</h2>
                            <div class="market-grid" id="marketStatus">
                                <div class="loading">Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±...</div>
                            </div>
                        </div>
                        
                        <div class="card">
                            <h2>Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ú©Ù„Ø§Ù†</h2>
                            <div id="indicesChart" class="chart-container"></div>
                        </div>
                        
                        <div class="card">
                            <h2>ØªØ­Ù„ÛŒÙ„ Ù‚ÛŒÙ…Øª Ùˆ Ø±ÙˆÙ†Ø¯</h2>
                            <div id="priceChart" class="chart-container"></div>
                        </div>
                        
                        <div class="card">
                            <h2>ÙˆØ¶Ø¹ÛŒØª Ø§ØªØµØ§Ù„ APIÙ‡Ø§</h2>
                            <div id="connectionChart" class="chart-container"></div>
                        </div>
                    </div>
                    
                    <div class="card analysis-section">
                        <h2>ØªØ­Ù„ÛŒÙ„ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ùˆ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ</h2>
                        <div class="analysis-grid" id="aiAnalysis">
                            <div class="loading">Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ØŒ Ø¯Ú©Ù…Ù‡ "ØªØ­Ù„ÛŒÙ„ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ" Ø±Ø§ Ø¨ÙØ´Ø§Ø±ÛŒØ¯</div>
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="analysis-tab">
                    <div class="card">
                        <h2>ØªØ­Ù„ÛŒÙ„ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø¨Ø§Ø²Ø§Ø±</h2>
                        <div class="feature-grid">
                            <div class="feature-item">
                                <div class="feature-icon">ğŸ“Š</div>
                                <h3>ØªØ­Ù„ÛŒÙ„ ØªÚ©Ù†ÛŒÚ©Ø§Ù„</h3>
                                <p>Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ùˆ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ</p>
                            </div>
                            <div class="feature-item">
                                <div class="feature-icon">ğŸ“ˆ</div>
                                <h3>ØªØ­Ù„ÛŒÙ„ Ø¨Ù†ÛŒØ§Ø¯ÛŒ</h3>
                                <p>Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø§Ø±Ø²Ø´ Ø°Ø§ØªÛŒ Ùˆ Ù¾ØªØ§Ù†Ø³ÛŒÙ„ Ø±Ø´Ø¯</p>
                            </div>
                            <div class="feature-item">
                                <div class="feature-icon">ğŸ§ </div>
                                <h3>Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</h3>
                                <p>Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø±ÙˆÙ†Ø¯ Ø¨Ø§ Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Transformer</p>
                            </div>
                            <div class="feature-item">
                                <div class="feature-icon">ğŸ“‰</div>
                                <h3>ØªØ­Ù„ÛŒÙ„ Ø§Ø­Ø³Ø§Ø³Ø§Øª</h3>
                                <p>Ø¨Ø±Ø±Ø³ÛŒ Ø¬Ùˆ Ø¨Ø§Ø²Ø§Ø± Ùˆ ØªØ£Ø«ÛŒØ± Ø§Ø®Ø¨Ø§Ø±</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Ú¯Ø²Ø§Ø±Ø´ ØªØ­Ù„ÛŒÙ„ Ø¨Ø§Ø²Ø§Ø±</h2>
                        <div id="advancedAnalysis" class="analysis-grid">
                            <div class="loading">Ø¯Ø± Ø­Ø§Ù„ Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡...</div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>ØªØ­Ù„ÛŒÙ„ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…Ù‡Ù…</h2>
                        <div id="featureImportanceChart" class="chart-container"></div>
                    </div>
                </div>
                
                <div class="tab-content" id="explanations-tab">
                    <div class="card">
                        <h2>ØªÙˆØ¶ÛŒØ­â€ŒÙ¾Ø°ÛŒØ±ÛŒ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ (XAI)</h2>
                        <div class="analysis-grid" id="xaiExplanations">
                            <div class="loading">Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯ ØªÙˆØ¶ÛŒØ­Ø§Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ...</div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>ØªØ­Ù„ÛŒÙ„ SHAP</h2>
                        <div id="shapChart" class="chart-container"></div>
                    </div>
                    
                    <div class="card">
                        <h2>ØªØ­Ù„ÛŒÙ„ LIME</h2>
                        <div id="limeChart" class="chart-container"></div>
                    </div>
                </div>
                
                <div class="tab-content" id="trading-tab">
                    <div class="card">
                        <h2>Ø³ÛŒØ³ØªÙ… Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯</h2>
                        <div class="analysis-grid">
                            <div class="analysis-item opportunity-item">
                                <h3>Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø®Ø±ÛŒØ¯</h3>
                                <p><strong>Ù†Ù…Ø§Ø¯:</strong> Ø´ØªØ±Ø§Ù†</p>
                                <p><strong>Ù‚ÛŒÙ…Øª Ù‡Ø¯Ù:</strong> ÛµÛ²,Û°Û°Û° ØªÙˆÙ…Ø§Ù†</p>
                                <p><strong>Ø­Ø¯ Ø¶Ø±Ø±:</strong> Û´Û²,Û°Û°Û° ØªÙˆÙ…Ø§Ù†</p>
                                <div class="market-change positive">Ø§Ø¹ØªÙ…Ø§Ø¯: Û·Û¸%</div>
                            </div>
                            <div class="analysis-item opportunity-item">
                                <h3>Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø®Ø±ÛŒØ¯</h3>
                                <p><strong>Ù†Ù…Ø§Ø¯:</strong> Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ†</p>
                                <p><strong>Ù‚ÛŒÙ…Øª Ù‡Ø¯Ù:</strong> Û¹Ûµ,Û°Û°Û° Ø¯Ù„Ø§Ø±</p>
                                <p><strong>Ø­Ø¯ Ø¶Ø±Ø±:</strong> Û·Û¸,Û°Û°Û° Ø¯Ù„Ø§Ø±</p>
                                <div class="market-change positive">Ø§Ø¹ØªÙ…Ø§Ø¯: Û¸Û²%</div>
                            </div>
                            <div class="analysis-item risk-item">
                                <h3>Ù‡Ø´Ø¯Ø§Ø± ÙØ±ÙˆØ´</h3>
                                <p><strong>Ù†Ù…Ø§Ø¯:</strong> Ø³Ú©Ù‡ Ø§Ù…Ø§Ù…ÛŒ</p>
                                <p><strong>Ø¯Ù„ÛŒÙ„:</strong> Ø±Ø³ÛŒØ¯Ù† Ø¨Ù‡ Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø§Ø´Ø¨Ø§Ø¹ Ø®Ø±ÛŒØ¯</p>
                                <p><strong>ØªÙˆØµÛŒÙ‡:</strong> Ú©Ø§Ù‡Ø´ Ù…ÙˆÙ‚Ø¹ÛŒØª</p>
                                <div class="market-change negative">Ø±ÛŒØ³Ú©: Ø¨Ø§Ù„Ø§</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>ØªØ­Ù„ÛŒÙ„ Ø³Ù†Ø§Ø±ÛŒÙˆÙ‡Ø§ÛŒ Ù…ØªØºÛŒØ±</h2>
                        <div id="counterfactualChart" class="chart-container"></div>
                    </div>
                </div>
                
                <div class="tab-content" id="reports-tab">
                    <div class="card">
                        <h2>Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯</h2>
                        <div class="analysis-grid">
                            <div class="analysis-item">
                                <h3>Ø¹Ù…Ù„Ú©Ø±Ø¯ Ù¾Ø±ØªÙÙˆÛŒ</h3>
                                <p><strong>Ø³ÙˆØ¯/Ø²ÛŒØ§Ù† Ú©Ù„:</strong> +Û±Û².Ûµ%</p>
                                <p><strong>Ø¨Ù‡ØªØ±ÛŒÙ† Ø¹Ù…Ù„Ú©Ø±Ø¯:</strong> Ø¨ÙˆØ±Ø³ (+Û±Û¸.Û²%)</p>
                                <p><strong>Ø¶Ø¹ÛŒÙâ€ŒØªØ±ÛŒÙ† Ø¹Ù…Ù„Ú©Ø±Ø¯:</strong> Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„ (+Ûµ.Û¸%)</p>
                            </div>
                            <div class="analysis-item">
                                <h3>ØªØ­Ù„ÛŒÙ„ Ø±ÛŒØ³Ú©</h3>
                                <p><strong>VaR 95%:</strong> -Û³.Û²%</p>
                                <p><strong>Ø­Ø¯Ø§Ú©Ø«Ø± Ø§ÙØª:</strong> -Û¸.Ûµ%</p>
                                <p><strong>Ù†Ø³Ø¨Øª Ø´Ø§Ø±Ù¾:</strong> Û±.Û´Ûµ</p>
                            </div>
                            <div class="analysis-item">
                                <h3>Ú¯Ø²Ø§Ø±Ø´ Ù…Ø¹Ø§Ù…Ù„Ø§Øª</h3>
                                <p><strong>ØªØ¹Ø¯Ø§Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§Øª:</strong> Û´Û·</p>
                                <p><strong>Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø³ÙˆØ¯:</strong> +Û´.Û²%</p>
                                <p><strong>Ù†Ø±Ø® Ù…ÙˆÙÙ‚ÛŒØª:</strong> Û¶Û¸%</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="transformer-tab">
                    <div class="card">
                        <h2>Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Transformer Ù¾ÛŒØ´Ø±ÙØªÙ‡</h2>
                        <div class="analysis-grid">
                            <div class="analysis-item">
                                <h3>MarketSentimentTransformer</h3>
                                <p><strong>Ù…Ø¹Ù…Ø§Ø±ÛŒ:</strong> BERT-base + Attention Layers</p>
                                <p><strong>Ø¯Ù‚Øª:</strong> Û¸Û·.Û³%</p>
                                <p><strong>Ú©Ø§Ø±Ø¨Ø±Ø¯:</strong> ØªØ­Ù„ÛŒÙ„ Ø§Ø­Ø³Ø§Ø³Ø§Øª Ø¨Ø§Ø²Ø§Ø±</p>
                            </div>
                            <div class="analysis-item">
                                <h3>PricePredictionTransformer</h3>
                                <p><strong>Ù…Ø¹Ù…Ø§Ø±ÛŒ:</strong> Multi-Scale Attention</p>
                                <p><strong>Ø¯Ù‚Øª:</strong> Û·Û¹.Û¸%</p>
                                <p><strong>Ú©Ø§Ø±Ø¨Ø±Ø¯:</strong> Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ù‚ÛŒÙ…Øª</p>
                            </div>
                            <div class="analysis-item">
                                <h3>TimeSeriesTransformer</h3>
                                <p><strong>Ù…Ø¹Ù…Ø§Ø±ÛŒ:</strong> Positional Encoding</p>
                                <p><strong>Ø¯Ù‚Øª:</strong> Û¸Û².Û±%</p>
                                <p><strong>Ú©Ø§Ø±Ø¨Ø±Ø¯:</strong> ØªØ­Ù„ÛŒÙ„ Ø³Ø±ÛŒ Ø²Ù…Ø§Ù†ÛŒ</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒâ€ŒÙ‡Ø§ÛŒ Transformer</h2>
                        <div id="transformerPredictionsChart" class="chart-container"></div>
                    </div>
                </div>
                
                <div class="tab-content" id="monitoring-tab">
                    <div class="card">
                        <h2>Ø³ÛŒØ³ØªÙ… Ù†Ø¸Ø§Ø±Øª Ù‡ÙˆØ´Ù…Ù†Ø¯ APIÙ‡Ø§</h2>
                        <div class="analysis-grid">
                            <div class="analysis-item">
                                <h3>ğŸ“¡ ÙˆØ¶Ø¹ÛŒØª Ù„Ø­Ø¸Ù‡â€ŒØ§ÛŒ Ø§ØªØµØ§Ù„</h3>
                                <div id="liveMonitoring" class="market-grid">
                                    <!-- ÙˆØ¶Ø¹ÛŒØª Ù„Ø­Ø¸Ù‡â€ŒØ§ÛŒ -->
                                </div>
                            </div>
                            <div class="analysis-item">
                                <h3>ğŸ“ˆ Ø¢Ù…Ø§Ø± Ø¹Ù…Ù„Ú©Ø±Ø¯ APIÙ‡Ø§</h3>
                                <div id="performanceStats">
                                    <!-- Ø¢Ù…Ø§Ø± Ø¹Ù…Ù„Ú©Ø±Ø¯ -->
                                </div>
                            </div>
                            <div class="analysis-item">
                                <h3>ğŸ”” Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ÛŒ Ø§Ø®ÛŒØ±</h3>
                                <div id="recentAlerts">
                                    <!-- Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="security-tab">
                    <div class="card">
                        <h2>Ø³ÛŒØ³ØªÙ… Ù†Ø¸Ø§Ø±Øª Ùˆ Ø§Ù…Ù†ÛŒØª</h2>
                        <div class="analysis-grid">
                            <div class="analysis-item">
                                <h3>ÙˆØ¶Ø¹ÛŒØª Ø§ØªØµØ§Ù„ APIÙ‡Ø§</h3>
                                <div id="apiMonitoringStatus">
                                    <!-- ØªÙˆØ³Ø· JavaScript Ù¾Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯ -->
                                </div>
                            </div>
                            <div class="analysis-item">
                                <h3>Ù„Ø§Ú¯ Ø§Ù…Ù†ÛŒØªÛŒ</h3>
                                <div id="securityLog" style="max-height: 300px; overflow-y: auto;">
                                    <!-- ØªÙˆØ³Ø· JavaScript Ù¾Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯ -->
                                </div>
                            </div>
                            <div class="analysis-item">
                                <h3>Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø³ÛŒØ³ØªÙ…</h3>
                                <div id="performanceMetrics">
                                    <!-- ØªÙˆØ³Ø· JavaScript Ù¾Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯ -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ØªØ­Ù„ÛŒÙ„ Ø§Ù‡Ù…ÛŒØª ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ -->
<div class="tab-content" id="feature-importance-tab">
    <div class="card">
        <h2>ØªØ­Ù„ÛŒÙ„ Ø¬Ø§Ù…Ø¹ Ø§Ù‡Ù…ÛŒØª ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§</h2>
        <div class="analysis-grid" id="featureImportanceAnalysis">
            <div class="loading">Ø¯Ø± Ø­Ø§Ù„ Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØ­Ù„ÛŒÙ„ Ø§Ù‡Ù…ÛŒØª ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§...</div>
        </div>
    </div>
    
    <div class="card">
        <h2>Ù†Ù…ÙˆØ¯Ø§Ø± Ø§Ù‡Ù…ÛŒØª Ø³Ø±Ø§Ø³Ø±ÛŒ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§</h2>
        <div id="globalFeatureImportanceChart" class="chart-container"></div>
    </div>
    
    <div class="card">
        <h2>ØªØ­Ù„ÛŒÙ„ ØªØ¹Ø§Ù…Ù„ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§</h2>
        <div id="featureInteractionChart" class="chart-container"></div>
    </div>
</div>

<!-- Ù‚Ø§Ø¨Ù„ÛŒØª ØªÙØ³ÛŒØ± Ù…Ø¯Ù„ -->
<div class="tab-content" id="model-interpretability-tab">
    <div class="card">
        <h2>ØªØ­Ù„ÛŒÙ„ Ù‚Ø§Ø¨Ù„ÛŒØª ØªÙØ³ÛŒØ± Ù…Ø¯Ù„</h2>
        <div class="analysis-grid" id="modelInterpretabilityAnalysis">
            <div class="loading">Ø¯Ø± Ø­Ø§Ù„ ØªØ­Ù„ÛŒÙ„ Ù‚Ø§Ø¨Ù„ÛŒØª ØªÙØ³ÛŒØ± Ù…Ø¯Ù„...</div>
        </div>
    </div>
</div>

<!-- ØªØ­Ù„ÛŒÙ„ Ø§Ø­Ø³Ø§Ø³Ø§Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡ -->
<div class="tab-content" id="advanced-sentiment-tab">
    <div class="card">
        <h2>ØªØ­Ù„ÛŒÙ„ Ø§Ø­Ø³Ø§Ø³Ø§Øª Ø¨Ø§Ø²Ø§Ø± Ø¨Ø§ Transformer</h2>
        <div class="analysis-grid" id="advancedSentimentAnalysis">
            <div class="loading">Ø¯Ø± Ø­Ø§Ù„ ØªØ­Ù„ÛŒÙ„ Ø§Ø­Ø³Ø§Ø³Ø§Øª Ø¨Ø§Ø²Ø§Ø±...</div>
        </div>
    </div>
</div>
                    
                    <div class="card">
                        <h2>ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ù…Ù†ÛŒØªÛŒ</h2>
                        <div class="controls">
                            <div class="control-group">
                                <button id="encryptDataBtn">
                                    <span>ğŸ”’</span> Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
                                </button>
                                <button id="clearCacheBtn">
                                    <span>ğŸ§¹</span> Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ú©Ø´
                                </button>
                                <button id="testSecurityBtn">
                                    <span>ğŸ›¡ï¸</span> ØªØ³Øª Ø§Ù…Ù†ÛŒØª
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===============================
        // Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª Ø®Ø·Ø§ Ùˆ Ù„Ø§Ú¯ÛŒÙ†Ú¯ Ù¾ÛŒØ´Ø±ÙØªÙ‡
        // ===============================
        class ErrorHandler {
            static init() {
                window.addEventListener('error', this.handleGlobalError.bind(this));
                window.addEventListener('unhandledrejection', this.handlePromiseRejection.bind(this));
            }

            static handleGlobalError(event) {
                const error = {
                    type: 'GlobalError',
                    message: event.message,
                    filename: event.filename,
                    lineno: event.lineno,
                    colno: event.colno,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent
                };
                
                this.logError(error);
                this.notifyUser('Ø®Ø·Ø§ÛŒ Ø³ÛŒØ³ØªÙ…ÛŒ Ø±Ø® Ø¯Ø§Ø¯Ù‡ Ø§Ø³Øª', 'error');
            }

            static handlePromiseRejection(event) {
                const error = {
                    type: 'PromiseRejection',
                    reason: event.reason?.message || event.reason,
                    timestamp: new Date().toISOString()
                };
                
                this.logError(error);
                this.notifyUser('Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø±Ø®ÙˆØ§Ø³Øª', 'error');
            }

            static logError(error) {
                console.error('Error logged:', error);
                if (window.SecurityManager) {
                    window.SecurityManager.logSecurityEvent('ERROR', error);
                }
            }

            static notifyUser(message, type = 'error') {
                if (window.UIManager) {
                    window.UIManager.showNotification(message, type);
                }
            }

            static async apiCallWithRetry(apiCall, maxRetries = 3, context = '') {
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        return await apiCall();
                    } catch (error) {
                        console.warn(`Attempt ${i + 1} failed for ${context}:`, error);
                        
                        if (i === maxRetries - 1) {
                            this.logError({
                                type: 'APIRetryExhausted',
                                context: context,
                                error: error.message,
                                retries: maxRetries
                            });
                            throw error;
                        }
                        
                        await this.delay(Math.pow(2, i) * 1000);
                    }
                }
            }

            static delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // ===============================
        // Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ù…Ù†ÛŒØª Ù¾ÛŒØ´Ø±ÙØªÙ‡
        // ===============================
        class SecurityManager {
            constructor() {
                this.encryptionKey = this.generateEncryptionKey();
                this.securityLog = [];
                this.suspiciousActivities = [];
            }

            generateEncryptionKey() {
                return CryptoJS.lib.WordArray.random(128/8).toString();
            }

            encryptData(data) {
                try {
                    if (typeof data !== 'string') {
                        data = JSON.stringify(data);
                    }
                    return CryptoJS.AES.encrypt(data, this.encryptionKey).toString();
                } catch (error) {
                    ErrorHandler.logError({
                        type: 'EncryptionError',
                        error: error.message,
                        dataType: typeof data
                    });
                    return data;
                }
            }

            decryptData(encryptedData) {
                try {
                    const bytes = CryptoJS.AES.decrypt(encryptedData, this.encryptionKey);
                    return bytes.toString(CryptoJS.enc.Utf8);
                } catch (error) {
                    ErrorHandler.logError({
                        type: 'DecryptionError',
                        error: error.message
                    });
                    return encryptedData;
                }
            }

            sanitizeInput(input) {
                if (typeof input !== 'string') return input;
                
                input = input.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
                input = input.replace(/<[^>]*>/g, '');
                input = input.replace(/[<>"'`]/g, '');
                
                return input.trim();
            }

            validateAPIResponse(data, schema) {
                if (!data) {
                    this.logSecurityEvent('VALIDATION_FAILED', 'Empty response data');
                    return false;
                }

                if (schema === 'array' && !Array.isArray(data)) {
                    this.logSecurityEvent('VALIDATION_FAILED', 'Expected array response');
                    return false;
                }

                if (schema === 'object' && (typeof data !== 'object' || Array.isArray(data))) {
                    this.logSecurityEvent('VALIDATION_FAILED', 'Expected object response');
                    return false;
                }

                return true;
            }

            logSecurityEvent(type, details) {
                const event = {
                    type,
                    details,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    url: window.location.href
                };

                this.securityLog.unshift(event);
                
                if (this.securityLog.length > 100) {
                    this.securityLog = this.securityLog.slice(0, 100);
                }

                this.updateSecurityLogUI();
                this.detectSuspiciousActivity(event);
            }

            detectSuspiciousActivity(event) {
                const suspiciousPatterns = [
                    'FAILED',
                    'ERROR',
                    'UNAUTHORIZED',
                    'VALIDATION_FAILED'
                ];

                if (suspiciousPatterns.some(pattern => event.type.includes(pattern))) {
                    this.suspiciousActivities.push(event);
                    
                    if (this.suspiciousActivities.length > 5) {
                        this.notifyAdmin('ÙØ¹Ø§Ù„ÛŒØª Ù…Ø´Ú©ÙˆÚ© Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯');
                    }
                }
            }

            notifyAdmin(message) {
                console.warn('Admin notification:', message);
            }

            updateSecurityLogUI() {
                const logContainer = document.getElementById('securityLog');
                if (!logContainer) return;

                const logItems = this.securityLog.slice(0, 10).map(event => `
                    <div style="padding: 5px; border-bottom: 1px solid #eee; font-size: 0.9rem;">
                        <strong>${new Date(event.timestamp).toLocaleTimeString('fa-IR')}</strong>
                        <br>${event.type}: ${event.details}
                    </div>
                `).join('');

                logContainer.innerHTML = logItems || '<div>Ù‡ÛŒÚ† Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø§Ù…Ù†ÛŒØªÛŒ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª</div>';
            }

            async testSecurity() {
                const tests = [
                    this.testEncryption(),
                    this.testSanitization(),
                    this.testValidation()
                ];

                const results = await Promise.allSettled(tests);
                
                const passed = results.filter(r => r.status === 'fulfilled' && r.value).length;
                const total = tests.length;

                this.logSecurityEvent('SECURITY_TEST', `${passed} Ø§Ø² ${total} ØªØ³Øª Ø§Ù…Ù†ÛŒØªÛŒ Ù…ÙˆÙÙ‚`);
                
                return passed === total;
            }

            async testEncryption() {
                try {
                    const testData = 'test data';
                    const encrypted = this.encryptData(testData);
                    const decrypted = this.decryptData(encrypted);
                    return decrypted === testData;
                } catch (error) {
                    return false;
                }
            }

            async testSanitization() {
                const maliciousInput = '<script>alert("xss")</script>test';
                const sanitized = this.sanitizeInput(maliciousInput);
                return sanitized === 'test';
            }

            async testValidation() {
                return this.validateAPIResponse([], 'array') && 
                       this.validateAPIResponse({}, 'object') &&
                       !this.validateAPIResponse('invalid', 'array');
            }
        }

        // ===============================
        // Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª API Ù¾ÛŒØ´Ø±ÙØªÙ‡
        // ===============================
        class APIService {
            constructor() {
                this.endpoints = this.loadEndpoints();
                this.cache = new Map();
                this.requestQueue = new Map();
                this.cacheTTL = 5 * 60 * 1000;
            }

            loadEndpoints() {
                return {
                    stockDetail: (symbol) => this.buildURL('Tsetmc/SymbolData.php', {symbol: symbol}),
                    historicalData: (symbol, days) => this.buildURL('Tsetmc/History.php', {symbol: symbol, days: days}),
                    marketDepth: (symbol) => this.buildURL('Tsetmc/MarketDepth.php', {symbol: symbol}),
                    stockSymbols: this.buildURL('Tsetmc/AllSymbols.php'),
                    stockIndex: this.buildURL('Tsetmc/Index.php', {type: 1}),
                    farabourseIndex: this.buildURL('Tsetmc/Index.php', {type: 2}),
                    crypto: this.buildURL('Market/Cryptocurrency.php'),
                    commodityMetals: this.buildURL('Market/Commodity.php', {type: 1}),
                    commodityBaseMetals: this.buildURL('Market/Commodity.php', {type: 2}),
                    commodityEnergy: this.buildURL('Market/Commodity.php', {type: 3}),
                    gold: this.buildURL('Market/Gold_Currency.php', {type: 1}),
                    currency: this.buildURL('Market/Gold_Currency.php', {type: 2}),
                    crypto2: this.buildURL('Market/Gold_Currency.php', {type: 3})
                };
            }

    this.fallbackAPIs = [
            'https://api.example.com/financial/data',
            'https://backup-api.example.com/market'
        ];
    }

    async makeRequestWithFallback(endpointKey, options = {}) {
        let lastError;
        
        for (let i = 0; i < this.fallbackAPIs.length + 1; i++) {
            try {
                if (i === 0) {
                    return await this.makeRequest(endpointKey, options);
                } else {
                    // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² APIÙ‡Ø§ÛŒ Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ†
                    const fallbackURL = this.fallbackAPIs[i - 1];
                    return await this.executeRequest(fallbackURL, endpointKey, options);
                }
            } catch (error) {
                lastError = error;
                console.warn(`Attempt ${i + 1} failed:`, error);
            }
        }
        
        throw lastError;
    }
}

    

            buildURL(path, params = {}) {
                const baseURL = 'https://BrsApi.ir/Api/';
                const searchParams = new URLSearchParams(params);
                searchParams.append('key', 'BKNzfpdXhJMcUANBeAAcNT24Cdys8MES');
                return `${baseURL}${path}?${searchParams.toString()}`;
            }

            async makeRequest(endpointKey, options = {}) {
                const url = this.endpoints[endpointKey];
                if (!url) {
                    throw new Error(`Endpoint not found: ${endpointKey}`);
                }

                const cacheKey = this.generateCacheKey(endpointKey, options);
                
                if (options.useCache !== false) {
                    const cached = this.getFromCache(cacheKey);
                    if (cached) return cached;
                }

                if (this.requestQueue.has(cacheKey)) {
                    return this.requestQueue.get(cacheKey);
                }

                const requestPromise = this.executeRequest(url, endpointKey, options, cacheKey);
                this.requestQueue.set(cacheKey, requestPromise);

                try {
                    const result = await requestPromise;
                    return result;
                } finally {
                    this.requestQueue.delete(cacheKey);
                }
            }

            async executeRequest(url, endpointKey, options, cacheKey) {
                const securityManager = window.SecurityManager;
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), options.timeout || 10000);

                try {
                    const response = await axios.get(url, {
                        signal: controller.signal,
                        timeout: options.timeout || 10000,
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        ...options
                    });

                    clearTimeout(timeoutId);

                    if (!this.validateResponse(response, endpointKey)) {
                        throw new Error(`Invalid response for ${endpointKey}`);
                    }

                    const encryptedData = securityManager.encryptData(JSON.stringify(response.data));
                    
                    this.setCache(cacheKey, response.data);

                    securityManager.logSecurityEvent('API_SUCCESS', endpointKey);
                    
                    return response.data;

                } catch (error) {
                    clearTimeout(timeoutId);
                    
                    const errorDetails = {
                        endpoint: endpointKey,
                        url: url,
                        error: error.message,
                        timestamp: new Date().toISOString()
                    };

                    securityManager.logSecurityEvent('API_ERROR', JSON.stringify(errorDetails));
                    
                    if (options.useFallback !== false) {
                        return this.getFallbackData(endpointKey);
                    }
                    
                    throw error;
                }
            }

            validateResponse(response, endpointKey) {
                if (response.status !== 200) return false;
                
                const schema = this.getResponseSchema(endpointKey);
                return window.SecurityManager.validateAPIResponse(response.data, schema);
            }

            getResponseSchema(endpointKey) {
                const arrayEndpoints = [
                    'stockSymbols', 'stockIndex', 'farabourseIndex', 'crypto',
                    'commodityMetals', 'commodityBaseMetals', 'commodityEnergy',
                    'gold', 'currency', 'crypto2'
                ];
                
                return arrayEndpoints.includes(endpointKey) ? 'array' : 'object';
            }

            generateCacheKey(endpointKey, options) {
                return `${endpointKey}_${JSON.stringify(options)}`;
            }

            getFromCache(key) {
                const cached = this.cache.get(key);
                if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
                    return cached.data;
                }
                this.cache.delete(key);
                return null;
            }

            setCache(key, data) {
                this.cache.set(key, {
                    data: data,
                    timestamp: Date.now()
                });
            }

            clearCache() {
                this.cache.clear();
                window.SecurityManager.logSecurityEvent('CACHE_CLEARED', 'All cache cleared');
            }

            getFallbackData(endpointKey) {
                const fallbackGenerators = {
                    'stockSymbols': () => this.generateMockStocks(),
                    'stockIndex': () => this.generateMockIndices(),
                    'farabourseIndex': () => this.generateMockIndices(),
                    'crypto': () => this.generateMockCrypto(),
                    'commodityMetals': () => this.generateMockCommodities(),
                    'commodityBaseMetals': () => this.generateMockCommodities(),
                    'commodityEnergy': () => this.generateMockCommodities(),
                    'gold': () => this.generateMockGold(),
                    'currency': () => this.generateMockCurrency(),
                    'crypto2': () => this.generateMockCrypto()
                };

                return fallbackGenerators[endpointKey] ? fallbackGenerators[endpointKey]() : [];
            }

            generateMockStocks() {
                const symbols = ['Ø´ØªØ±Ø§Ù†', 'ÙÙˆÙ„Ø§Ø¯', 'Ø®Ø³Ø§Ù¾Ø§', 'ÙˆØ¨ØµØ§Ø¯Ø±', 'Ø´Ù¾Ù†Ø§', 'Ú©Ú¯Ù„', 'ÙÙ…Ù„ÛŒ', 'ÙˆØªØ¬Ø§Ø±Øª', 'Ø®Ù¾Ø§Ø±Ø³', 'Ø¨Ø±Ú©Øª'];
                return symbols.map(symbol => ({
                    symbol: symbol,
                    name: `Ø´Ø±Ú©Øª ${symbol}`,
                    price: Math.floor(Math.random() * 50000) + 10000,
                    change: (Math.random() * 2000) - 1000,
                    changePercent: (Math.random() * 10) - 5,
                    volume: Math.floor(Math.random() * 10000000),
                    value: Math.floor(Math.random() * 500000000000),
                    high: Math.floor(Math.random() * 60000) + 10000,
                    low: Math.floor(Math.random() * 40000) + 5000
                }));
            }

            generateMockIndices() {
                const indices = ['Ø´Ø§Ø®Øµ Ú©Ù„', 'Ø´Ø§Ø®Øµ Ù‡Ù… ÙˆØ²Ù†', 'Ø´Ø§Ø®Øµ ØµÙ†Ø¹Øª', 'Ø´Ø§Ø®Øµ Ù…Ø§Ù„ÛŒ'];
                return indices.map(name => ({
                    name: name,
                    value: Math.floor(Math.random() * 5000000) + 2000000,
                    change: (Math.random() * 50000) - 25000,
                    changePercent: (Math.random() * 5) - 2.5,
                    high: Math.floor(Math.random() * 6000000) + 2000000,
                    low: Math.floor(Math.random() * 4000000) + 1000000
                }));
            }

            generateMockCrypto() {
                const cryptos = ['Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ†', 'Ø§ØªØ±ÛŒÙˆÙ…', 'Ø±ÛŒÙ¾Ù„', 'Ú©Ø§Ø±Ø¯Ø§Ù†Ùˆ', 'Ø³ÙˆÙ„Ø§Ù†Ø§'];
                return cryptos.map(name => ({
                    name: name,
                    price: Math.floor(Math.random() * 50000) + 20000,
                    priceToman: Math.floor(Math.random() * 5000000000) + 2000000000,
                    changePercent: (Math.random() * 15) - 7.5,
                    marketCap: Math.floor(Math.random() * 1000000000000) + 500000000000
                }));
            }

            generateMockGold() {
                const goldItems = ['Ø³Ú©Ù‡ Ø§Ù…Ø§Ù…ÛŒ', 'Ø³Ú©Ù‡ Ø¨Ù‡Ø§Ø± Ø¢Ø²Ø§Ø¯ÛŒ', 'Ù†ÛŒÙ… Ø³Ú©Ù‡', 'Ø±Ø¨Ø¹ Ø³Ú©Ù‡', 'Ø·Ù„Ø§ÛŒ 18 Ø¹ÛŒØ§Ø±'];
                return goldItems.map(name => ({
                    symbol: name.replace(/\s/g, '_'),
                    name: name,
                    price: Math.floor(Math.random() * 50000000) + 50000000,
                    change: (Math.random() * 2000000) - 1000000,
                    changePercent: (Math.random() * 8) - 4,
                    unit: 'ØªÙˆÙ…Ø§Ù†'
                }));
            }

            generateMockCurrency() {
                const currencies = ['Ø¯Ù„Ø§Ø±', 'ÛŒÙˆØ±Ùˆ', 'Ù¾ÙˆÙ†Ø¯', 'Ø¯Ø±Ù‡Ù…', 'ÛŒÙ†'];
                return currencies.map(name => ({
                    symbol: name,
                    name: name,
                    price: Math.floor(Math.random() * 50000) + 10000,
                    change: (Math.random() * 1000) - 500,
                    changePercent: (Math.random() * 6) - 3,
                    unit: 'ØªÙˆÙ…Ø§Ù†'
                }));
            }

            generateMockCommodities() {
                const commodities = ['Ù†ÙØª Ø¨Ø±Ù†Øª', 'Ø·Ù„Ø§ÛŒ Ø¬Ù‡Ø§Ù†ÛŒ', 'Ù†Ù‚Ø±Ù‡', 'Ù…Ø³', 'Ø¢Ù„ÙˆÙ…ÛŒÙ†ÛŒÙˆÙ…'];
                return commodities.map(name => ({
                    symbol: name.replace(/\s/g, '_'),
                    name: name,
                    price: Math.floor(Math.random() * 200) + 50,
                    change: (Math.random() * 10) - 5,
                    changePercent: (Math.random() * 8) - 4,
                    unit: 'Ø¯Ù„Ø§Ø±'
                }));
            }
        }

        // ===============================
        // Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª Ø±Ø§Ø¨Ø· Ú©Ø§Ø±Ø¨Ø±ÛŒ
        // ===============================
        class UIManager {
            constructor() {
                this.debounceTimers = new Map();
                this.intersectionObservers = new Map();
            }

            init() {
                this.setupEventListeners();
                this.setupTabs();
                this.initializeCharts();
                this.setupPerformanceMonitoring();
            }

            setupEventListeners() {
                document.addEventListener('click', this.handleGlobalClick.bind(this));
                this.setupDebouncedInputs();
                        document.addEventListener('click', (event) => {
        const target = event.target;
        if (target.classList.contains('tab')) {
            const tabId = target.getAttribute('data-tab');
            if (tabId === 'feature-importance') {
                window.FinancialAnalysisApp.performAdvancedFeatureAnalysis();
            } else if (tabId === 'model-interpretability') {
                window.FinancialAnalysisApp.performModelInterpretabilityAnalysis();
            } else if (tabId === 'advanced-sentiment') {
                window.FinancialAnalysisApp.performAdvancedSentimentAnalysis();
            }
        }
    });
}
            }

            handleGlobalClick(event) {
                const target = event.target;
                
                if (target.classList.contains('tab')) {
                    this.handleTabClick(target);
                } else if (target.id === 'refreshBtn') {
                    this.debounce('refresh', () => window.FinancialAnalysisApp.loadMarketData(), 300);
                } else if (target.id === 'analyzeBtn') {
                    this.debounce('analyze', () => window.FinancialAnalysisApp.performAIAnalysis(), 300);
                } else if (target.id === 'securityBtn') {
                    this.debounce('security', () => window.FinancialAnalysisApp.testSecurity(), 300);
                }
            }

            handleTabClick(tab) {
                const tabs = document.querySelectorAll('.tab');
                tabs.forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                tab.classList.add('active');
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(`${tabId}-tab`).classList.add('active');
                
                if (tabId === 'explanations') {
                    window.FinancialAnalysisApp.loadXAIExplanations();
                } else if (tabId === 'transformer') {
                    window.FinancialAnalysisApp.loadTransformerPredictions();
                } else if (tabId === 'security') {
                    window.FinancialAnalysisApp.updateSecurityTab();
                }
            }

            setupDebouncedInputs() {
                const debouncedInputs = {
                    'marketType': (value) => window.FinancialAnalysisApp.updateCharts(),
                    'timeFrame': (value) => window.FinancialAnalysisApp.updateCharts()
                };

                Object.keys(debouncedInputs).forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', this.debounce(
                            id, 
                            () => debouncedInputs[id](element.value), 
                            500
                        ));
                    }
                });
            }

            debounce(key, func, wait) {
                if (this.debounceTimers.has(key)) {
                    clearTimeout(this.debounceTimers.get(key));
                }
                
                const timer = setTimeout(() => {
                    func();
                    this.debounceTimers.delete(key);
                }, wait);
                
                this.debounceTimers.set(key, timer);
            }

            setupTabs() {
                const tabs = document.querySelectorAll('.tab');
                tabs.forEach(tab => {
                    tab.addEventListener('click', () => this.handleTabClick(tab));
                });
            }

            initializeCharts() {
                const chartContainers = [
                    'indicesChart', 'priceChart', 'connectionChart', 'featureImportanceChart',
                    'shapChart', 'limeChart', 'counterfactualChart', 'transformerPredictionsChart'
                ];

                chartContainers.forEach(containerId => {
                    this.createEmptyChart(containerId, 'Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ...');
                });
            }

            createEmptyChart(containerId, title) {
                const layout = {
                    title: title,
                    xaxis: { title: 'Ø²Ù…Ø§Ù†' },
                    yaxis: { title: 'Ù…Ù‚Ø¯Ø§Ø±' },
                    font: { family: 'Tahoma' },
                    showlegend: false
                };
                
                Plotly.newPlot(containerId, [], layout, { responsive: true });
            }

            showNotification(message, type = 'info') {
                const existingNotification = document.querySelector('.notification');
                if (existingNotification) {
                    existingNotification.remove();
                }
                
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                
                notification.innerHTML = `
                    <div>${message}</div>
                    <button class="close-notification" onclick="this.parentElement.remove()">Ã—</button>
                `;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 5000);
            }

            toggleSidebar() {
                const sidebar = document.getElementById('sidebar');
                sidebar.classList.toggle('active');
            }

            setupPerformanceMonitoring() {
                if ('PerformanceObserver' in window) {
                    const observer = new PerformanceObserver((list) => {
                        const entries = list.getEntries();
                        entries.forEach(entry => {
                            if (entry.entryType === 'measure') {
                                this.updatePerformanceMetrics(entry);
                            }
                        });
                    });
                    
                    observer.observe({ entryTypes: ['measure'] });
                }
            }

            updatePerformanceMetrics(entry) {
                const meter = document.getElementById('performanceMeter');
                const text = document.getElementById('performanceText');
                
                if (entry.duration < 100) {
                    meter.style.background = 'var(--success)';
                    meter.style.width = '95%';
                    text.textContent = 'Ø¹Ø§Ù„ÛŒ';
                } else if (entry.duration < 500) {
                    meter.style.background = 'var(--warning)';
                    meter.style.width = '75%';
                    text.textContent = 'Ø®ÙˆØ¨';
                } else {
                    meter.style.background = 'var(--danger)';
                    meter.style.width = '50%';
                    text.textContent = 'Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¨Ù‡Ø¨ÙˆØ¯';
                }
            }

            showLoading(elementId, message) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerHTML = `<div class="loading">${message}</div>`;
                }
            }

            showError(elementId, message) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerHTML = `<div class="loading" style="color: #dc3545;">${message}</div>`;
                }
            }
        }

        // ===============================
        // Ø³ÛŒØ³ØªÙ… Ù†Ø¸Ø§Ø±Øª Ù‡ÙˆØ´Ù…Ù†Ø¯ API
        // ===============================
        class APIMonitoringSystem {
            constructor() {
                this.apiStatus = {};
                this.connectionHistory = [];
                this.alerts = [];
                this.monitoringInterval = null;
                this.isMonitoring = false;
                
                this.initializeMonitoring();
            }

            initializeMonitoring() {
                const API_ENDPOINTS = {
                    stockSymbols: 'https://BrsApi.ir/Api/Tsetmc/AllSymbols.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES',
                    stockIndex: 'https://BrsApi.ir/Api/Tsetmc/Index.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=1',
                    farabourseIndex: 'https://BrsApi.ir/Api/Tsetmc/Index.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=2',
                    crypto: 'https://BrsApi.ir/Api/Market/Cryptocurrency.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES',
                    commodityMetals: 'https://BrsApi.ir/Api/Market/Commodity.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=1',
                    commodityBaseMetals: 'https://BrsApi.ir/Api/Market/Commodity.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=2',
                    commodityEnergy: 'https://BrsApi.ir/Api/Market/Commodity.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=3',
                    gold: 'https://BrsApi.ir/Api/Market/Gold_Currency.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=1',
                    currency: 'https://BrsApi.ir/Api/Market/Gold_Currency.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=2',
                    crypto2: 'https://BrsApi.ir/Api/Market/Gold_Currency.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=3'
                };

                const API_NAMES = {
                    stockSymbols: 'Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ Ø¨ÙˆØ±Ø³',
                    stockIndex: 'Ø´Ø§Ø®Øµ Ø¨ÙˆØ±Ø³',
                    farabourseIndex: 'Ø´Ø§Ø®Øµ ÙØ±Ø§Ø¨ÙˆØ±Ø³',
                    crypto: 'Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„',
                    commodityMetals: 'ÙÙ„Ø²Ø§Øª Ú¯Ø±Ø§Ù†Ø¨Ù‡Ø§',
                    commodityBaseMetals: 'ÙÙ„Ø²Ø§Øª Ø§Ø³Ø§Ø³ÛŒ',
                    commodityEnergy: 'Ø§Ù†Ø±Ú˜ÛŒ',
                    gold: 'Ø·Ù„Ø§ Ùˆ Ø³Ú©Ù‡',
                    currency: 'Ø§Ø±Ø²',
                    crypto2: 'Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„ (Ù…Ù†Ø¨Ø¹ Û²)'
                };

                for (const [key, url] of Object.entries(API_ENDPOINTS)) {
                    this.apiStatus[key] = {
                        name: API_NAMES[key],
                        url: url,
                        status: 'unknown',
                        lastCheck: null,
                        responseTime: null,
                        successRate: 0,
                        errorCount: 0,
                        successCount: 0,
                        lastError: null,
                        shouldBeActive: this.shouldAPIBeActive(key)
                    };
                }
            }

            shouldAPIBeActive(apiKey) {
                const tehranTime = this.getTehranTime();
                const hour = tehranTime.getHours();
                const minute = tehranTime.getMinutes();
                const day = tehranTime.getDay();
                
                if (apiKey.includes('stock') || apiKey.includes('Index')) {
                    if (day >= 5) return false;
                    if (hour < 9 || hour > 12) return false;
                    if (hour === 12 && minute > 30) return false;
                }
                
                return true;
            }

            getTehranTime() {
                const now = new Date();
                const tehranOffset = 3.5 * 60 * 60 * 1000;
                return new Date(now.getTime() + tehranOffset);
            }

            startAutoMonitoring() {
                if (this.monitoringInterval) {
                    clearInterval(this.monitoringInterval);
                }
                
                this.isMonitoring = true;
                this.monitoringInterval = setInterval(() => {
                    this.checkAllAPIs();
                }, 60000);
                
                this.checkAllAPIs();
                
                window.UIManager.showNotification('Ø³ÛŒØ³ØªÙ… Ù†Ø¸Ø§Ø±Øª Ø®ÙˆØ¯Ú©Ø§Ø± APIÙ‡Ø§ ÙØ¹Ø§Ù„ Ø´Ø¯', 'success');
            }

            async checkAllAPIs() {
                const promises = [];
                
                for (const [key, apiInfo] of Object.entries(this.apiStatus)) {
                    promises.push(this.checkSingleAPI(key, apiInfo));
                }
                
                await Promise.allSettled(promises);
                this.updateMonitoringDisplay();
            }

            async checkSingleAPI(apiKey, apiInfo) {
                apiInfo.shouldBeActive = this.shouldAPIBeActive(apiKey);
                
                if (!apiInfo.shouldBeActive) {
                    apiInfo.status = 'inactive_hours';
                    apiInfo.lastCheck = new Date();
                    return;
                }

                try {
                    const startTime = Date.now();
                    const response = await axios.get(apiInfo.url, {
                        timeout: 10000,
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    const responseTime = Date.now() - startTime;
                    
                    apiInfo.status = 'connected';
                    apiInfo.lastCheck = new Date();
                    apiInfo.responseTime = responseTime;
                    apiInfo.successCount++;
                    apiInfo.lastError = null;
                    
                    const totalRequests = apiInfo.successCount + apiInfo.errorCount;
                    apiInfo.successRate = totalRequests > 0 ? (apiInfo.successCount / totalRequests) * 100 : 0;
                    
                    this.connectionHistory.push({
                        api: apiKey,
                        timestamp: new Date(),
                        status: 'success',
                        responseTime: responseTime
                    });
                    
                } catch (error) {
                    apiInfo.status = 'disconnected';
                    apiInfo.lastCheck = new Date();
                    apiInfo.errorCount++;
                    apiInfo.lastError = error.message;
                    
                    const totalRequests = apiInfo.successCount + apiInfo.errorCount;
                    apiInfo.successRate = totalRequests > 0 ? (apiInfo.successCount / totalRequests) * 100 : 0;
                    
                    this.connectionHistory.push({
                        api: apiKey,
                        timestamp: new Date(),
                        status: 'error',
                        error: error.message
                    });
                    
                    this.sendAlert(apiKey, `Ù‚Ø·Ø¹ Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§ ${apiInfo.name}`, error.message);
                }
            }

            sendAlert(apiKey, title, message) {
                const alert = {
                    id: Date.now(),
                    apiKey: apiKey,
                    apiName: this.apiStatus[apiKey].name,
                    title: title,
                    message: message,
                    timestamp: new Date(),
                    read: false
                };
                
                this.alerts.unshift(alert);
                
                window.UIManager.showNotification(`ğŸš¨ ${title}: ${message}`, 'error');
                
                if (this.alerts.length > 50) {
                    this.alerts = this.alerts.slice(0, 50);
                }
                
                this.updateAlertsDisplay();
            }

            updateMonitoringDisplay() {
                this.updateSidebarStatus();
                this.updateConnectionStats();
            }

            updateSidebarStatus() {
                const container = document.getElementById('apiStatusContainer');
                let html = '';
                
                for (const [key, apiInfo] of Object.entries(this.apiStatus)) {
                    let statusClass = 'api-status ';
                    let statusText = '';
                    let indicatorClass = '';
                    
                    if (!apiInfo.shouldBeActive) {
                        statusClass += 'warning';
                        statusText = 'â¸ ØºÛŒØ±ÙØ¹Ø§Ù„ (Ø³Ø§Ø¹Ø§Øª Ú©Ø§Ø±ÛŒ)';
                        indicatorClass = 'status-warning';
                    } else if (apiInfo.status === 'connected') {
                        statusClass += 'connected';
                        statusText = `âœ… Ù…ØªØµÙ„ (${apiInfo.responseTime}ms)`;
                        indicatorClass = 'status-connected';
                    } else if (apiInfo.status === 'disconnected') {
                        statusClass += 'disconnected';
                        statusText = 'âŒ Ù‚Ø·Ø¹ Ø§Ø±ØªØ¨Ø§Ø·';
                        indicatorClass = 'status-disconnected';
                    } else {
                        statusClass += 'warning';
                        statusText = 'ğŸ” Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø±Ø±Ø³ÛŒ...';
                        indicatorClass = 'status-warning';
                    }
                    
                    html += `
                        <div class="${statusClass}">
                            <div>
                                <strong>${apiInfo.name}</strong>
                                <br>
                                <small>${statusText}</small>
                            </div>
                            <span class="status-indicator ${indicatorClass}"></span>
                        </div>
                    `;
                }
                
                container.innerHTML = html;
            }

            updateConnectionStats() {
                let connected = 0;
                let disconnected = 0;
                let total = 0;
                
                for (const apiInfo of Object.values(this.apiStatus)) {
                    if (apiInfo.shouldBeActive) {
                        total++;
                        if (apiInfo.status === 'connected') {
                            connected++;
                        } else if (apiInfo.status === 'disconnected') {
                            disconnected++;
                        }
                    }
                }
                
                document.getElementById('connectedCount').textContent = connected;
                document.getElementById('disconnectedCount').textContent = disconnected;
                document.getElementById('totalCount').textContent = total;
            }

            updateAlertsDisplay() {
                const container = document.getElementById('recentAlerts');
                if (!container) return;

                const alertsHTML = this.alerts.slice(0, 5).map(alert => `
                    <div style="padding: 10px; border-bottom: 1px solid #eee;">
                        <strong>${alert.title}</strong>
                        <br>
                        <small>${alert.message}</small>
                        <br>
                        <small style="color: #666;">${new Date(alert.timestamp).toLocaleString('fa-IR')}</small>
                    </div>
                `).join('');

                container.innerHTML = alertsHTML || '<div>Ù‡ÛŒÚ† Ù‡Ø´Ø¯Ø§Ø±ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯</div>';
            }
        }

        // ===============================
        // Ú©Ù„Ø§Ø³â€ŒÙ‡Ø§ÛŒ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ
        // ===============================
        const ExplanationType = {
            COUNTERFACTUAL: "counterfactual",
            CONTRASTIVE: "contrastive",
            CAUSAL: "causal",
            EXAMPLE_BASED: "example_based",
            FEATURE_BASED: "feature_based"
        };

        const ConfidenceLevel = {
            VERY_HIGH: "very_high",
            HIGH: "high",
            MEDIUM: "medium",
            LOW: "low",
            VERY_LOW: "very_low"
        };

        const DecisionImpact = {
            STRONG_POSITIVE: "strong_positive",
            POSITIVE: "positive",
            NEUTRAL: "neutral",
            NEGATIVE: "negative",
            STRONG_NEGATIVE: "strong_negative"
        };

        class AdvancedDecisionExplainer {
            constructor(config = {}) {
                this.config = {
                    counterfactual_samples: 1000,
                    similarity_threshold: 0.8,
                    max_counterfactuals: 5,
                    confidence_thresholds: {
                        'very_high': 0.9,
                        'high': 0.8,
                        'medium': 0.7,
                        'low': 0.6,
                        'very_low': 0.5
                    },
                    ...config
                };
            }

            explain_decision(model, instance, feature_names, training_data = null, explanation_type = ExplanationType.COUNTERFACTUAL) {
                try {
                    const [prediction, confidence] = this._get_prediction_with_confidence(instance);
                    const confidence_level = this._get_confidence_level(confidence);
                    const key_factors = this._analyze_key_factors(instance, prediction);
                    const counterfactuals = this._generate_counterfactuals(instance, prediction);
                    
                    return {
                        prediction: prediction,
                        confidence: confidence,
                        confidence_level: confidence_level,
                        key_factors: key_factors,
                        counterfactuals: counterfactuals,
                        explanation_type: explanation_type,
                        rationale: this._generate_rationale(prediction, key_factors, counterfactuals)
                    };
                    
                } catch (error) {
                    ErrorHandler.logError({
                        type: 'DecisionExplanationError',
                        error: error.message
                    });
                    throw error;
                }
            }

            _get_prediction_with_confidence(instance) {
                const prediction = Math.random() * 2 - 1;
                const confidence = 0.7 + Math.random() * 0.3;
                return [prediction, confidence];
            }

            _get_confidence_level(confidence) {
                const thresholds = this.config.confidence_thresholds;
                
                if (confidence >= thresholds.very_high) return ConfidenceLevel.VERY_HIGH;
                if (confidence >= thresholds.high) return ConfidenceLevel.HIGH;
                if (confidence >= thresholds.medium) return ConfidenceLevel.MEDIUM;
                if (confidence >= thresholds.low) return ConfidenceLevel.LOW;
                return ConfidenceLevel.VERY_LOW;
            }

            _analyze_key_factors(instance, prediction) {
                const key_factors = [];
                const num_features = 8;
                const feature_names = ['Ù‚ÛŒÙ…Øª', 'Ø­Ø¬Ù…', 'RSI', 'MACD', 'Ù†ÙˆØ³Ø§Ù†', 'Ø§Ø±Ø²Ø´ Ø¨Ø§Ø²Ø§Ø±', 'P/E', 'ØªØºÛŒÛŒØ±Ø§Øª'];
                
                for (let i = 0; i < num_features; i++) {
                    const feature_name = feature_names[i];
                    const contribution = (Math.random() * 2 - 1) * 0.5;
                    const impact = this._determine_impact(contribution, prediction);
                    
                    key_factors.push([feature_name, contribution, impact]);
                }
                
                key_factors.sort((a, b) => Math.abs(b[1]) - Math.abs(a[1]));
                
                return key_factors.slice(0, 5);
            }

            _determine_impact(contribution, prediction) {
                const thresholds = {
                    'strong_positive': 0.3,
                    'positive': 0.1,
                    'negative': -0.1,
                    'strong_negative': -0.3
                };
                
                let normalized_contrib = contribution;
                
                if (Math.abs(prediction) > 0) {
                    normalized_contrib = contribution / Math.abs(prediction);
                }
                
                if (normalized_contrib >= thresholds.strong_positive) return DecisionImpact.STRONG_POSITIVE;
                if (normalized_contrib >= thresholds.positive) return DecisionImpact.POSITIVE;
                if (normalized_contrib <= thresholds.strong_negative) return DecisionImpact.STRONG_NEGATIVE;
                if (normalized_contrib <= thresholds.negative) return DecisionImpact.NEGATIVE;
                return DecisionImpact.NEUTRAL;
            }

            _generate_counterfactuals(instance, prediction) {
                const counterfactuals = [];
                const key_factors = this._analyze_key_factors(instance, prediction);
                
                for (const [feature_name, contribution, impact] of key_factors.slice(0, 2)) {
                    let action = "optimize";
                    if (impact === DecisionImpact.NEGATIVE || impact === DecisionImpact.STRONG_NEGATIVE) {
                        action = "increase";
                    } else if (impact === DecisionImpact.POSITIVE || impact === DecisionImpact.STRONG_POSITIVE) {
                        action = "maintain";
                    }
                    
                    const counterfactual = this._create_counterfactual(feature_name, contribution, action);
                    if (counterfactual) {
                        counterfactuals.push(counterfactual);
                    }
                }
                
                return counterfactuals.slice(0, this.config.max_counterfactuals);
            }

            _create_counterfactual(feature_name, contribution, action) {
                let suggested_value, expected_impact, description;
                
                if (action === "increase") {
                    suggested_value = 'Ø§ÙØ²Ø§ÛŒØ´ Û²Û°Ùª';
                    expected_impact = Math.abs(contribution) * 0.8;
                    description = `Ø§ÙØ²Ø§ÛŒØ´ ${feature_name} Ø¨Ø±Ø§ÛŒ Ø¨Ù‡Ø¨ÙˆØ¯ ØªØ§Ø«ÛŒØ± Ù…Ø«Ø¨Øª`;
                } else if (action === "maintain") {
                    suggested_value = 'Ø­ÙØ¸ Ø³Ø·Ø­ ÙØ¹Ù„ÛŒ';
                    expected_impact = Math.abs(contribution) * 0.9;
                    description = `Ø­ÙØ¸ Ø³Ø·Ø­ ÙØ¹Ù„ÛŒ ${feature_name} Ø¨Ø±Ø§ÛŒ Ø­ÙØ¸ Ù…Ø²Ø§ÛŒØ§`;
                } else {
                    suggested_value = 'Ú©Ø§Ù‡Ø´ Û±Û°Ùª';
                    expected_impact = Math.abs(contribution) * 0.5;
                    description = `Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ ${feature_name} Ø¨Ø±Ø§ÛŒ ØªØ¹Ø§Ø¯Ù„ Ø¨Ù‡ØªØ±`;
                }
                
                return {
                    feature: feature_name,
                    suggested_value: suggested_value,
                    expected_impact: expected_impact,
                    confidence: Math.min(0.8, Math.abs(contribution)),
                    description: description
                };
            }

            _generate_rationale(prediction, key_factors, counterfactuals) {
                const rationale_parts = [];
                
                rationale_parts.push(`Ù…Ø¯Ù„ Ù…Ù‚Ø¯Ø§Ø± ${prediction.toFixed(4)} Ø±Ø§ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.`);
                
                const top_positive = key_factors.filter(f => f[2] === DecisionImpact.POSITIVE || f[2] === DecisionImpact.STRONG_POSITIVE).slice(0, 2);
                const top_negative = key_factors.filter(f => f[2] === DecisionImpact.NEGATIVE || f[2] === DecisionImpact.STRONG_NEGATIVE).slice(0, 2);
                
                if (top_positive.length > 0) {
                    const pos_features = top_positive.map(f => f[0]).join(', ');
                    rationale_parts.push(`Ø¹ÙˆØ§Ù…Ù„ Ú©Ù„ÛŒØ¯ÛŒ Ù…Ø«Ø¨Øª Ø´Ø§Ù…Ù„: ${pos_features} Ù…ÛŒâ€ŒØ´ÙˆØ¯.`);
                }
                
                if (top_negative.length > 0) {
                    const neg_features = top_negative.map(f => f[0]).join(', ');
                    rationale_parts.push(`Ø¹ÙˆØ§Ù…Ù„ Ú©Ù„ÛŒØ¯ÛŒ Ù…Ù†ÙÛŒ Ø´Ø§Ù…Ù„: ${neg_features} Ù…ÛŒâ€ŒØ´ÙˆØ¯.`);
                }
                
                return rationale_parts.join(' ');
            }
        }

        class MarketSentimentTransformer {
            constructor(config = {}) {
                this.config = {
                    sentiment_thresholds: {
                        'very_bearish': -0.6,
                        'bearish': -0.2,
                        'neutral': 0.2,
                        'bullish': 0.6
                    },
                    ...config
                };
                
                this.financial_lexicon = this._load_financial_lexicon();
            }

            _load_financial_lexicon() {
                return {
                    'bullish': 0.8, 'rally': 0.7, 'surge': 0.8, 'soar': 0.9, 'jump': 0.6,
                    'gain': 0.5, 'profit': 0.4, 'growth': 0.6, 'optimistic': 0.7,
                    'positive': 0.5, 'strong': 0.4, 'outperform': 0.7, 'buy': 0.8,
                    'bearish': -0.8, 'plunge': -0.9, 'slump': -0.7, 'drop': -0.6,
                    'fall': -0.5, 'loss': -0.6, 'decline': -0.5, 'pessimistic': -0.7,
                    'negative': -0.5, 'weak': -0.4, 'underperform': -0.7, 'sell': -0.8
                };
            }

            analyze_sentiment(text) {
                if (!text || text.trim().length === 0) {
                    return this._create_neutral_sentiment();
                }

                const processed_text = this.preprocess_text(text);
                const rule_based_result = this.rule_based_sentiment(processed_text);

                const final_score = rule_based_result.score;
                const confidence = Math.max(0.5, 1 - rule_based_result.subjectivity);
                const sentiment_type = this._score_to_sentiment_type(final_score);

                return {
                    overall_score: final_score,
                    sentiment_type: sentiment_type,
                    confidence: confidence,
                    magnitude: Math.abs(final_score),
                    subjectivity: rule_based_result.subjectivity,
                    timestamp: new Date()
                };
            }

            preprocess_text(text) {
                text = text.replace(/http\S+/g, '');
                text = text.replace(/[^\w\s$%]/g, '');
                text = text.toLowerCase();
                text = text.split(/\s+/).join(' ');
                return text;
            }

            rule_based_sentiment(text) {
                const words = text.split(/\s+/);
                let sentiment_score = 0;
                let word_count = 0;
                let intensity_multiplier = 1.0;

                for (let i = 0; i < words.length; i++) {
                    const word = words[i];
                    if (this.financial_lexicon[word] !== undefined) {
                        if (i > 0 && ['very', 'extremely', 'highly'].includes(words[i-1])) {
                            intensity_multiplier = 1.5;
                        } else if (i > 0 && ['slightly', 'somewhat'].includes(words[i-1])) {
                            intensity_multiplier = 0.7;
                        }

                        sentiment_score += this.financial_lexicon[word] * intensity_multiplier;
                        word_count++;
                        intensity_multiplier = 1.0;
                    }
                }

                if (word_count > 0) {
                    sentiment_score /= word_count;
                }

                const subjectivity = Math.min(1, word_count / 20);

                return {
                    score: sentiment_score,
                    subjectivity: subjectivity,
                    word_count: word_count,
                    method: 'rule_based'
                };
            }

            _score_to_sentiment_type(score) {
                const thresholds = this.config.sentiment_thresholds;
                
                if (score <= thresholds.very_bearish) return 'VERY_BEARISH';
                if (score <= thresholds.bearish) return 'BEARISH';
                if (score >= thresholds.bullish) return 'BULLISH';
                if (score >= 0.8) return 'VERY_BULLISH';
                return 'NEUTRAL';
            }

            _create_neutral_sentiment() {
                return {
                    overall_score: 0.0,
                    sentiment_type: 'NEUTRAL',
                    confidence: 0.5,
                    magnitude: 0.0,
                    subjectivity: 0.5,
                    timestamp: new Date()
                };
            }
        }

        class RiskAssessorAgent {
            constructor(config = {}) {
                this.config = {
                    max_portfolio_var: 0.02,
                    max_drawdown_limit: 0.15,
                    ...config
                };
            }

            assess_risk(positions, market_conditions) {
                const var_95 = this._calculate_var(positions, 0.95);
                const max_drawdown = this._calculate_max_drawdown(positions);
                const volatility = this._calculate_volatility(positions);
                const concentration_risk = this._calculate_concentration_risk(positions);

                const overall_risk = this._determine_overall_risk_level({
                    var_95,
                    max_drawdown,
                    volatility,
                    concentration_risk
                });

                const recommendations = this._generate_risk_recommendations({
                    overall_risk,
                    var_95,
                    max_drawdown,
                    concentration_risk
                });

                return {
                    overall_risk,
                    portfolio_var: var_95,
                    max_drawdown,
                    volatility,
                    concentration_risk,
                    recommendations,
                    warnings: this._generate_risk_warnings({
                        var_95,
                        max_drawdown,
                        concentration_risk
                    })
                };
            }

            _calculate_var(positions, confidence_level) {
                const total_value = positions.reduce((sum, pos) => sum + pos.quantity * pos.current_price, 0);
                return total_value * (1 - confidence_level) * 0.1;
            }

            _calculate_max_drawdown(positions) {
                return Math.random() * 0.2;
            }

            _calculate_volatility(positions) {
                const returns = positions.map(p => (p.current_price - p.entry_price) / p.entry_price);
                const avg_return = returns.reduce((sum, ret) => sum + ret, 0) / returns.length;
                return Math.sqrt(returns.reduce((sum, ret) => sum + Math.pow(ret - avg_return, 2), 0) / returns.length);
            }

            _calculate_concentration_risk(positions) {
                const total_value = positions.reduce((sum, pos) => sum + pos.quantity * pos.current_price, 0);
                const max_position_value = Math.max(...positions.map(p => p.quantity * p.current_price));
                return max_position_value / total_value;
            }

            _determine_overall_risk_level(metrics) {
                const risk_score = (
                    metrics.var_95 / this.config.max_portfolio_var +
                    metrics.max_drawdown / this.config.max_drawdown_limit +
                    metrics.volatility * 10
                ) / 3;

                if (risk_score > 1.5) return 'EXTREME';
                if (risk_score > 1.2) return 'VERY_HIGH';
                if (risk_score > 1.0) return 'HIGH';
                if (risk_score > 0.8) return 'MODERATE';
                if (risk_score > 0.5) return 'LOW';
                return 'VERY_LOW';
            }

            _generate_risk_recommendations(metrics) {
                const recommendations = [];
                
                if (metrics.overall_risk === 'EXTREME' || metrics.overall_risk === 'VERY_HIGH') {
                    recommendations.push('Ú©Ø§Ù‡Ø´ ÙÙˆØ±ÛŒ Ø§Ù†Ø¯Ø§Ø²Ù‡ Ù¾ÙˆØ±ØªÙÙˆÛŒ');
                    recommendations.push('Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§ÛŒ Ù¾ÙˆØ´Ø´ Ø±ÛŒØ³Ú©');
                }
                
                if (metrics.var_95 > this.config.max_portfolio_var) {
                    recommendations.push('ØªÙ†ÙˆØ¹â€ŒØ¨Ø®Ø´ÛŒ Ø¨ÛŒØ´ØªØ± Ù¾ÙˆØ±ØªÙÙˆÛŒ');
                }
                
                if (metrics.max_drawdown > this.config.max_drawdown_limit) {
                    recommendations.push('ØªØ¹ÛŒÛŒÙ† Ø­Ø¯ Ø¶Ø±Ø± Ù…ØªØ­Ø±Ú© Ø¨Ø±Ø§ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§');
                }
                
                if (metrics.concentration_risk > 0.3) {
                    recommendations.push('Ú©Ø§Ù‡Ø´ ØªÙ…Ø±Ú©Ø² Ø±ÙˆÛŒ Ø¨Ø²Ø±Ú¯ØªØ±ÛŒÙ† Ù…ÙˆÙ‚Ø¹ÛŒØª');
                }
                
                return recommendations;
            }

            _generate_risk_warnings(metrics) {
                const warnings = [];
                
                if (metrics.var_95 > this.config.max_portfolio_var) {
                    warnings.push('VaR Ù¾ÙˆØ±ØªÙÙˆÛŒ Ø§Ø² Ø­Ø¯ Ù…Ø¬Ø§Ø² ÙØ±Ø§ØªØ± Ø±ÙØªÙ‡ Ø§Ø³Øª');
                }
                
                if (metrics.max_drawdown > this.config.max_drawdown_limit) {
                    warnings.push('Ø­Ø¯Ø§Ú©Ø«Ø± Ø§ÙØª Ø³Ø±Ù…Ø§ÛŒÙ‡ Ø§Ø² Ø­Ø¯ Ù…Ø¬Ø§Ø² Ø¨ÛŒØ´ØªØ± Ø´Ø¯Ù‡ Ø§Ø³Øª');
                }
                
                if (metrics.concentration_risk > 0.4) {
                    warnings.push('ØªÙ…Ø±Ú©Ø² Ù¾ÙˆØ±ØªÙÙˆÛŒ Ø¨Ø³ÛŒØ§Ø± Ø¨Ø§Ù„Ø§ Ø§Ø³Øª');
                }
                
                return warnings;
            }
        }

        class PricePredictionTransformer {
            constructor(config = {}) {
                this.config = {
                    prediction_horizon: 5,
                    ...config
                };
            }

            predict(features) {
                const predictions = [];
                for (let i = 0; i < this.config.prediction_horizon; i++) {
                    predictions.push({
                        predicted_price: features.current_price * (1 + (Math.random() - 0.5) * 0.1),
                        confidence: 0.7 + Math.random() * 0.3,
                        upper_bound: features.current_price * (1 + (Math.random() - 0.3) * 0.15),
                        lower_bound: features.current_price * (1 + (Math.random() - 0.7) * 0.15)
                    });
                }
                return predictions;
            }
        }

        // ===============================
        // Ú©Ù„Ø§Ø³ Ø§ØµÙ„ÛŒ Ø¨Ø±Ù†Ø§Ù…Ù‡
        // ===============================
        class FinancialAnalysisApp {
            constructor() {
                if (FinancialAnalysisApp.instance) {
                    return FinancialAnalysisApp.instance;
                }
                FinancialAnalysisApp.instance = this;

                this.errorHandler = ErrorHandler;
                this.securityManager = new SecurityManager();
                this.apiService = new APIService();
                this.uiManager = new UIManager();
                this.monitoringSystem = new APIMonitoringSystem();
                
                this.marketData = {
                    stocks: [],
                    indices: [],
                    crypto: [],
                    gold: [],
                    currency: [],
                    commodities: []
                };

                 this.aiModels = {
            decisionExplainer: new AdvancedDecisionExplainer(),
            featureImportance: new AdvancedFeatureImportance(),
            sentimentAnalyzer: new MarketSentimentTransformer(),
            riskAssessor: new RiskAssessorAgent(),
            pricePredictor: new PricePredictionTransformer(),
            modelInterpreter: new AdvancedModelInterpreter()
        };

                this.init();
            }

            static getInstance() {
                if (!FinancialAnalysisApp.instance) {
                    FinancialAnalysisApp.instance = new FinancialAnalysisApp();
                }
                return FinancialAnalysisApp.instance;
            }

            init() {
                this.errorHandler.init();
                this.uiManager.init();
                this.setupGlobalEventListeners();
                
                this.loadMarketData();
                this.updateTechnicalIndicators();
                this.updateRiskMetrics();
                
                this.monitoringSystem.startAutoMonitoring();
                
                setTimeout(() => {
                    this.securityManager.testSecurity();
                }, 3000);
            }

            setupGlobalEventListeners() {
                document.getElementById('refreshBtn').addEventListener('click', () => this.loadMarketData());
                document.getElementById('analyzeBtn').addEventListener('click', () => this.performAIAnalysis());
                document.getElementById('riskBtn').addEventListener('click', () => this.performRiskAssessment());
                document.getElementById('tradeBtn').addEventListener('click', () => this.generateTradeSuggestions());
                document.getElementById('monitorBtn').addEventListener('click', () => this.monitoringSystem.checkAllAPIs());
                document.getElementById('securityBtn').addEventListener('click', () => this.testSecurity());
                
                document.getElementById('encryptDataBtn')?.addEventListener('click', () => this.encryptAllData());
                document.getElementById('clearCacheBtn')?.addEventListener('click', () => this.clearCache());
                document.getElementById('testSecurityBtn')?.addEventListener('click', () => this.testSecurity());
            }

            async loadMarketData() {
                try {
                    this.uiManager.showLoading('marketStatus', 'Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±...');
                    this.uiManager.showNotification('Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø¢Ø®Ø±ÛŒÙ† Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ø§Ø²Ø§Ø±...', 'info');

                    const requests = [
                        this.apiService.makeRequest('stockSymbols'),
                        this.apiService.makeRequest('stockIndex'),
                        this.apiService.makeRequest('crypto'),
                        this.apiService.makeRequest('gold'),
                        this.apiService.makeRequest('currency'),
                        this.apiService.makeRequest('commodityMetals')
                    ];

                    const results = await Promise.allSettled(requests);

                    this.processMarketDataResults(results);

                    this.updateMarketStatus();
                    this.updateCharts();
                    this.updateAdvancedAnalysis();
                    this.updateTechnicalIndicators();
                    this.updateRiskMetrics();

                    this.uiManager.showNotification('Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ø§Ø²Ø§Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯', 'success');

                } catch (error) {
                    this.errorHandler.handleGlobalError({
                        error: error,
                        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±'
                    });
                }
            }

            processMarketDataResults(results) {
                const processors = {
                    0: (data) => this.marketData.stocks = this.processRealStockData(data),
                    1: (data) => this.marketData.indices = this.processRealIndexData(data),
                    2: (data) => this.marketData.crypto = this.processRealCryptoData(data),
                    3: (data) => this.marketData.gold = this.processRealGoldData(data),
                    4: (data) => this.marketData.currency = this.processRealCurrencyData(data),
                    5: (data) => this.marketData.commodities = this.processRealCommodityData(data)
                };

                results.forEach((result, index) => {
                    if (result.status === 'fulfilled' && result.value) {
                        processors[index](result.value);
                    } else {
                        const endpointKey = Object.keys(this.apiService.endpoints)[index];
                        const fallbackData = this.apiService.getFallbackData(endpointKey);
                        processors[index](fallbackData);
                    }
                });
            }

            processRealStockData(apiData) {
                if (!apiData || !Array.isArray(apiData)) {
                    return this.apiService.generateMockStocks();
                }

                return apiData.slice(0, 10).map(item => ({
                    symbol: item.l18 || 'N/A',
                    name: item.l30 || 'N/A',
                    price: item.pl || item.pc || 0,
                    change: item.plc || item.pcc || 0,
                    changePercent: item.plp || item.pcp || 0,
                    volume: item.tvol || 0,
                    value: item.tval || 0
                }));
            }

            processRealIndexData(apiData) {
                if (!apiData || !Array.isArray(apiData)) {
                    return this.apiService.generateMockIndices();
                }

                return apiData.map(item => ({
                    name: item.name || 'N/A',
                    value: item.index || 0,
                    change: item.index_change || 0,
                    changePercent: item.index_change_percent || 0
                }));
            }

            processRealCryptoData(apiData) {
                if (!apiData || !Array.isArray(apiData)) {
                    return this.apiService.generateMockCrypto();
                }

                return apiData.slice(0, 5).map(item => ({
                    name: item.name || 'N/A',
                    price: item.price || 0,
                    changePercent: item.change_percent || 0,
                    marketCap: item.market_cap || 0
                }));
            }

            processRealGoldData(apiData) {
                if (!apiData || !Array.isArray(apiData)) {
                    return this.apiService.generateMockGold();
                }

                return apiData.map(item => ({
                    symbol: item.symbol || 'N/A',
                    name: item.name || 'N/A',
                    price: item.price || 0,
                    change: item.change_value || 0,
                    changePercent: item.change_percent || 0
                }));
            }

            processRealCurrencyData(apiData) {
                if (!apiData || !Array.isArray(apiData)) {
                    return this.apiService.generateMockCurrency();
                }

                return apiData.map(item => ({
                    symbol: item.symbol || 'N/A',
                    name: item.name || 'N/A',
                    price: item.price || 0,
                    change: item.change_value || 0,
                    changePercent: item.change_percent || 0
                }));
            }

            processRealCommodityData(apiData) {
                if (!apiData || !Array.isArray(apiData)) {
                    return this.apiService.generateMockCommodities();
                }

                return apiData.map(item => ({
                    symbol: item.symbol || 'N/A',
                    name: item.name || 'N/A',
                    price: item.price || 0,
                    change: item.change_value || 0,
                    changePercent: item.change_percent || 0
                }));
            }

            updateMarketStatus() {
                const container = document.getElementById('marketStatus');
                const marketType = document.getElementById('marketType').value;
                
                let items = [];
                
                if (marketType === 'all' || marketType === 'stock') {
                    items = items.concat(
                        this.marketData.stocks.slice(0, 6).map(stock => this.createMarketItem(stock, 'stock'))
                    );
                }
                
                if (marketType === 'all' || marketType === 'crypto') {
                    items = items.concat(
                        this.marketData.crypto.slice(0, 6).map(crypto => this.createMarketItem(crypto, 'crypto'))
                    );
                }
                
                if (marketType === 'all' || marketType === 'gold') {
                    items = items.concat(
                        this.marketData.gold.slice(0, 6).map(gold => this.createMarketItem(gold, 'gold'))
                    );
                }
                
                if (marketType === 'all' || marketType === 'currency') {
                    items = items.concat(
                        this.marketData.currency.slice(0, 6).map(currency => this.createMarketItem(currency, 'currency'))
                    );
                }
                
                if (marketType === 'all' || marketType === 'commodity') {
                    items = items.concat(
                        this.marketData.commodities.slice(0, 6).map(commodity => this.createMarketItem(commodity, 'commodity'))
                    );
                }
                
                container.innerHTML = items.join('');
            }

            createMarketItem(item, type) {
                const changeClass = item.changePercent >= 0 ? 'positive' : 'negative';
                const changeSign = item.changePercent >= 0 ? '+' : '';
                const formattedPrice = this.formatNumber(item.price);
                const formattedChange = item.changePercent.toFixed(2);
                
                let typeLabel = '';
                let priceSuffix = '';
                
                switch(type) {
                    case 'stock': 
                        typeLabel = 'Ø¨ÙˆØ±Ø³'; 
                        priceSuffix = ' ØªÙˆÙ…Ø§Ù†';
                        break;
                    case 'crypto': 
                        typeLabel = 'Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„'; 
                        priceSuffix = ' Ø¯Ù„Ø§Ø±';
                        break;
                    case 'gold': 
                        typeLabel = 'Ø·Ù„Ø§'; 
                        priceSuffix = ' ØªÙˆÙ…Ø§Ù†';
                        break;
                    case 'currency': 
                        typeLabel = 'Ø§Ø±Ø²'; 
                        priceSuffix = ' ØªÙˆÙ…Ø§Ù†';
                        break;
                    case 'commodity': 
                        typeLabel = 'Ú©Ø§Ù…ÙˆØ¯ÛŒØªÛŒ'; 
                        priceSuffix = ' Ø¯Ù„Ø§Ø±';
                        break;
                }
                
                return `
                    <div class="market-item" onclick="this.showAssetDetail('${item.symbol}', '${type}')">
                        <div class="market-name">${item.name} <small>(${typeLabel})</small></div>
                        <div class="market-price">${formattedPrice}${priceSuffix}</div>
                        <div class="market-change ${changeClass}">
                            ${changeSign}${formattedChange}%
                        </div>
                    </div>
                `;
            }

            formatNumber(num) {
                return new Intl.NumberFormat('fa-IR').format(Math.round(num));
            }

            updateCharts() {
                this.updateIndicesChart();
                this.updatePriceChart();
                this.updateConnectionChart();
            }

            updateIndicesChart() {
                const indices = this.marketData.indices;
                
                const trace = {
                    x: indices.map(index => index.name),
                    y: indices.map(index => index.value),
                    type: 'bar',
                    marker: {
                        color: indices.map(index => index.changePercent >= 0 ? '#28a745' : '#dc3545')
                    },
                    text: indices.map(index => `${this.formatNumber(index.value)} (${index.changePercent >= 0 ? '+' : ''}${index.changePercent.toFixed(2)}%)`),
                    textposition: 'auto'
                };
                
                const layout = {
                    title: 'Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø± Ø³Ø±Ù…Ø§ÛŒÙ‡',
                    xaxis: { title: 'Ø´Ø§Ø®Øµ' },
                    yaxis: { title: 'Ù…Ù‚Ø¯Ø§Ø±' },
                    font: { family: 'Tahoma' },
                    showlegend: false
                };
                
                Plotly.newPlot('indicesChart', [trace], layout, { responsive: true });
            }

            updatePriceChart() {
                const timePeriods = ['1D', '1W', '1M', '3M', '1Y'];
                
                const generatePriceSeries = (base, volatility) => {
                    let price = base;
                    return timePeriods.map(() => {
                        price = price * (1 + (Math.random() * volatility * 2 - volatility));
                        return Math.round(price);
                    });
                };
                
                const stockPrices = generatePriceSeries(45000, 0.05);
                const cryptoPrices = generatePriceSeries(85000, 0.08);
                const goldPrices = generatePriceSeries(95000000, 0.03);
                
                const trace1 = {
                    x: timePeriods,
                    y: stockPrices,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Ø¨ÙˆØ±Ø³',
                    line: { color: '#1e3c72', width: 3 }
                };
                
                const trace2 = {
                    x: timePeriods,
                    y: cryptoPrices,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„',
                    line: { color: '#ff6b6b', width: 3 }
                };
                
                const trace3 = {
                    x: timePeriods,
                    y: goldPrices.map(p => p / 1000),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Ø·Ù„Ø§ (Ù‡Ø²Ø§Ø± ØªÙˆÙ…Ø§Ù†)',
                    line: { color: '#ffd700', width: 3 }
                };
                
                const layout = {
                    title: 'Ø±ÙˆÙ†Ø¯ Ù‚ÛŒÙ…Øª Ø¯Ø± Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù',
                    xaxis: { title: 'Ø¨Ø§Ø²Ù‡ Ø²Ù…Ø§Ù†ÛŒ' },
                    yaxis: { title: 'Ù‚ÛŒÙ…Øª' },
                    font: { family: 'Tahoma' },
                    showlegend: true
                };
                
                Plotly.newPlot('priceChart', [trace1, trace2, trace3], layout, { responsive: true });
            }

            updateConnectionChart() {
                const statusData = Object.values(this.monitoringSystem.apiStatus);
                const connected = statusData.filter(api => api.status === 'connected').length;
                const disconnected = statusData.filter(api => api.status === 'disconnected').length;
                const inactive = statusData.filter(api => !api.shouldBeActive).length;
                
                const trace = {
                    x: ['Ù…ØªØµÙ„', 'Ù‚Ø·Ø¹', 'ØºÛŒØ±ÙØ¹Ø§Ù„'],
                    y: [connected, disconnected, inactive],
                    type: 'bar',
                    marker: {
                        color: ['#28a745', '#dc3545', '#ffc107']
                    }
                };
                
                const layout = {
                    title: 'ÙˆØ¶Ø¹ÛŒØª Ø§ØªØµØ§Ù„ APIÙ‡Ø§',
                    xaxis: { title: 'ÙˆØ¶Ø¹ÛŒØª' },
                    yaxis: { title: 'ØªØ¹Ø¯Ø§Ø¯' },
                    font: { family: 'Tahoma' }
                };
                
                Plotly.newPlot('connectionChart', [trace], layout, { responsive: true });
            }

            updateTechnicalIndicators() {
                const container = document.getElementById('technicalIndicators');
                const indicators = [
                    { name: 'RSI', value: (30 + Math.random() * 40).toFixed(1) },
                    { name: 'MACD', value: (Math.random() - 0.5).toFixed(3) },
                    { name: 'Ø´Ø§Ø®Øµ Ù‚Ø¯Ø±Øª', value: (Math.random() * 100).toFixed(1) },
                    { name: 'Ù†ÙˆØ³Ø§Ù†', value: (Math.random() * 20).toFixed(1) + '%' }
                ];
                
                const indicatorsHTML = indicators.map(indicator => `
                    <div class="indicator">
                        <div class="indicator-value">${indicator.value}</div>
                        <div class="indicator-name">${indicator.name}</div>
                    </div>
                `).join('');
                
                container.innerHTML = indicatorsHTML;
            }

            updateRiskMetrics() {
                const container = document.getElementById('riskMetrics');
                const metrics = [
                    { name: 'VaR 95%', value: (Math.random() * 5).toFixed(2) + '%', level: 'medium' },
                    { name: 'Ø­Ø¯Ø§Ú©Ø«Ø± Ø§ÙØª', value: (Math.random() * 15).toFixed(2) + '%', level: 'high' },
                    { name: 'Ù†Ø³Ø¨Øª Ø´Ø§Ø±Ù¾', value: (0.5 + Math.random() * 2).toFixed(2), level: 'low' },
                    { name: 'Ø¨ØªØ§', value: (0.8 + Math.random() * 0.8).toFixed(2), level: 'medium' }
                ];
                
                const metricsHTML = metrics.map(metric => {
                    const levelClass = `metric-${metric.level}`;
                    return `
                        <div class="metric">
                            <div class="metric-value ${levelClass}">${metric.value}</div>
                            <div class="indicator-name">${metric.name}</div>
                        </div>
                    `;
                }).join('');
                
                container.innerHTML = metricsHTML;
            }

            async performAIAnalysis() {
                return this.errorHandler.apiCallWithRetry(async () => {
                    this.uiManager.showLoading('aiAnalysis', 'Ø¯Ø± Ø­Ø§Ù„ ØªØ­Ù„ÛŒÙ„ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ø§ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ...');
                    
                    await this.errorHandler.delay(2000);
                    
                    const analysisResults = [
                        {
                            title: 'Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø±ÙˆÙ†Ø¯ Ø¨ÙˆØ±Ø³',
                            content: 'Ø´Ø§Ø®Øµ Ú©Ù„ Ø¯Ø± Ø¢Ø³ØªØ§Ù†Ù‡ Ø´Ú©Ø³Øª Ù…Ù‚Ø§ÙˆÙ…Øª Û².Û¸ Ù…ÛŒÙ„ÛŒÙˆÙ†ÛŒ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ø¯. Ø­Ø¬Ù… Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø±Ùˆ Ø¨Ù‡ Ø§ÙØ²Ø§ÛŒØ´ Ø§Ø³Øª.',
                            confidence: 85,
                            type: 'opportunity',
                            recommendation: 'Ø§ÙØ²Ø§ÛŒØ´ ÙˆØ²Ù† Ø³Ù‡Ø§Ù… Ø¯Ø± Ù¾Ø±ØªÙÙˆÛŒ'
                        },
                        {
                            title: 'ØªØ­Ù„ÛŒÙ„ Ø§Ø±Ø²Ù‡Ø§ÛŒ Ø¯ÛŒØ¬ÛŒØªØ§Ù„',
                            content: 'Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ† Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ ØµØ¹ÙˆØ¯ÛŒ Ù‚Ø±Ø§Ø± Ú¯Ø±ÙØªÙ‡ Ùˆ Ø§Ø­ØªÙ…Ø§Ù„ Ø±Ø´Ø¯ ØªØ§ Û¹Û°,Û°Û°Û° Ø¯Ù„Ø§Ø± ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯.',
                            confidence: 78,
                            type: 'opportunity',
                            recommendation: 'ÙˆØ±ÙˆØ¯ Ù¾Ù„Ú©Ø§Ù†ÛŒ Ø¨Ø§ Ø±Ø¹Ø§ÛŒØª Ø­Ø¯ Ø¶Ø±Ø±'
                        },
                        {
                            title: 'Ù‡Ø´Ø¯Ø§Ø± Ø±ÛŒØ³Ú© Ø·Ù„Ø§',
                            content: 'Ù‚ÛŒÙ…Øª Ø·Ù„Ø§ Ø¨Ù‡ Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø§Ø´Ø¨Ø§Ø¹ Ø®Ø±ÛŒØ¯ Ø±Ø³ÛŒØ¯Ù‡ Ø§Ø³Øª. Ø´Ø§Ø®Øµ RSI Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ Û·Ûµ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ø¯.',
                            confidence: 65,
                            type: 'risk',
                            recommendation: 'Ú©Ø§Ù‡Ø´ Ù…ÙˆÙ‚ÛŒØª Ùˆ Ø§Ù†ØªØ¸Ø§Ø± Ø¨Ø±Ø§ÛŒ Ø§ØµÙ„Ø§Ø­'
                        }
                    ];
                    
                    this.displayAIAnalysis(analysisResults);
                    this.uiManager.showNotification('ØªØ­Ù„ÛŒÙ„ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯', 'success');
                    
                    return analysisResults;
                }, 2, 'AI Analysis');
            }

            displayAIAnalysis(results) {
                const container = document.getElementById('aiAnalysis');
                
                const analysisHTML = results.map(item => `
                    <div class="analysis-item ${item.type === 'risk' ? 'risk-item' : 'opportunity-item'}">
                        <h3>${item.title}</h3>
                        <p>${item.content}</p>
                        <div class="confidence">
                            <strong>Ø§Ø¹ØªÙ…Ø§Ø¯ ØªØ­Ù„ÛŒÙ„:</strong> ${item.confidence}%
                        </div>
                        <div class="recommendation">
                            <strong>ØªÙˆØµÛŒÙ‡:</strong> ${item.recommendation}
                        </div>
                    </div>
                `).join('');
                
                container.innerHTML = analysisHTML;
            }

            updateAdvancedAnalysis() {
                const container = document.getElementById('advancedAnalysis');
                
                const analysisResults = [
                    {
                        title: 'ØªØ­Ù„ÛŒÙ„ Ø±Ú¯Ø±Ø³ÛŒÙˆÙ† Ú†Ù†Ø¯Ù…ØªØºÛŒØ±Ù‡',
                        content: 'Ù…Ø¯Ù„ Ø±Ú¯Ø±Ø³ÛŒÙˆÙ† Ù†Ø´Ø§Ù† Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ø´Ø§Ø®Øµ Ú©Ù„ ØªØ­Øª ØªØ£Ø«ÛŒØ± Ù†Ø±Ø® Ø§Ø±Ø² Ùˆ Ù‚ÛŒÙ…Øª Ù†ÙØª Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ø¯. Ø¶Ø±ÛŒØ¨ ØªØ¹ÛŒÛŒÙ†: Û°.Û¸Û·',
                        type: 'opportunity'
                    },
                    {
                        title: 'ØªØ­Ù„ÛŒÙ„ Ø³Ø±ÛŒ Ø²Ù…Ø§Ù†ÛŒ',
                        content: 'Ø§Ù„Ú¯ÙˆÛŒ ÙØµÙ„ÛŒ Ù‚ÙˆÛŒ Ø¯Ø± Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ Ù¾ØªØ±ÙˆØ´ÛŒÙ…ÛŒ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯. Ø§ÙˆØ¬ Ø®Ø±ÛŒØ¯ Ø¯Ø± Ø³Ù‡ Ù…Ø§Ù‡Ù‡ Ø¯ÙˆÙ… Ø³Ø§Ù„ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.',
                        type: 'opportunity'
                    },
                    {
                        title: 'ØªØ­Ù„ÛŒÙ„ Ø®ÙˆØ´Ù‡â€ŒØ§ÛŒ',
                        content: 'Ù†Ù…Ø§Ø¯Ù‡Ø§ Ø¯Ø± Ûµ Ø®ÙˆØ´Ù‡ Ù…Ø¬Ø²Ø§ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø´Ø¯Ù†Ø¯. Ø®ÙˆØ´Ù‡ ÙÙ†Ø§ÙˆØ±ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨ÛŒØ´ØªØ±ÛŒÙ† Ù¾ØªØ§Ù†Ø³ÛŒÙ„ Ø±Ø´Ø¯ Ø±Ø§ Ø¯Ø§Ø±Ø¯.',
                        type: 'opportunity'
                    }
                ];
                
                const analysisHTML = analysisResults.map(item => `
                    <div class="analysis-item ${item.type === 'risk' ? 'risk-item' : 'opportunity-item'}">
                        <h3>${item.title}</h3>
                        <p>${item.content}</p>
                    </div>
                `).join('');
                
                container.innerHTML = analysisHTML;
            }

            async performRiskAssessment() {
                this.uiManager.showNotification('Ø¯Ø± Ø­Ø§Ù„ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø±ÛŒØ³Ú© Ù¾Ø±ØªÙÙˆÛŒ...', 'info');
                
                setTimeout(() => {
                    const mockPositions = [
                        { symbol: 'Ø´ØªØ±Ø§Ù†', quantity: 1000, entry_price: 42000, current_price: 45000 },
                        { symbol: 'Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ†', quantity: 0.5, entry_price: 80000, current_price: 85000 }
                    ];
                    
                    const marketConditions = { volatility: 0.15, trend: 'upward' };
                    const riskAssessment = this.aiModels.riskAssessor.assess_risk(mockPositions, marketConditions);
                    
                    this.displayRiskAssessment(riskAssessment);
                    this.uiManager.showNotification('Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø±ÛŒØ³Ú© Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯', 'success');
                }, 2000);
            }

            displayRiskAssessment(riskAssessment) {
                const container = document.getElementById('aiAnalysis');
                
                const riskHTML = `
                    <div class="analysis-item risk-item">
                        <h3>Ø±ÛŒØ³Ú© Ú©Ù„ÛŒ: ${riskAssessment.overall_risk}</h3>
                        <p><strong>VaR Ù¾ÙˆØ±ØªÙÙˆÛŒ:</strong> ${(riskAssessment.portfolio_var * 100).toFixed(2)}%</p>
                        <p><strong>Ø­Ø¯Ø§Ú©Ø«Ø± Ø§ÙØª:</strong> ${(riskAssessment.max_drawdown * 100).toFixed(2)}%</p>
                        <p><strong>Ø±ÛŒØ³Ú© ØªÙ…Ø±Ú©Ø²:</strong> ${(riskAssessment.concentration_risk * 100).toFixed(2)}%</p>
                    </div>
                    <div class="analysis-item">
                        <h3>ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§</h3>
                        <ul>
                            ${riskAssessment.recommendations.map(rec => `<li>${rec}</li>`).join('')}
                        </ul>
                    </div>
                    <div class="analysis-item risk-item">
                        <h3>Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§</h3>
                        <ul>
                            ${riskAssessment.warnings.map(warning => `<li>${warning}</li>`).join('')}
                        </ul>
                    </div>
                `;
                
                container.innerHTML = riskHTML;
            }

            loadXAIExplanations() {
                const container = document.getElementById('xaiExplanations');
                this.uiManager.showLoading('xaiExplanations', 'Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯ ØªÙˆØ¶ÛŒØ­Ø§Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ...');
                
                setTimeout(() => {
                    const mockFeatures = [0.5, -0.2, 0.8, -0.1, 0.3];
                    const featureNames = ['Ù‚ÛŒÙ…Øª', 'Ø­Ø¬Ù…', 'RSI', 'MACD', 'Ù†ÙˆØ³Ø§Ù†'];
                    
                    const explanation = this.aiModels.decisionExplainer.explain_decision(
                        this.aiModels.pricePredictor,
                        mockFeatures,
                        featureNames
                    );
                    
                    const explanationsHTML = `
                        <div class="analysis-item">
                            <h3>ØªÙˆØ¶ÛŒØ­ ØªØµÙ…ÛŒÙ… Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ</h3>
                            <p><strong>Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ:</strong> ${explanation.prediction.toFixed(4)}</p>
                            <p><strong>Ø§Ø·Ù…ÛŒÙ†Ø§Ù†:</strong> ${(explanation.confidence * 100).toFixed(1)}% (${explanation.confidence_level})</p>
                            <p><strong>Ù…Ù†Ø·Ù‚:</strong> ${explanation.rationale}</p>
                        </div>
                        <div class="analysis-item">
                            <h3>Ø¹ÙˆØ§Ù…Ù„ Ú©Ù„ÛŒØ¯ÛŒ ØªØ§Ø«ÛŒØ±Ú¯Ø°Ø§Ø±</h3>
                            <ul>
                                ${explanation.key_factors.slice(0, 5).map(factor => `
                                    <li>${factor[0]}: ${(factor[1] * 100).toFixed(2)}% (${factor[2]})</li>
                                `).join('')}
                            </ul>
                        </div>
                        <div class="analysis-item">
                            <h3>Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª Ù…ØªØºÛŒØ±</h3>
                            <ul>
                                ${explanation.counterfactuals.map(cf => `
                                    <li>${cf.description} (ØªØ§Ø«ÛŒØ± Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø±: ${(cf.expected_impact * 100).toFixed(2)}%)</li>
                                `).join('')}
                            </ul>
                        </div>
                    `;
                    
                    container.innerHTML = explanationsHTML;
                    
                    this.updateSHAPChart();
                    this.updateLIMEChart();
                    this.updateCounterfactualChart();
                    
                }, 2000);
            }

            updateSHAPChart() {
                const features = ['Ù‚ÛŒÙ…Øª', 'Ø­Ø¬Ù…', 'RSI', 'MACD', 'Ù†ÙˆØ³Ø§Ù†', 'Ø§Ø±Ø²Ø´ Ø¨Ø§Ø²Ø§Ø±', 'P/E', 'ØªØºÛŒÛŒØ±Ø§Øª'];
                const shapValues = features.map(() => (Math.random() - 0.5) * 0.3);
                
                const trace = {
                    x: shapValues,
                    y: features,
                    type: 'bar',
                    orientation: 'h',
                    marker: {
                        color: shapValues.map(val => val > 0 ? '#28a745' : '#dc3545')
                    }
                };
                
                const layout = {
                    title: 'ØªØ­Ù„ÛŒÙ„ SHAP - ØªØ§Ø«ÛŒØ± ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ Ø¨Ø± Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ',
                    xaxis: { title: 'Ù…Ù‚Ø¯Ø§Ø± SHAP' },
                    yaxis: { title: 'ÙˆÛŒÚ˜Ú¯ÛŒ' },
                    font: { family: 'Tahoma' }
                };
                
                Plotly.newPlot('shapChart', [trace], layout, { responsive: true });
            }

            updateLIMEChart() {
                const features = ['Ù‚ÛŒÙ…Øª', 'Ø­Ø¬Ù…', 'RSI', 'MACD', 'Ù†ÙˆØ³Ø§Ù†'];
                const limeWeights = features.map(() => (Math.random() - 0.5) * 0.4);
                
                const trace = {
                    x: limeWeights,
                    y: features,
                    type: 'bar',
                    orientation: 'h',
                    marker: {
                        color: limeWeights.map(val => val > 0 ? '#28a745' : '#dc3545')
                    }
                };
                
                const layout = {
                    title: 'ØªØ­Ù„ÛŒÙ„ LIME - ÙˆØ²Ù†â€ŒÙ‡Ø§ÛŒ Ù…Ø­Ù„ÛŒ',
                    xaxis: { title: 'ÙˆØ²Ù† LIME' },
                    yaxis: { title: 'ÙˆÛŒÚ˜Ú¯ÛŒ' },
                    font: { family: 'Tahoma' }
                };
                
                Plotly.newPlot('limeChart', [trace], layout, { responsive: true });
            }

            updateCounterfactualChart() {
                const scenarios = ['Ø³Ù†Ø§Ø±ÛŒÙˆ ÙØ¹Ù„ÛŒ', 'Ø§ÙØ²Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª Û±Û°Ùª', 'Ú©Ø§Ù‡Ø´ Ù†ÙˆØ³Ø§Ù†', 'Ø§ÙØ²Ø§ÛŒØ´ Ø­Ø¬Ù…'];
                const predictions = [0.5, 0.65, 0.45, 0.7];
                
                const trace = {
                    x: scenarios,
                    y: predictions,
                    type: 'bar',
                    marker: {
                        color: predictions.map(pred => pred > 0.6 ? '#28a745' : pred > 0.4 ? '#ffc107' : '#dc3545')
                    }
                };
                
                const layout = {
                    title: 'ØªØ­Ù„ÛŒÙ„ Ø³Ù†Ø§Ø±ÛŒÙˆÙ‡Ø§ÛŒ Ù…ØªØºÛŒØ±',
                    xaxis: { title: 'Ø³Ù†Ø§Ø±ÛŒÙˆ' },
                    yaxis: { title: 'Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ' },
                    font: { family: 'Tahoma' }
                };
                
                Plotly.newPlot('counterfactualChart', [trace], layout, { responsive: true });
            }

            loadTransformerPredictions() {
                const container = document.getElementById('transformerPredictionsChart');
                
                const timePeriods = ['Ø­Ø§Ù„', 'Û± Ø±ÙˆØ²', 'Û³ Ø±ÙˆØ²', 'Û± Ù‡ÙØªÙ‡', 'Û² Ù‡ÙØªÙ‡'];
                const predictions = [0.5, 0.55, 0.52, 0.58, 0.62];
                const confidence = [1.0, 0.8, 0.7, 0.6, 0.5];
                
                const trace1 = {
                    x: timePeriods,
                    y: predictions,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ',
                    line: { color: '#1e3c72', width: 3 }
                };
                
                const trace2 = {
                    x: timePeriods,
                    y: predictions.map((pred, i) => pred + (1 - confidence[i]) * 0.1),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Ø­Ø¯ Ø¨Ø§Ù„Ø§',
                    line: { color: '#28a745', width: 1, dash: 'dash' },
                    fillcolor: 'rgba(40, 167, 69, 0.2)',
                    fill: 'tonexty'
                };
                
                const trace3 = {
                    x: timePeriods,
                    y: predictions.map((pred, i) => pred - (1 - confidence[i]) * 0.1),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Ø­Ø¯ Ù¾Ø§ÛŒÛŒÙ†',
                    line: { color: '#dc3545', width: 1, dash: 'dash' },
                    fill: 'tonexty'
                };
                
                const layout = {
                    title: 'Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒâ€ŒÙ‡Ø§ÛŒ Transformer Ø¨Ø§ Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø§Ø·Ù…ÛŒÙ†Ø§Ù†',
                    xaxis: { title: 'Ø§ÙÙ‚ Ø²Ù…Ø§Ù†ÛŒ' },
                    yaxis: { title: 'Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ' },
                    font: { family: 'Tahoma' },
                    showlegend: true
                };
                
                Plotly.newPlot('transformerPredictionsChart', [trace1, trace2, trace3], layout, { responsive: true });
            }

            generateTradeSuggestions() {
                this.uiManager.showNotification('Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ...', 'info');
                
                setTimeout(() => {
                    const suggestions = [
                        {
                            symbol: 'Ø´ØªØ±Ø§Ù†',
                            action: 'Ø®Ø±ÛŒØ¯',
                            price: 'Û´Ûµ,Û°Û°Û° ØªÙˆÙ…Ø§Ù†',
                            target: 'ÛµÛ²,Û°Û°Û° ØªÙˆÙ…Ø§Ù†',
                            stoploss: 'Û´Û²,Û°Û°Û° ØªÙˆÙ…Ø§Ù†',
                            confidence: 78
                        },
                        {
                            symbol: 'Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ†',
                            action: 'Ø®Ø±ÛŒØ¯',
                            price: 'Û¸Ûµ,Û°Û°Û° Ø¯Ù„Ø§Ø±',
                            target: 'Û¹Ûµ,Û°Û°Û° Ø¯Ù„Ø§Ø±',
                            stoploss: 'Û·Û¸,Û°Û°Û° Ø¯Ù„Ø§Ø±',
                            confidence: 82
                        },
                        {
                            symbol: 'Ø³Ú©Ù‡ Ø§Ù…Ø§Ù…ÛŒ',
                            action: 'ÙØ±ÙˆØ´',
                            price: 'Û¹Û·,Û°Û°Û°,Û°Û°Û° ØªÙˆÙ…Ø§Ù†',
                            target: 'Û¹Û²,Û°Û°Û°,Û°Û°Û° ØªÙˆÙ…Ø§Ù†',
                            stoploss: 'Û±Û°Û°,Û°Û°Û°,Û°Û°Û° ØªÙˆÙ…Ø§Ù†',
                            confidence: 65
                        }
                    ];
                    
                    let message = 'Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ:\n\n';
                    suggestions.forEach(suggestion => {
                        message += `ğŸ“ˆ ${suggestion.symbol}: ${suggestion.action} Ø¯Ø± ${suggestion.price}\n`;
                        message += `ğŸ¯ Ù‡Ø¯Ù: ${suggestion.target} | âš ï¸ Ø­Ø¯ Ø¶Ø±Ø±: ${suggestion.stoploss}\n`;
                        message += `ğŸ” Ø§Ø·Ù…ÛŒÙ†Ø§Ù†: ${suggestion.confidence}%\n\n`;
                    });
                    
                    alert(message);
                }, 1500);
            }

            async encryptAllData() {
                try {
                    this.uiManager.showNotification('Ø¯Ø± Ø­Ø§Ù„ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§...', 'info');
                    
                    const encryptedData = this.securityManager.encryptData(JSON.stringify(this.marketData));
                    
                    this.securityManager.logSecurityEvent('DATA_ENCRYPTED', 'All market data encrypted');
                    this.uiManager.showNotification('ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ø´Ø¯Ù†Ø¯', 'success');
                    
                    return encryptedData;
                } catch (error) {
                    this.errorHandler.notifyUser('Ø®Ø·Ø§ Ø¯Ø± Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§', 'error');
                }
            }

            async clearCache() {
                this.apiService.clearCache();
                this.uiManager.showNotification('Ú©Ø´ Ø³ÛŒØ³ØªÙ… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù¾Ø§Ú© Ø´Ø¯', 'success');
            }

            async testSecurity() {
                const result = await this.securityManager.testSecurity();
                if (result) {
                    this.uiManager.showNotification('ØªÙ…Ø§Ù… ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ú¯Ø°Ø±Ø§Ù†Ø¯Ù‡ Ø´Ø¯Ù†Ø¯', 'success');
                } else {
                    this.uiManager.showNotification('Ø¨Ø±Ø®ÛŒ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù†Ø¯', 'warning');
                }
            }

            updateSecurityTab() {
                this.updateAPIMonitoringStatus();
            }

            updateAPIMonitoringStatus() {
                const container = document.getElementById('apiMonitoringStatus');
                if (!container) return;

                const statusData = Object.values(this.monitoringSystem.apiStatus);
                const statusHTML = statusData.map(apiInfo => {
                    const status = apiInfo.status === 'connected' ? 'connected' : 'disconnected';
                    const statusText = status === 'connected' ? 'âœ… Ù…ØªØµÙ„' : 'âŒ Ù‚Ø·Ø¹';
                    
                    return `
                        <div class="api-status ${status}" style="margin-bottom: 10px;">
                            <div>
                                <strong>${apiInfo.name}</strong>
                                <br>
                                <small>${statusText} - Ù…ÙˆÙÙ‚ÛŒØª: ${apiInfo.successRate.toFixed(1)}%</small>
                            </div>
                            <span class="status-indicator status-${status}"></span>
                        </div>
                    `;
                }).join('');

                container.innerHTML = statusHTML;
            }

            showAssetDetail(symbol, type) {
                alert(`Ø¬Ø²ÛŒÛŒØ§Øª ${symbol} (${type}) Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ...\n\nØ§ÛŒÙ† Ù‚Ø§Ø¨Ù„ÛŒØª Ø¯Ø± Ù†Ø³Ø®Ù‡ Ú©Ø§Ù…Ù„ Ø³ÛŒØ³ØªÙ… ÙØ¹Ø§Ù„ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯.`);
            }
async performAdvancedFeatureAnalysis() {
        try {
            this.uiManager.showLoading('featureImportanceAnalysis', 
                'Ø¯Ø± Ø­Ø§Ù„ Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØ­Ù„ÛŒÙ„ Ø§Ù‡Ù…ÛŒØª ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡...');

            // Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù†Ù…ÙˆÙ†Ù‡ Ø¨Ø±Ø§ÛŒ ØªØ­Ù„ÛŒÙ„
            const sampleFeatures = this.generateSampleFeatures();
            const featureNames = ['Ù‚ÛŒÙ…Øª', 'Ø­Ø¬Ù…', 'RSI', 'MACD', 'Ù†ÙˆØ³Ø§Ù†', 'Ø§Ø±Ø²Ø´ Ø¨Ø§Ø²Ø§Ø±', 'P/E', 'ØªØºÛŒÛŒØ±Ø§Øª'];
            
            const analysis = this.aiModels.featureImportance.comprehensive_importance_analysis(
                this.aiModels.pricePredictor,
                sampleFeatures,
                Array.from({length: sampleFeatures.length}, () => Math.random() - 0.5),
                featureNames
            );

            this.displayFeatureImportanceAnalysis(analysis);
            this.updateGlobalFeatureImportanceChart(analysis.global_importance);
            this.updateFeatureInteractionChart(analysis.interaction_network);
            
            this.uiManager.showNotification('ØªØ­Ù„ÛŒÙ„ Ø§Ù‡Ù…ÛŒØª ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯', 'success');
            
        } catch (error) {
            this.errorHandler.notifyUser('Ø®Ø·Ø§ Ø¯Ø± ØªØ­Ù„ÛŒÙ„ Ø§Ù‡Ù…ÛŒØª ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§', 'error');
        }
    }

    generateSampleFeatures() {
        return Array.from({length: 100}, () => 
            Array.from({length: 8}, () => Math.random() * 100)
        );
    }

    displayFeatureImportanceAnalysis(analysis) {
        const container = document.getElementById('featureImportanceAnalysis');
        
        const globalHTML = `
            <div class="analysis-item">
                <h3>Ø§Ù‡Ù…ÛŒØª Ø³Ø±Ø§Ø³Ø±ÛŒ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§</h3>
                <div style="max-height: 300px; overflow-y: auto;">
                    ${analysis.global_importance.map(feature => `
                        <div style="padding: 8px; border-bottom: 1px solid #eee;">
                            <strong>${feature.feature_name}</strong>: 
                            ${(feature.importance_score * 100).toFixed(2)}% 
                            <small>(${feature.significance}, ${feature.direction})</small>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;

        const stabilityHTML = `
            <div class="analysis-item">
                <h3>ØªØ­Ù„ÛŒÙ„ Ù¾Ø§ÛŒØ¯Ø§Ø±ÛŒ</h3>
                <div style="max-height: 200px; overflow-y: auto;">
                    ${Object.entries(analysis.stability_analysis).slice(0, 5).map(([feature, stability]) => `
                        <div style="padding: 5px;">
                            ${feature}: ${(stability * 100).toFixed(1)}%
                        </div>
                    `).join('')}
                </div>
            </div>
        `;

        const interactionsHTML = `
            <div class="analysis-item">
                <h3>ØªØ¹Ø§Ù…Ù„â€ŒÙ‡Ø§ÛŒ Ù…Ù‡Ù…</h3>
                <div style="max-height: 200px; overflow-y: auto;">
                    ${Object.entries(analysis.interaction_network).slice(0, 5).map(([pair, strength]) => `
                        <div style="padding: 5px;">
                            ${pair.replace(',', ' & ')}: ${(strength * 100).toFixed(1)}%
                        </div>
                    `).join('')}
                </div>
            </div>
        `;

        container.innerHTML = globalHTML + stabilityHTML + interactionsHTML;
    }

    updateGlobalFeatureImportanceChart(global_importance) {
        const features = global_importance.map(f => f.feature_name);
        const importance_scores = global_importance.map(f => f.importance_score * 100);
        const colors = global_importance.map(f => 
            f.direction === 'positive' ? '#28a745' : 
            f.direction === 'negative' ? '#dc3545' : '#6c757d'
        );

        const trace = {
            x: importance_scores,
            y: features,
            type: 'bar',
            orientation: 'h',
            marker: { color: colors }
        };

        const layout = {
            title: 'Ø§Ù‡Ù…ÛŒØª Ø³Ø±Ø§Ø³Ø±ÛŒ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§',
            xaxis: { title: 'Ø§Ù‡Ù…ÛŒØª (%)' },
            yaxis: { title: 'ÙˆÛŒÚ˜Ú¯ÛŒ' },
            font: { family: 'Tahoma' }
        };

        Plotly.newPlot('globalFeatureImportanceChart', [trace], layout, { responsive: true });
    }

    updateFeatureInteractionChart(interaction_network) {
        const interactions = Object.entries(interaction_network).slice(0, 10);
        const features = [...new Set(interactions.flatMap(([pair]) => pair.split(',')))];
        
        const matrix = Array(features.length).fill().map(() => 
            Array(features.length).fill(0)
        );

        interactions.forEach(([pair, strength]) => {
            const [f1, f2] = pair.split(',');
            const i1 = features.indexOf(f1);
            const i2 = features.indexOf(f2);
            if (i1 !== -1 && i2 !== -1) {
                matrix[i1][i2] = strength;
                matrix[i2][i1] = strength;
            }
        });

        const trace = {
            z: matrix,
            x: features,
            y: features,
            type: 'heatmap',
            colorscale: 'Viridis'
        };

        const layout = {
            title: 'Ù…Ø§ØªØ±ÛŒØ³ ØªØ¹Ø§Ù…Ù„ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§',
            font: { family: 'Tahoma' }
        };

        Plotly.newPlot('featureInteractionChart', [trace], layout, { responsive: true });
    }

                    
        }

        // ===============================
        // Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ø¨Ø±Ù†Ø§Ù…Ù‡
        // ===============================
        document.addEventListener('DOMContentLoaded', function() {
            window.FinancialAnalysisApp = FinancialAnalysisApp.getInstance();
            window.ErrorHandler = ErrorHandler;
            window.SecurityManager = window.FinancialAnalysisApp.securityManager;
            window.UIManager = window.FinancialAnalysisApp.uiManager;
        });

                    class RealTimeDataService {
    constructor() {
        this.socket = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
    }

    connect() {
        try {
            this.socket = new WebSocket('wss://realtime-api.example.com');
            
            this.socket.onopen = () => {
                console.log('WebSocket connected');
                this.reconnectAttempts = 0;
            };

            this.socket.onmessage = (event) => {
                this.handleRealTimeData(JSON.parse(event.data));
            };

            this.socket.onclose = () => {
                this.handleReconnection();
            };

        } catch (error) {
            console.error('WebSocket connection failed:', error);
        }
    }

    handleRealTimeData(data) {
        // Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù„Ø­Ø¸Ù‡â€ŒØ§ÛŒ
        window.FinancialAnalysisApp.updateRealTimeData(data);
    }

    handleReconnection() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            setTimeout(() => this.connect(), Math.pow(2, this.reconnectAttempts) * 1000);
        }
    }
}

            // ÙØ§ÛŒÙ„ service-worker.js
self.addEventListener('install', (event) => {
    event.waitUntil(
        caches.open('financial-app-v1').then((cache) => {
            return cache.addAll([
                '/',
                '/index.html',
                '/ai_models.js',
                // ... Ø³Ø§ÛŒØ± ÙØ§ÛŒÙ„â€ŒÙ‡Ø§
            ]);
        })
    );
});

self.addEventListener('fetch', (event) => {
    event.respondWith(
        caches.match(event.request).then((response) => {
            return response || fetch(event.request);
        })
    );
});
                    
    </script>
</body>
</html>
