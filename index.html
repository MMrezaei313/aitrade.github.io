<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>سیستم جامع تحلیل و معامله‌گری بازارهای مالی ایران</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.0/axios.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="ai_models.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        :root {
            --primary: #1e3c72;
            --secondary: #2a5298;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --info: #17a2b8;
            --light: #f8f9fa;
            --dark: #343a40;
            --sidebar-width: 300px;
        }
        
        body {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
        }
        
        .sidebar {
            width: var(--sidebar-width);
            background: rgba(255, 255, 255, 0.98);
            height: 100vh;
            position: fixed;
            right: 0;
            top: 0;
            padding: 20px;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            z-index: 1000;
        }
        
        .main-content {
            flex: 1;
            margin-right: var(--sidebar-width);
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
        }
        
        h1 {
            color: var(--primary);
            margin-bottom: 10px;
            font-size: 2.2rem;
            font-weight: 700;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 25px;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }
        
        .card h2 {
            color: var(--primary);
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
            font-size: 1.4rem;
            font-weight: 600;
        }
        
        .market-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .market-item {
            background: var(--light);
            border-radius: 12px;
            padding: 18px;
            border-left: 5px solid var(--primary);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .market-item:hover {
            background: #e9ecef;
            transform: translateX(8px);
        }
        
        .market-name {
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        
        .market-price {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 8px;
            color: var(--dark);
        }
        
        .market-change {
            font-size: 0.95rem;
            padding: 5px 12px;
            border-radius: 8px;
            display: inline-block;
            font-weight: 600;
        }
        
        .positive {
            background: #d4edda;
            color: #155724;
        }
        
        .negative {
            background: #f8d7da;
            color: #721c24;
        }
        
        .chart-container {
            height: 400px;
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
            background: rgba(255, 255, 255, 0.98);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        
        .control-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        select, button, input {
            padding: 12px 18px;
            border-radius: 10px;
            border: 1px solid #ddd;
            background: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:focus, button:focus, input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(30, 60, 114, 0.2);
        }
        
        button {
            background: var(--primary);
            color: white;
            border: none;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        button:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .analysis-section {
            margin-top: 25px;
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .analysis-item {
            background: var(--light);
            border-radius: 12px;
            padding: 20px;
            border-left: 5px solid var(--success);
            transition: all 0.3s ease;
        }
        
        .risk-item {
            border-left-color: var(--danger);
        }
        
        .opportunity-item {
            border-left-color: var(--success);
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 1.1rem;
        }
        
        .tab-container {
            margin-bottom: 20px;
        }
        
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tab {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px 10px 0 0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .tab.active {
            background: white;
            color: var(--primary);
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .sidebar-section {
            margin-bottom: 30px;
        }
        
        .sidebar-section h3 {
            color: var(--primary);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .api-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: var(--light);
            border-radius: 8px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }
        
        .api-status.connected {
            border-right: 4px solid var(--success);
        }
        
        .api-status.disconnected {
            border-right: 4px solid var(--danger);
            animation: pulse 2s infinite;
        }
        
        .api-status.warning {
            border-right: 4px solid var(--warning);
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 8px;
        }
        
        .status-connected {
            background: var(--success);
        }
        
        .status-disconnected {
            background: var(--danger);
        }
        
        .status-warning {
            background: var(--warning);
        }
        
        .notification {
            position: fixed;
            top: 20px;
            left: 20px;
            right: calc(var(--sidebar-width) + 20px);
            background: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slideIn 0.5s ease;
            border-right: 4px solid var(--danger);
        }
        
        .notification.success {
            border-right-color: var(--success);
        }
        
        .notification.warning {
            border-right-color: var(--warning);
        }
        
        @keyframes slideIn {
            from { transform: translateY(-100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .close-notification {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: #666;
            padding: 5px;
        }
        
        .connection-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .stat-item {
            background: var(--light);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--primary);
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: #666;
        }

        /* استایل‌های جدید برای بخش امنیت */
        .security-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-left: 5px;
        }
        
        .security-high { background: var(--success); color: white; }
        .security-medium { background: var(--warning); color: black; }
        .security-low { background: var(--danger); color: white; }
        
        .encrypted-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
            color: var(--success);
            margin-bottom: 10px;
        }
        
        .performance-meter {
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            margin: 5px 0;
            overflow: hidden;
        }
        
        .performance-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.5s ease;
        }
        
        .model-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: var(--light);
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .model-status.active {
            border-right: 4px solid var(--success);
        }
        
        .technical-indicators {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .indicator {
            background: var(--light);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .indicator-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--primary);
        }
        
        .indicator-name {
            font-size: 0.9rem;
            color: #666;
        }
        
        .risk-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric {
            background: var(--light);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.4rem;
            font-weight: bold;
        }
        
        .metric-high {
            color: var(--danger);
        }
        
        .metric-medium {
            color: var(--warning);
        }
        
        .metric-low {
            color: var(--success);
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .feature-item {
            background: var(--light);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .feature-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .feature-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            color: var(--primary);
        }
        
        @media (max-width: 1200px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                width: 280px;
            }
            
            .main-content {
                margin-right: 280px;
            }
        }
        
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(100%);
                transition: transform 0.3s ease;
            }
            
            .sidebar.active {
                transform: translateX(0);
            }
            
            .main-content {
                margin-right: 0;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .control-group {
                width: 100%;
                justify-content: center;
            }
            
            select, button {
                flex: 1;
                min-width: 150px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
        }
        
        .menu-toggle {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
        }
        
        @media (max-width: 768px) {
            .menu-toggle {
                display: block;
            }
        }
    </style>
</head>
<body>
    <button class="menu-toggle" onclick="FinancialAnalysisApp.getInstance().uiManager.toggleSidebar()">☰</button>
    
    <div class="sidebar" id="sidebar">
        <div class="sidebar-section">
            <h3>🔍 وضعیت اتصال APIها</h3>
            <div id="apiStatusContainer">
                <!-- وضعیت APIها اینجا نمایش داده می‌شود -->
            </div>
            
            <div class="connection-stats">
                <div class="stat-item">
                    <div class="stat-value" id="connectedCount">0</div>
                    <div class="stat-label">متصل</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="disconnectedCount">0</div>
                    <div class="stat-label">قطع</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalCount">0</div>
                    <div class="stat-label">کل</div>
                </div>
            </div>
        </div>
        
        <div class="sidebar-section">
            <h3>🤖 وضعیت مدل‌های هوش مصنوعی</h3>
            <div class="model-status active">
                <span>AdvancedDecisionExplainer</span>
                <span class="status-indicator status-connected"></span>
            </div>
            <div class="model-status active">
                <span>MarketSentimentTransformer</span>
                <span class="status-indicator status-connected"></span>
            </div>
            <div class="model-status active">
                <span>PricePredictionTransformer</span>
                <span class="status-indicator status-connected"></span>
            </div>
            <div class="model-status active">
                <span>RiskAssessorAgent</span>
                <span class="status-indicator status-connected"></span>
            </div>
        </div>
        
        <div class="sidebar-section">
            <h3>📊 اندیکاتورهای فنی</h3>
            <div class="technical-indicators" id="technicalIndicators">
                <!-- توسط JavaScript پر می‌شود -->
            </div>
        </div>
        
        <div class="sidebar-section">
            <h3>⚠️ معیارهای ریسک</h3>
            <div class="risk-metrics" id="riskMetrics">
                <!-- توسط JavaScript پر می‌شود -->
            </div>
        </div>
        
        <div class="sidebar-section">
            <h3>🛡️ امنیت سیستم</h3>
            <div class="encrypted-indicator">
                <span>🔒</span>
                <span>تمامی داده‌ها رمزنگاری شده</span>
            </div>
            <div class="performance-meter">
                <div class="performance-fill" id="performanceMeter" style="width: 95%; background: var(--success);"></div>
            </div>
            <small>عملکرد سیستم: <span id="performanceText">عالی</span></small>
        </div>
    </div>
    
    <div class="main-content">
        <div class="container">
            <header>
                <h1>سیستم جامع تحلیل و معامله‌گری بازارهای مالی ایران</h1>
                <p class="subtitle">تحلیل یکپارچه بورس، ارز دیجیتال، طلا و ارز با نظارت هوشمند API</p>
                <div>
                    <span class="security-badge security-high">امنیت بالا</span>
                    <span class="security-badge security-high">داده‌های زنده</span>
                    <span class="security-badge security-medium">نسخه آزمایشی</span>
                </div>
            </header>
            
            <div class="controls">
                <div class="control-group">
                    <select id="marketType">
                        <option value="all">همه بازارها</option>
                        <option value="stock">بورس اوراق بهادار</option>
                        <option value="crypto">ارز دیجیتال</option>
                        <option value="gold">طلا و سکه</option>
                        <option value="currency">ارز</option>
                        <option value="commodity">کامودیتی</option>
                    </select>
                    
                    <select id="timeFrame">
                        <option value="1d">۱ روز</option>
                        <option value="1w">۱ هفته</option>
                        <option value="1m">۱ ماه</option>
                        <option value="3m">۳ ماه</option>
                        <option value="1y">۱ سال</option>
                    </select>
                    
                    <button id="refreshBtn">
                        <span>🔄</span> بروزرسانی داده‌ها
                    </button>
                </div>
                
                <div class="control-group">
                    <button id="analyzeBtn">
                        <span>🤖</span> تحلیل هوش مصنوعی
                    </button>
                    <button id="riskBtn">
                        <span>⚠️</span> ارزیابی ریسک
                    </button>
                    <button id="tradeBtn">
                        <span>💼</span> پیشنهاد معامله
                    </button>
                    <button id="monitorBtn">
                        <span>🔍</span> تست اتصال APIها
                    </button>
                    <button id="securityBtn">
                        <span>🛡️</span> تست امنیت
                    </button>
                </div>
            </div>
            
            <div class="tab-container">
                <div class="tabs">
                    <div class="tab active" data-tab="dashboard">داشبورد اصلی</div>
                    <div class="tab" data-tab="analysis">تحلیل پیشرفته</div>
                    <div class="tab" data-tab="explanations">توضیح‌پذیری AI</div>
                    <div class="tab" data-tab="trading">معاملات</div>
                    <div class="tab" data-tab="reports">گزارش‌ها</div>
                    <div class="tab" data-tab="transformer">مدل‌های Transformer</div>
                    <div class="tab" data-tab="monitoring">نظارت API</div>
                    <div class="tab" data-tab="security">امنیت و نظارت</div>
                    <div class="tab" data-tab="feature-importance">تحلیل اهمیت ویژگی‌ها</div>
                    <div class="tab" data-tab="model-interpretability">قابلیت تفسیر مدل</div>
                    <div class="tab" data-tab="advanced-sentiment">تحلیل احساسات پیشرفته</div>
                </div>
                
                <div class="tab-content active" id="dashboard-tab">
                    <div class="dashboard">
                        <div class="card">
                            <h2>وضعیت بازارها</h2>
                            <div class="market-grid" id="marketStatus">
                                <div class="loading">در حال بارگذاری داده‌های بازار...</div>
                            </div>
                        </div>
                        
                        <div class="card">
                            <h2>شاخص‌های کلان</h2>
                            <div id="indicesChart" class="chart-container"></div>
                        </div>
                        
                        <div class="card">
                            <h2>تحلیل قیمت و روند</h2>
                            <div id="priceChart" class="chart-container"></div>
                        </div>
                        
                        <div class="card">
                            <h2>وضعیت اتصال APIها</h2>
                            <div id="connectionChart" class="chart-container"></div>
                        </div>
                    </div>
                    
                    <div class="card analysis-section">
                        <h2>تحلیل هوش مصنوعی و پیشنهادات معاملاتی</h2>
                        <div class="analysis-grid" id="aiAnalysis">
                            <div class="loading">برای مشاهده تحلیل‌ها، دکمه "تحلیل هوش مصنوعی" را بفشارید</div>
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="analysis-tab">
                    <div class="card">
                        <h2>تحلیل پیشرفته بازار</h2>
                        <div class="feature-grid">
                            <div class="feature-item">
                                <div class="feature-icon">📊</div>
                                <h3>تحلیل تکنیکال</h3>
                                <p>اندیکاتورهای پیشرفته و سیگنال‌های معاملاتی</p>
                            </div>
                            <div class="feature-item">
                                <div class="feature-icon">📈</div>
                                <h3>تحلیل بنیادی</h3>
                                <p>ارزیابی ارزش ذاتی و پتانسیل رشد</p>
                            </div>
                            <div class="feature-item">
                                <div class="feature-icon">🧠</div>
                                <h3>هوش مصنوعی</h3>
                                <p>پیش‌بینی روند با مدل‌های Transformer</p>
                            </div>
                            <div class="feature-item">
                                <div class="feature-icon">📉</div>
                                <h3>تحلیل احساسات</h3>
                                <p>بررسی جو بازار و تأثیر اخبار</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>گزارش تحلیل بازار</h2>
                        <div id="advancedAnalysis" class="analysis-grid">
                            <div class="loading">در حال محاسبه تحلیل‌های پیشرفته...</div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>تحلیل ویژگی‌های مهم</h2>
                        <div id="featureImportanceChart" class="chart-container"></div>
                    </div>
                </div>
                
                <div class="tab-content" id="explanations-tab">
                    <div class="card">
                        <h2>توضیح‌پذیری هوش مصنوعی (XAI)</h2>
                        <div class="analysis-grid" id="xaiExplanations">
                            <div class="loading">در حال تولید توضیحات هوش مصنوعی...</div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>تحلیل SHAP</h2>
                        <div id="shapChart" class="chart-container"></div>
                    </div>
                    
                    <div class="card">
                        <h2>تحلیل LIME</h2>
                        <div id="limeChart" class="chart-container"></div>
                    </div>
                </div>
                
                <div class="tab-content" id="trading-tab">
                    <div class="card">
                        <h2>سیستم معاملاتی هوشمند</h2>
                        <div class="analysis-grid">
                            <div class="analysis-item opportunity-item">
                                <h3>پیشنهاد خرید</h3>
                                <p><strong>نماد:</strong> شتران</p>
                                <p><strong>قیمت هدف:</strong> ۵۲,۰۰۰ تومان</p>
                                <p><strong>حد ضرر:</strong> ۴۲,۰۰۰ تومان</p>
                                <div class="market-change positive">اعتماد: ۷۸%</div>
                            </div>
                            <div class="analysis-item opportunity-item">
                                <h3>پیشنهاد خرید</h3>
                                <p><strong>نماد:</strong> بیت‌کوین</p>
                                <p><strong>قیمت هدف:</strong> ۹۵,۰۰۰ دلار</p>
                                <p><strong>حد ضرر:</strong> ۷۸,۰۰۰ دلار</p>
                                <div class="market-change positive">اعتماد: ۸۲%</div>
                            </div>
                            <div class="analysis-item risk-item">
                                <h3>هشدار فروش</h3>
                                <p><strong>نماد:</strong> سکه امامی</p>
                                <p><strong>دلیل:</strong> رسیدن به محدوده اشباع خرید</p>
                                <p><strong>توصیه:</strong> کاهش موقعیت</p>
                                <div class="market-change negative">ریسک: بالا</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>تحلیل سناریوهای متغیر</h2>
                        <div id="counterfactualChart" class="chart-container"></div>
                    </div>
                </div>
                
                <div class="tab-content" id="reports-tab">
                    <div class="card">
                        <h2>گزارش‌های عملکرد</h2>
                        <div class="analysis-grid">
                            <div class="analysis-item">
                                <h3>عملکرد پرتفوی</h3>
                                <p><strong>سود/زیان کل:</strong> +۱۲.۵%</p>
                                <p><strong>بهترین عملکرد:</strong> بورس (+۱۸.۲%)</p>
                                <p><strong>ضعیف‌ترین عملکرد:</strong> ارز دیجیتال (+۵.۸%)</p>
                            </div>
                            <div class="analysis-item">
                                <h3>تحلیل ریسک</h3>
                                <p><strong>VaR 95%:</strong> -۳.۲%</p>
                                <p><strong>حداکثر افت:</strong> -۸.۵%</p>
                                <p><strong>نسبت شارپ:</strong> ۱.۴۵</p>
                            </div>
                            <div class="analysis-item">
                                <h3>گزارش معاملات</h3>
                                <p><strong>تعداد معاملات:</strong> ۴۷</p>
                                <p><strong>میانگین سود:</strong> +۴.۲%</p>
                                <p><strong>نرخ موفقیت:</strong> ۶۸%</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="transformer-tab">
                    <div class="card">
                        <h2>مدل‌های Transformer پیشرفته</h2>
                        <div class="analysis-grid">
                            <div class="analysis-item">
                                <h3>MarketSentimentTransformer</h3>
                                <p><strong>معماری:</strong> BERT-base + Attention Layers</p>
                                <p><strong>دقت:</strong> ۸۷.۳%</p>
                                <p><strong>کاربرد:</strong> تحلیل احساسات بازار</p>
                            </div>
                            <div class="analysis-item">
                                <h3>PricePredictionTransformer</h3>
                                <p><strong>معماری:</strong> Multi-Scale Attention</p>
                                <p><strong>دقت:</strong> ۷۹.۸%</p>
                                <p><strong>کاربرد:</strong> پیش‌بینی قیمت</p>
                            </div>
                            <div class="analysis-item">
                                <h3>TimeSeriesTransformer</h3>
                                <p><strong>معماری:</strong> Positional Encoding</p>
                                <p><strong>دقت:</strong> ۸۲.۱%</p>
                                <p><strong>کاربرد:</strong> تحلیل سری زمانی</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>پیش‌بینی‌های Transformer</h2>
                        <div id="transformerPredictionsChart" class="chart-container"></div>
                    </div>
                </div>
                
                <div class="tab-content" id="monitoring-tab">
                    <div class="card">
                        <h2>سیستم نظارت هوشمند APIها</h2>
                        <div class="analysis-grid">
                            <div class="analysis-item">
                                <h3>📡 وضعیت لحظه‌ای اتصال</h3>
                                <div id="liveMonitoring" class="market-grid">
                                    <!-- وضعیت لحظه‌ای -->
                                </div>
                            </div>
                            <div class="analysis-item">
                                <h3>📈 آمار عملکرد APIها</h3>
                                <div id="performanceStats">
                                    <!-- آمار عملکرد -->
                                </div>
                            </div>
                            <div class="analysis-item">
                                <h3>🔔 هشدارهای اخیر</h3>
                                <div id="recentAlerts">
                                    <!-- هشدارها -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="security-tab">
                    <div class="card">
                        <h2>سیستم نظارت و امنیت</h2>
                        <div class="analysis-grid">
                            <div class="analysis-item">
                                <h3>وضعیت اتصال APIها</h3>
                                <div id="apiMonitoringStatus">
                                    <!-- توسط JavaScript پر می‌شود -->
                                </div>
                            </div>
                            <div class="analysis-item">
                                <h3>لاگ امنیتی</h3>
                                <div id="securityLog" style="max-height: 300px; overflow-y: auto;">
                                    <!-- توسط JavaScript پر می‌شود -->
                                </div>
                            </div>
                            <div class="analysis-item">
                                <h3>عملکرد سیستم</h3>
                                <div id="performanceMetrics">
                                    <!-- توسط JavaScript پر می‌شود -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- تحلیل اهمیت ویژگی‌ها -->
<div class="tab-content" id="feature-importance-tab">
    <div class="card">
        <h2>تحلیل جامع اهمیت ویژگی‌ها</h2>
        <div class="analysis-grid" id="featureImportanceAnalysis">
            <div class="loading">در حال محاسبه تحلیل اهمیت ویژگی‌ها...</div>
        </div>
    </div>
    
    <div class="card">
        <h2>نمودار اهمیت سراسری ویژگی‌ها</h2>
        <div id="globalFeatureImportanceChart" class="chart-container"></div>
    </div>
    
    <div class="card">
        <h2>تحلیل تعامل ویژگی‌ها</h2>
        <div id="featureInteractionChart" class="chart-container"></div>
    </div>
</div>

<!-- قابلیت تفسیر مدل -->
<div class="tab-content" id="model-interpretability-tab">
    <div class="card">
        <h2>تحلیل قابلیت تفسیر مدل</h2>
        <div class="analysis-grid" id="modelInterpretabilityAnalysis">
            <div class="loading">در حال تحلیل قابلیت تفسیر مدل...</div>
        </div>
    </div>
</div>

<!-- تحلیل احساسات پیشرفته -->
<div class="tab-content" id="advanced-sentiment-tab">
    <div class="card">
        <h2>تحلیل احساسات بازار با Transformer</h2>
        <div class="analysis-grid" id="advancedSentimentAnalysis">
            <div class="loading">در حال تحلیل احساسات بازار...</div>
        </div>
    </div>
</div>
                    
                    <div class="card">
                        <h2>تنظیمات امنیتی</h2>
                        <div class="controls">
                            <div class="control-group">
                                <button id="encryptDataBtn">
                                    <span>🔒</span> رمزنگاری داده‌ها
                                </button>
                                <button id="clearCacheBtn">
                                    <span>🧹</span> پاک‌سازی کش
                                </button>
                                <button id="testSecurityBtn">
                                    <span>🛡️</span> تست امنیت
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===============================
        // سیستم مدیریت خطا و لاگینگ پیشرفته
        // ===============================
        class ErrorHandler {
            static init() {
                window.addEventListener('error', this.handleGlobalError.bind(this));
                window.addEventListener('unhandledrejection', this.handlePromiseRejection.bind(this));
            }

            static handleGlobalError(event) {
                const error = {
                    type: 'GlobalError',
                    message: event.message,
                    filename: event.filename,
                    lineno: event.lineno,
                    colno: event.colno,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent
                };
                
                this.logError(error);
                this.notifyUser('خطای سیستمی رخ داده است', 'error');
            }

            static handlePromiseRejection(event) {
                const error = {
                    type: 'PromiseRejection',
                    reason: event.reason?.message || event.reason,
                    timestamp: new Date().toISOString()
                };
                
                this.logError(error);
                this.notifyUser('خطا در پردازش درخواست', 'error');
            }

            static logError(error) {
                console.error('Error logged:', error);
                if (window.SecurityManager) {
                    window.SecurityManager.logSecurityEvent('ERROR', error);
                }
            }

            static notifyUser(message, type = 'error') {
                if (window.UIManager) {
                    window.UIManager.showNotification(message, type);
                }
            }

            static async apiCallWithRetry(apiCall, maxRetries = 3, context = '') {
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        return await apiCall();
                    } catch (error) {
                        console.warn(`Attempt ${i + 1} failed for ${context}:`, error);
                        
                        if (i === maxRetries - 1) {
                            this.logError({
                                type: 'APIRetryExhausted',
                                context: context,
                                error: error.message,
                                retries: maxRetries
                            });
                            throw error;
                        }
                        
                        await this.delay(Math.pow(2, i) * 1000);
                    }
                }
            }

            static delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // ===============================
        // سیستم مدیریت امنیت پیشرفته
        // ===============================
        class SecurityManager {
            constructor() {
                this.encryptionKey = this.generateEncryptionKey();
                this.securityLog = [];
                this.suspiciousActivities = [];
            }

            generateEncryptionKey() {
                return CryptoJS.lib.WordArray.random(128/8).toString();
            }

            encryptData(data) {
                try {
                    if (typeof data !== 'string') {
                        data = JSON.stringify(data);
                    }
                    return CryptoJS.AES.encrypt(data, this.encryptionKey).toString();
                } catch (error) {
                    ErrorHandler.logError({
                        type: 'EncryptionError',
                        error: error.message,
                        dataType: typeof data
                    });
                    return data;
                }
            }

            decryptData(encryptedData) {
                try {
                    const bytes = CryptoJS.AES.decrypt(encryptedData, this.encryptionKey);
                    return bytes.toString(CryptoJS.enc.Utf8);
                } catch (error) {
                    ErrorHandler.logError({
                        type: 'DecryptionError',
                        error: error.message
                    });
                    return encryptedData;
                }
            }

            sanitizeInput(input) {
                if (typeof input !== 'string') return input;
                
                input = input.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
                input = input.replace(/<[^>]*>/g, '');
                input = input.replace(/[<>"'`]/g, '');
                
                return input.trim();
            }

            validateAPIResponse(data, schema) {
                if (!data) {
                    this.logSecurityEvent('VALIDATION_FAILED', 'Empty response data');
                    return false;
                }

                if (schema === 'array' && !Array.isArray(data)) {
                    this.logSecurityEvent('VALIDATION_FAILED', 'Expected array response');
                    return false;
                }

                if (schema === 'object' && (typeof data !== 'object' || Array.isArray(data))) {
                    this.logSecurityEvent('VALIDATION_FAILED', 'Expected object response');
                    return false;
                }

                return true;
            }

            logSecurityEvent(type, details) {
                const event = {
                    type,
                    details,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    url: window.location.href
                };

                this.securityLog.unshift(event);
                
                if (this.securityLog.length > 100) {
                    this.securityLog = this.securityLog.slice(0, 100);
                }

                this.updateSecurityLogUI();
                this.detectSuspiciousActivity(event);
            }

            detectSuspiciousActivity(event) {
                const suspiciousPatterns = [
                    'FAILED',
                    'ERROR',
                    'UNAUTHORIZED',
                    'VALIDATION_FAILED'
                ];

                if (suspiciousPatterns.some(pattern => event.type.includes(pattern))) {
                    this.suspiciousActivities.push(event);
                    
                    if (this.suspiciousActivities.length > 5) {
                        this.notifyAdmin('فعالیت مشکوک شناسایی شد');
                    }
                }
            }

            notifyAdmin(message) {
                console.warn('Admin notification:', message);
            }

            updateSecurityLogUI() {
                const logContainer = document.getElementById('securityLog');
                if (!logContainer) return;

                const logItems = this.securityLog.slice(0, 10).map(event => `
                    <div style="padding: 5px; border-bottom: 1px solid #eee; font-size: 0.9rem;">
                        <strong>${new Date(event.timestamp).toLocaleTimeString('fa-IR')}</strong>
                        <br>${event.type}: ${event.details}
                    </div>
                `).join('');

                logContainer.innerHTML = logItems || '<div>هیچ رویداد امنیتی ثبت نشده است</div>';
            }

            async testSecurity() {
                const tests = [
                    this.testEncryption(),
                    this.testSanitization(),
                    this.testValidation()
                ];

                const results = await Promise.allSettled(tests);
                
                const passed = results.filter(r => r.status === 'fulfilled' && r.value).length;
                const total = tests.length;

                this.logSecurityEvent('SECURITY_TEST', `${passed} از ${total} تست امنیتی موفق`);
                
                return passed === total;
            }

            async testEncryption() {
                try {
                    const testData = 'test data';
                    const encrypted = this.encryptData(testData);
                    const decrypted = this.decryptData(encrypted);
                    return decrypted === testData;
                } catch (error) {
                    return false;
                }
            }

            async testSanitization() {
                const maliciousInput = '<script>alert("xss")</script>test';
                const sanitized = this.sanitizeInput(maliciousInput);
                return sanitized === 'test';
            }

            async testValidation() {
                return this.validateAPIResponse([], 'array') && 
                       this.validateAPIResponse({}, 'object') &&
                       !this.validateAPIResponse('invalid', 'array');
            }
        }

        // ===============================
        // سیستم مدیریت API پیشرفته
        // ===============================
        class APIService {
            constructor() {
                this.endpoints = this.loadEndpoints();
                this.cache = new Map();
                this.requestQueue = new Map();
                this.cacheTTL = 5 * 60 * 1000;
            }

            loadEndpoints() {
                return {
                    stockDetail: (symbol) => this.buildURL('Tsetmc/SymbolData.php', {symbol: symbol}),
                    historicalData: (symbol, days) => this.buildURL('Tsetmc/History.php', {symbol: symbol, days: days}),
                    marketDepth: (symbol) => this.buildURL('Tsetmc/MarketDepth.php', {symbol: symbol}),
                    stockSymbols: this.buildURL('Tsetmc/AllSymbols.php'),
                    stockIndex: this.buildURL('Tsetmc/Index.php', {type: 1}),
                    farabourseIndex: this.buildURL('Tsetmc/Index.php', {type: 2}),
                    crypto: this.buildURL('Market/Cryptocurrency.php'),
                    commodityMetals: this.buildURL('Market/Commodity.php', {type: 1}),
                    commodityBaseMetals: this.buildURL('Market/Commodity.php', {type: 2}),
                    commodityEnergy: this.buildURL('Market/Commodity.php', {type: 3}),
                    gold: this.buildURL('Market/Gold_Currency.php', {type: 1}),
                    currency: this.buildURL('Market/Gold_Currency.php', {type: 2}),
                    crypto2: this.buildURL('Market/Gold_Currency.php', {type: 3})
                };
            }

    this.fallbackAPIs = [
            'https://api.example.com/financial/data',
            'https://backup-api.example.com/market'
        ];
    }

    async makeRequestWithFallback(endpointKey, options = {}) {
        let lastError;
        
        for (let i = 0; i < this.fallbackAPIs.length + 1; i++) {
            try {
                if (i === 0) {
                    return await this.makeRequest(endpointKey, options);
                } else {
                    // استفاده از APIهای جایگزین
                    const fallbackURL = this.fallbackAPIs[i - 1];
                    return await this.executeRequest(fallbackURL, endpointKey, options);
                }
            } catch (error) {
                lastError = error;
                console.warn(`Attempt ${i + 1} failed:`, error);
            }
        }
        
        throw lastError;
    }
}

    

            buildURL(path, params = {}) {
                const baseURL = 'https://BrsApi.ir/Api/';
                const searchParams = new URLSearchParams(params);
                searchParams.append('key', 'BKNzfpdXhJMcUANBeAAcNT24Cdys8MES');
                return `${baseURL}${path}?${searchParams.toString()}`;
            }

            async makeRequest(endpointKey, options = {}) {
                const url = this.endpoints[endpointKey];
                if (!url) {
                    throw new Error(`Endpoint not found: ${endpointKey}`);
                }

                const cacheKey = this.generateCacheKey(endpointKey, options);
                
                if (options.useCache !== false) {
                    const cached = this.getFromCache(cacheKey);
                    if (cached) return cached;
                }

                if (this.requestQueue.has(cacheKey)) {
                    return this.requestQueue.get(cacheKey);
                }

                const requestPromise = this.executeRequest(url, endpointKey, options, cacheKey);
                this.requestQueue.set(cacheKey, requestPromise);

                try {
                    const result = await requestPromise;
                    return result;
                } finally {
                    this.requestQueue.delete(cacheKey);
                }
            }

            async executeRequest(url, endpointKey, options, cacheKey) {
                const securityManager = window.SecurityManager;
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), options.timeout || 10000);

                try {
                    const response = await axios.get(url, {
                        signal: controller.signal,
                        timeout: options.timeout || 10000,
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        ...options
                    });

                    clearTimeout(timeoutId);

                    if (!this.validateResponse(response, endpointKey)) {
                        throw new Error(`Invalid response for ${endpointKey}`);
                    }

                    const encryptedData = securityManager.encryptData(JSON.stringify(response.data));
                    
                    this.setCache(cacheKey, response.data);

                    securityManager.logSecurityEvent('API_SUCCESS', endpointKey);
                    
                    return response.data;

                } catch (error) {
                    clearTimeout(timeoutId);
                    
                    const errorDetails = {
                        endpoint: endpointKey,
                        url: url,
                        error: error.message,
                        timestamp: new Date().toISOString()
                    };

                    securityManager.logSecurityEvent('API_ERROR', JSON.stringify(errorDetails));
                    
                    if (options.useFallback !== false) {
                        return this.getFallbackData(endpointKey);
                    }
                    
                    throw error;
                }
            }

            validateResponse(response, endpointKey) {
                if (response.status !== 200) return false;
                
                const schema = this.getResponseSchema(endpointKey);
                return window.SecurityManager.validateAPIResponse(response.data, schema);
            }

            getResponseSchema(endpointKey) {
                const arrayEndpoints = [
                    'stockSymbols', 'stockIndex', 'farabourseIndex', 'crypto',
                    'commodityMetals', 'commodityBaseMetals', 'commodityEnergy',
                    'gold', 'currency', 'crypto2'
                ];
                
                return arrayEndpoints.includes(endpointKey) ? 'array' : 'object';
            }

            generateCacheKey(endpointKey, options) {
                return `${endpointKey}_${JSON.stringify(options)}`;
            }

            getFromCache(key) {
                const cached = this.cache.get(key);
                if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
                    return cached.data;
                }
                this.cache.delete(key);
                return null;
            }

            setCache(key, data) {
                this.cache.set(key, {
                    data: data,
                    timestamp: Date.now()
                });
            }

            clearCache() {
                this.cache.clear();
                window.SecurityManager.logSecurityEvent('CACHE_CLEARED', 'All cache cleared');
            }

            getFallbackData(endpointKey) {
                const fallbackGenerators = {
                    'stockSymbols': () => this.generateMockStocks(),
                    'stockIndex': () => this.generateMockIndices(),
                    'farabourseIndex': () => this.generateMockIndices(),
                    'crypto': () => this.generateMockCrypto(),
                    'commodityMetals': () => this.generateMockCommodities(),
                    'commodityBaseMetals': () => this.generateMockCommodities(),
                    'commodityEnergy': () => this.generateMockCommodities(),
                    'gold': () => this.generateMockGold(),
                    'currency': () => this.generateMockCurrency(),
                    'crypto2': () => this.generateMockCrypto()
                };

                return fallbackGenerators[endpointKey] ? fallbackGenerators[endpointKey]() : [];
            }

            generateMockStocks() {
                const symbols = ['شتران', 'فولاد', 'خساپا', 'وبصادر', 'شپنا', 'کگل', 'فملی', 'وتجارت', 'خپارس', 'برکت'];
                return symbols.map(symbol => ({
                    symbol: symbol,
                    name: `شرکت ${symbol}`,
                    price: Math.floor(Math.random() * 50000) + 10000,
                    change: (Math.random() * 2000) - 1000,
                    changePercent: (Math.random() * 10) - 5,
                    volume: Math.floor(Math.random() * 10000000),
                    value: Math.floor(Math.random() * 500000000000),
                    high: Math.floor(Math.random() * 60000) + 10000,
                    low: Math.floor(Math.random() * 40000) + 5000
                }));
            }

            generateMockIndices() {
                const indices = ['شاخص کل', 'شاخص هم وزن', 'شاخص صنعت', 'شاخص مالی'];
                return indices.map(name => ({
                    name: name,
                    value: Math.floor(Math.random() * 5000000) + 2000000,
                    change: (Math.random() * 50000) - 25000,
                    changePercent: (Math.random() * 5) - 2.5,
                    high: Math.floor(Math.random() * 6000000) + 2000000,
                    low: Math.floor(Math.random() * 4000000) + 1000000
                }));
            }

            generateMockCrypto() {
                const cryptos = ['بیت‌کوین', 'اتریوم', 'ریپل', 'کاردانو', 'سولانا'];
                return cryptos.map(name => ({
                    name: name,
                    price: Math.floor(Math.random() * 50000) + 20000,
                    priceToman: Math.floor(Math.random() * 5000000000) + 2000000000,
                    changePercent: (Math.random() * 15) - 7.5,
                    marketCap: Math.floor(Math.random() * 1000000000000) + 500000000000
                }));
            }

            generateMockGold() {
                const goldItems = ['سکه امامی', 'سکه بهار آزادی', 'نیم سکه', 'ربع سکه', 'طلای 18 عیار'];
                return goldItems.map(name => ({
                    symbol: name.replace(/\s/g, '_'),
                    name: name,
                    price: Math.floor(Math.random() * 50000000) + 50000000,
                    change: (Math.random() * 2000000) - 1000000,
                    changePercent: (Math.random() * 8) - 4,
                    unit: 'تومان'
                }));
            }

            generateMockCurrency() {
                const currencies = ['دلار', 'یورو', 'پوند', 'درهم', 'ین'];
                return currencies.map(name => ({
                    symbol: name,
                    name: name,
                    price: Math.floor(Math.random() * 50000) + 10000,
                    change: (Math.random() * 1000) - 500,
                    changePercent: (Math.random() * 6) - 3,
                    unit: 'تومان'
                }));
            }

            generateMockCommodities() {
                const commodities = ['نفت برنت', 'طلای جهانی', 'نقره', 'مس', 'آلومینیوم'];
                return commodities.map(name => ({
                    symbol: name.replace(/\s/g, '_'),
                    name: name,
                    price: Math.floor(Math.random() * 200) + 50,
                    change: (Math.random() * 10) - 5,
                    changePercent: (Math.random() * 8) - 4,
                    unit: 'دلار'
                }));
            }
        }

        // ===============================
        // سیستم مدیریت رابط کاربری
        // ===============================
        class UIManager {
            constructor() {
                this.debounceTimers = new Map();
                this.intersectionObservers = new Map();
            }

            init() {
                this.setupEventListeners();
                this.setupTabs();
                this.initializeCharts();
                this.setupPerformanceMonitoring();
            }

            setupEventListeners() {
                document.addEventListener('click', this.handleGlobalClick.bind(this));
                this.setupDebouncedInputs();
                        document.addEventListener('click', (event) => {
        const target = event.target;
        if (target.classList.contains('tab')) {
            const tabId = target.getAttribute('data-tab');
            if (tabId === 'feature-importance') {
                window.FinancialAnalysisApp.performAdvancedFeatureAnalysis();
            } else if (tabId === 'model-interpretability') {
                window.FinancialAnalysisApp.performModelInterpretabilityAnalysis();
            } else if (tabId === 'advanced-sentiment') {
                window.FinancialAnalysisApp.performAdvancedSentimentAnalysis();
            }
        }
    });
}
            }

            handleGlobalClick(event) {
                const target = event.target;
                
                if (target.classList.contains('tab')) {
                    this.handleTabClick(target);
                } else if (target.id === 'refreshBtn') {
                    this.debounce('refresh', () => window.FinancialAnalysisApp.loadMarketData(), 300);
                } else if (target.id === 'analyzeBtn') {
                    this.debounce('analyze', () => window.FinancialAnalysisApp.performAIAnalysis(), 300);
                } else if (target.id === 'securityBtn') {
                    this.debounce('security', () => window.FinancialAnalysisApp.testSecurity(), 300);
                }
            }

            handleTabClick(tab) {
                const tabs = document.querySelectorAll('.tab');
                tabs.forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                tab.classList.add('active');
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(`${tabId}-tab`).classList.add('active');
                
                if (tabId === 'explanations') {
                    window.FinancialAnalysisApp.loadXAIExplanations();
                } else if (tabId === 'transformer') {
                    window.FinancialAnalysisApp.loadTransformerPredictions();
                } else if (tabId === 'security') {
                    window.FinancialAnalysisApp.updateSecurityTab();
                }
            }

            setupDebouncedInputs() {
                const debouncedInputs = {
                    'marketType': (value) => window.FinancialAnalysisApp.updateCharts(),
                    'timeFrame': (value) => window.FinancialAnalysisApp.updateCharts()
                };

                Object.keys(debouncedInputs).forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', this.debounce(
                            id, 
                            () => debouncedInputs[id](element.value), 
                            500
                        ));
                    }
                });
            }

            debounce(key, func, wait) {
                if (this.debounceTimers.has(key)) {
                    clearTimeout(this.debounceTimers.get(key));
                }
                
                const timer = setTimeout(() => {
                    func();
                    this.debounceTimers.delete(key);
                }, wait);
                
                this.debounceTimers.set(key, timer);
            }

            setupTabs() {
                const tabs = document.querySelectorAll('.tab');
                tabs.forEach(tab => {
                    tab.addEventListener('click', () => this.handleTabClick(tab));
                });
            }

            initializeCharts() {
                const chartContainers = [
                    'indicesChart', 'priceChart', 'connectionChart', 'featureImportanceChart',
                    'shapChart', 'limeChart', 'counterfactualChart', 'transformerPredictionsChart'
                ];

                chartContainers.forEach(containerId => {
                    this.createEmptyChart(containerId, 'در حال بارگذاری...');
                });
            }

            createEmptyChart(containerId, title) {
                const layout = {
                    title: title,
                    xaxis: { title: 'زمان' },
                    yaxis: { title: 'مقدار' },
                    font: { family: 'Tahoma' },
                    showlegend: false
                };
                
                Plotly.newPlot(containerId, [], layout, { responsive: true });
            }

            showNotification(message, type = 'info') {
                const existingNotification = document.querySelector('.notification');
                if (existingNotification) {
                    existingNotification.remove();
                }
                
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                
                notification.innerHTML = `
                    <div>${message}</div>
                    <button class="close-notification" onclick="this.parentElement.remove()">×</button>
                `;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 5000);
            }

            toggleSidebar() {
                const sidebar = document.getElementById('sidebar');
                sidebar.classList.toggle('active');
            }

            setupPerformanceMonitoring() {
                if ('PerformanceObserver' in window) {
                    const observer = new PerformanceObserver((list) => {
                        const entries = list.getEntries();
                        entries.forEach(entry => {
                            if (entry.entryType === 'measure') {
                                this.updatePerformanceMetrics(entry);
                            }
                        });
                    });
                    
                    observer.observe({ entryTypes: ['measure'] });
                }
            }

            updatePerformanceMetrics(entry) {
                const meter = document.getElementById('performanceMeter');
                const text = document.getElementById('performanceText');
                
                if (entry.duration < 100) {
                    meter.style.background = 'var(--success)';
                    meter.style.width = '95%';
                    text.textContent = 'عالی';
                } else if (entry.duration < 500) {
                    meter.style.background = 'var(--warning)';
                    meter.style.width = '75%';
                    text.textContent = 'خوب';
                } else {
                    meter.style.background = 'var(--danger)';
                    meter.style.width = '50%';
                    text.textContent = 'نیاز به بهبود';
                }
            }

            showLoading(elementId, message) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerHTML = `<div class="loading">${message}</div>`;
                }
            }

            showError(elementId, message) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerHTML = `<div class="loading" style="color: #dc3545;">${message}</div>`;
                }
            }
        }

        // ===============================
        // سیستم نظارت هوشمند API
        // ===============================
        class APIMonitoringSystem {
            constructor() {
                this.apiStatus = {};
                this.connectionHistory = [];
                this.alerts = [];
                this.monitoringInterval = null;
                this.isMonitoring = false;
                
                this.initializeMonitoring();
            }

            initializeMonitoring() {
                const API_ENDPOINTS = {
                    stockSymbols: 'https://BrsApi.ir/Api/Tsetmc/AllSymbols.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES',
                    stockIndex: 'https://BrsApi.ir/Api/Tsetmc/Index.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=1',
                    farabourseIndex: 'https://BrsApi.ir/Api/Tsetmc/Index.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=2',
                    crypto: 'https://BrsApi.ir/Api/Market/Cryptocurrency.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES',
                    commodityMetals: 'https://BrsApi.ir/Api/Market/Commodity.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=1',
                    commodityBaseMetals: 'https://BrsApi.ir/Api/Market/Commodity.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=2',
                    commodityEnergy: 'https://BrsApi.ir/Api/Market/Commodity.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=3',
                    gold: 'https://BrsApi.ir/Api/Market/Gold_Currency.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=1',
                    currency: 'https://BrsApi.ir/Api/Market/Gold_Currency.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=2',
                    crypto2: 'https://BrsApi.ir/Api/Market/Gold_Currency.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=3'
                };

                const API_NAMES = {
                    stockSymbols: 'نمادهای بورس',
                    stockIndex: 'شاخص بورس',
                    farabourseIndex: 'شاخص فرابورس',
                    crypto: 'ارز دیجیتال',
                    commodityMetals: 'فلزات گرانبها',
                    commodityBaseMetals: 'فلزات اساسی',
                    commodityEnergy: 'انرژی',
                    gold: 'طلا و سکه',
                    currency: 'ارز',
                    crypto2: 'ارز دیجیتال (منبع ۲)'
                };

                for (const [key, url] of Object.entries(API_ENDPOINTS)) {
                    this.apiStatus[key] = {
                        name: API_NAMES[key],
                        url: url,
                        status: 'unknown',
                        lastCheck: null,
                        responseTime: null,
                        successRate: 0,
                        errorCount: 0,
                        successCount: 0,
                        lastError: null,
                        shouldBeActive: this.shouldAPIBeActive(key)
                    };
                }
            }

            shouldAPIBeActive(apiKey) {
                const tehranTime = this.getTehranTime();
                const hour = tehranTime.getHours();
                const minute = tehranTime.getMinutes();
                const day = tehranTime.getDay();
                
                if (apiKey.includes('stock') || apiKey.includes('Index')) {
                    if (day >= 5) return false;
                    if (hour < 9 || hour > 12) return false;
                    if (hour === 12 && minute > 30) return false;
                }
                
                return true;
            }

            getTehranTime() {
                const now = new Date();
                const tehranOffset = 3.5 * 60 * 60 * 1000;
                return new Date(now.getTime() + tehranOffset);
            }

            startAutoMonitoring() {
                if (this.monitoringInterval) {
                    clearInterval(this.monitoringInterval);
                }
                
                this.isMonitoring = true;
                this.monitoringInterval = setInterval(() => {
                    this.checkAllAPIs();
                }, 60000);
                
                this.checkAllAPIs();
                
                window.UIManager.showNotification('سیستم نظارت خودکار APIها فعال شد', 'success');
            }

            async checkAllAPIs() {
                const promises = [];
                
                for (const [key, apiInfo] of Object.entries(this.apiStatus)) {
                    promises.push(this.checkSingleAPI(key, apiInfo));
                }
                
                await Promise.allSettled(promises);
                this.updateMonitoringDisplay();
            }

            async checkSingleAPI(apiKey, apiInfo) {
                apiInfo.shouldBeActive = this.shouldAPIBeActive(apiKey);
                
                if (!apiInfo.shouldBeActive) {
                    apiInfo.status = 'inactive_hours';
                    apiInfo.lastCheck = new Date();
                    return;
                }

                try {
                    const startTime = Date.now();
                    const response = await axios.get(apiInfo.url, {
                        timeout: 10000,
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    const responseTime = Date.now() - startTime;
                    
                    apiInfo.status = 'connected';
                    apiInfo.lastCheck = new Date();
                    apiInfo.responseTime = responseTime;
                    apiInfo.successCount++;
                    apiInfo.lastError = null;
                    
                    const totalRequests = apiInfo.successCount + apiInfo.errorCount;
                    apiInfo.successRate = totalRequests > 0 ? (apiInfo.successCount / totalRequests) * 100 : 0;
                    
                    this.connectionHistory.push({
                        api: apiKey,
                        timestamp: new Date(),
                        status: 'success',
                        responseTime: responseTime
                    });
                    
                } catch (error) {
                    apiInfo.status = 'disconnected';
                    apiInfo.lastCheck = new Date();
                    apiInfo.errorCount++;
                    apiInfo.lastError = error.message;
                    
                    const totalRequests = apiInfo.successCount + apiInfo.errorCount;
                    apiInfo.successRate = totalRequests > 0 ? (apiInfo.successCount / totalRequests) * 100 : 0;
                    
                    this.connectionHistory.push({
                        api: apiKey,
                        timestamp: new Date(),
                        status: 'error',
                        error: error.message
                    });
                    
                    this.sendAlert(apiKey, `قطع ارتباط با ${apiInfo.name}`, error.message);
                }
            }

            sendAlert(apiKey, title, message) {
                const alert = {
                    id: Date.now(),
                    apiKey: apiKey,
                    apiName: this.apiStatus[apiKey].name,
                    title: title,
                    message: message,
                    timestamp: new Date(),
                    read: false
                };
                
                this.alerts.unshift(alert);
                
                window.UIManager.showNotification(`🚨 ${title}: ${message}`, 'error');
                
                if (this.alerts.length > 50) {
                    this.alerts = this.alerts.slice(0, 50);
                }
                
                this.updateAlertsDisplay();
            }

            updateMonitoringDisplay() {
                this.updateSidebarStatus();
                this.updateConnectionStats();
            }

            updateSidebarStatus() {
                const container = document.getElementById('apiStatusContainer');
                let html = '';
                
                for (const [key, apiInfo] of Object.entries(this.apiStatus)) {
                    let statusClass = 'api-status ';
                    let statusText = '';
                    let indicatorClass = '';
                    
                    if (!apiInfo.shouldBeActive) {
                        statusClass += 'warning';
                        statusText = '⏸ غیرفعال (ساعات کاری)';
                        indicatorClass = 'status-warning';
                    } else if (apiInfo.status === 'connected') {
                        statusClass += 'connected';
                        statusText = `✅ متصل (${apiInfo.responseTime}ms)`;
                        indicatorClass = 'status-connected';
                    } else if (apiInfo.status === 'disconnected') {
                        statusClass += 'disconnected';
                        statusText = '❌ قطع ارتباط';
                        indicatorClass = 'status-disconnected';
                    } else {
                        statusClass += 'warning';
                        statusText = '🔍 در حال بررسی...';
                        indicatorClass = 'status-warning';
                    }
                    
                    html += `
                        <div class="${statusClass}">
                            <div>
                                <strong>${apiInfo.name}</strong>
                                <br>
                                <small>${statusText}</small>
                            </div>
                            <span class="status-indicator ${indicatorClass}"></span>
                        </div>
                    `;
                }
                
                container.innerHTML = html;
            }

            updateConnectionStats() {
                let connected = 0;
                let disconnected = 0;
                let total = 0;
                
                for (const apiInfo of Object.values(this.apiStatus)) {
                    if (apiInfo.shouldBeActive) {
                        total++;
                        if (apiInfo.status === 'connected') {
                            connected++;
                        } else if (apiInfo.status === 'disconnected') {
                            disconnected++;
                        }
                    }
                }
                
                document.getElementById('connectedCount').textContent = connected;
                document.getElementById('disconnectedCount').textContent = disconnected;
                document.getElementById('totalCount').textContent = total;
            }

            updateAlertsDisplay() {
                const container = document.getElementById('recentAlerts');
                if (!container) return;

                const alertsHTML = this.alerts.slice(0, 5).map(alert => `
                    <div style="padding: 10px; border-bottom: 1px solid #eee;">
                        <strong>${alert.title}</strong>
                        <br>
                        <small>${alert.message}</small>
                        <br>
                        <small style="color: #666;">${new Date(alert.timestamp).toLocaleString('fa-IR')}</small>
                    </div>
                `).join('');

                container.innerHTML = alertsHTML || '<div>هیچ هشداری وجود ندارد</div>';
            }
        }

        // ===============================
        // کلاس‌های هوش مصنوعی
        // ===============================
        const ExplanationType = {
            COUNTERFACTUAL: "counterfactual",
            CONTRASTIVE: "contrastive",
            CAUSAL: "causal",
            EXAMPLE_BASED: "example_based",
            FEATURE_BASED: "feature_based"
        };

        const ConfidenceLevel = {
            VERY_HIGH: "very_high",
            HIGH: "high",
            MEDIUM: "medium",
            LOW: "low",
            VERY_LOW: "very_low"
        };

        const DecisionImpact = {
            STRONG_POSITIVE: "strong_positive",
            POSITIVE: "positive",
            NEUTRAL: "neutral",
            NEGATIVE: "negative",
            STRONG_NEGATIVE: "strong_negative"
        };

        class AdvancedDecisionExplainer {
            constructor(config = {}) {
                this.config = {
                    counterfactual_samples: 1000,
                    similarity_threshold: 0.8,
                    max_counterfactuals: 5,
                    confidence_thresholds: {
                        'very_high': 0.9,
                        'high': 0.8,
                        'medium': 0.7,
                        'low': 0.6,
                        'very_low': 0.5
                    },
                    ...config
                };
            }

            explain_decision(model, instance, feature_names, training_data = null, explanation_type = ExplanationType.COUNTERFACTUAL) {
                try {
                    const [prediction, confidence] = this._get_prediction_with_confidence(instance);
                    const confidence_level = this._get_confidence_level(confidence);
                    const key_factors = this._analyze_key_factors(instance, prediction);
                    const counterfactuals = this._generate_counterfactuals(instance, prediction);
                    
                    return {
                        prediction: prediction,
                        confidence: confidence,
                        confidence_level: confidence_level,
                        key_factors: key_factors,
                        counterfactuals: counterfactuals,
                        explanation_type: explanation_type,
                        rationale: this._generate_rationale(prediction, key_factors, counterfactuals)
                    };
                    
                } catch (error) {
                    ErrorHandler.logError({
                        type: 'DecisionExplanationError',
                        error: error.message
                    });
                    throw error;
                }
            }

            _get_prediction_with_confidence(instance) {
                const prediction = Math.random() * 2 - 1;
                const confidence = 0.7 + Math.random() * 0.3;
                return [prediction, confidence];
            }

            _get_confidence_level(confidence) {
                const thresholds = this.config.confidence_thresholds;
                
                if (confidence >= thresholds.very_high) return ConfidenceLevel.VERY_HIGH;
                if (confidence >= thresholds.high) return ConfidenceLevel.HIGH;
                if (confidence >= thresholds.medium) return ConfidenceLevel.MEDIUM;
                if (confidence >= thresholds.low) return ConfidenceLevel.LOW;
                return ConfidenceLevel.VERY_LOW;
            }

            _analyze_key_factors(instance, prediction) {
                const key_factors = [];
                const num_features = 8;
                const feature_names = ['قیمت', 'حجم', 'RSI', 'MACD', 'نوسان', 'ارزش بازار', 'P/E', 'تغییرات'];
                
                for (let i = 0; i < num_features; i++) {
                    const feature_name = feature_names[i];
                    const contribution = (Math.random() * 2 - 1) * 0.5;
                    const impact = this._determine_impact(contribution, prediction);
                    
                    key_factors.push([feature_name, contribution, impact]);
                }
                
                key_factors.sort((a, b) => Math.abs(b[1]) - Math.abs(a[1]));
                
                return key_factors.slice(0, 5);
            }

            _determine_impact(contribution, prediction) {
                const thresholds = {
                    'strong_positive': 0.3,
                    'positive': 0.1,
                    'negative': -0.1,
                    'strong_negative': -0.3
                };
                
                let normalized_contrib = contribution;
                
                if (Math.abs(prediction) > 0) {
                    normalized_contrib = contribution / Math.abs(prediction);
                }
                
                if (normalized_contrib >= thresholds.strong_positive) return DecisionImpact.STRONG_POSITIVE;
                if (normalized_contrib >= thresholds.positive) return DecisionImpact.POSITIVE;
                if (normalized_contrib <= thresholds.strong_negative) return DecisionImpact.STRONG_NEGATIVE;
                if (normalized_contrib <= thresholds.negative) return DecisionImpact.NEGATIVE;
                return DecisionImpact.NEUTRAL;
            }

            _generate_counterfactuals(instance, prediction) {
                const counterfactuals = [];
                const key_factors = this._analyze_key_factors(instance, prediction);
                
                for (const [feature_name, contribution, impact] of key_factors.slice(0, 2)) {
                    let action = "optimize";
                    if (impact === DecisionImpact.NEGATIVE || impact === DecisionImpact.STRONG_NEGATIVE) {
                        action = "increase";
                    } else if (impact === DecisionImpact.POSITIVE || impact === DecisionImpact.STRONG_POSITIVE) {
                        action = "maintain";
                    }
                    
                    const counterfactual = this._create_counterfactual(feature_name, contribution, action);
                    if (counterfactual) {
                        counterfactuals.push(counterfactual);
                    }
                }
                
                return counterfactuals.slice(0, this.config.max_counterfactuals);
            }

            _create_counterfactual(feature_name, contribution, action) {
                let suggested_value, expected_impact, description;
                
                if (action === "increase") {
                    suggested_value = 'افزایش ۲۰٪';
                    expected_impact = Math.abs(contribution) * 0.8;
                    description = `افزایش ${feature_name} برای بهبود تاثیر مثبت`;
                } else if (action === "maintain") {
                    suggested_value = 'حفظ سطح فعلی';
                    expected_impact = Math.abs(contribution) * 0.9;
                    description = `حفظ سطح فعلی ${feature_name} برای حفظ مزایا`;
                } else {
                    suggested_value = 'کاهش ۱۰٪';
                    expected_impact = Math.abs(contribution) * 0.5;
                    description = `بهینه‌سازی ${feature_name} برای تعادل بهتر`;
                }
                
                return {
                    feature: feature_name,
                    suggested_value: suggested_value,
                    expected_impact: expected_impact,
                    confidence: Math.min(0.8, Math.abs(contribution)),
                    description: description
                };
            }

            _generate_rationale(prediction, key_factors, counterfactuals) {
                const rationale_parts = [];
                
                rationale_parts.push(`مدل مقدار ${prediction.toFixed(4)} را پیش‌بینی می‌کند.`);
                
                const top_positive = key_factors.filter(f => f[2] === DecisionImpact.POSITIVE || f[2] === DecisionImpact.STRONG_POSITIVE).slice(0, 2);
                const top_negative = key_factors.filter(f => f[2] === DecisionImpact.NEGATIVE || f[2] === DecisionImpact.STRONG_NEGATIVE).slice(0, 2);
                
                if (top_positive.length > 0) {
                    const pos_features = top_positive.map(f => f[0]).join(', ');
                    rationale_parts.push(`عوامل کلیدی مثبت شامل: ${pos_features} می‌شود.`);
                }
                
                if (top_negative.length > 0) {
                    const neg_features = top_negative.map(f => f[0]).join(', ');
                    rationale_parts.push(`عوامل کلیدی منفی شامل: ${neg_features} می‌شود.`);
                }
                
                return rationale_parts.join(' ');
            }
        }

        class MarketSentimentTransformer {
            constructor(config = {}) {
                this.config = {
                    sentiment_thresholds: {
                        'very_bearish': -0.6,
                        'bearish': -0.2,
                        'neutral': 0.2,
                        'bullish': 0.6
                    },
                    ...config
                };
                
                this.financial_lexicon = this._load_financial_lexicon();
            }

            _load_financial_lexicon() {
                return {
                    'bullish': 0.8, 'rally': 0.7, 'surge': 0.8, 'soar': 0.9, 'jump': 0.6,
                    'gain': 0.5, 'profit': 0.4, 'growth': 0.6, 'optimistic': 0.7,
                    'positive': 0.5, 'strong': 0.4, 'outperform': 0.7, 'buy': 0.8,
                    'bearish': -0.8, 'plunge': -0.9, 'slump': -0.7, 'drop': -0.6,
                    'fall': -0.5, 'loss': -0.6, 'decline': -0.5, 'pessimistic': -0.7,
                    'negative': -0.5, 'weak': -0.4, 'underperform': -0.7, 'sell': -0.8
                };
            }

            analyze_sentiment(text) {
                if (!text || text.trim().length === 0) {
                    return this._create_neutral_sentiment();
                }

                const processed_text = this.preprocess_text(text);
                const rule_based_result = this.rule_based_sentiment(processed_text);

                const final_score = rule_based_result.score;
                const confidence = Math.max(0.5, 1 - rule_based_result.subjectivity);
                const sentiment_type = this._score_to_sentiment_type(final_score);

                return {
                    overall_score: final_score,
                    sentiment_type: sentiment_type,
                    confidence: confidence,
                    magnitude: Math.abs(final_score),
                    subjectivity: rule_based_result.subjectivity,
                    timestamp: new Date()
                };
            }

            preprocess_text(text) {
                text = text.replace(/http\S+/g, '');
                text = text.replace(/[^\w\s$%]/g, '');
                text = text.toLowerCase();
                text = text.split(/\s+/).join(' ');
                return text;
            }

            rule_based_sentiment(text) {
                const words = text.split(/\s+/);
                let sentiment_score = 0;
                let word_count = 0;
                let intensity_multiplier = 1.0;

                for (let i = 0; i < words.length; i++) {
                    const word = words[i];
                    if (this.financial_lexicon[word] !== undefined) {
                        if (i > 0 && ['very', 'extremely', 'highly'].includes(words[i-1])) {
                            intensity_multiplier = 1.5;
                        } else if (i > 0 && ['slightly', 'somewhat'].includes(words[i-1])) {
                            intensity_multiplier = 0.7;
                        }

                        sentiment_score += this.financial_lexicon[word] * intensity_multiplier;
                        word_count++;
                        intensity_multiplier = 1.0;
                    }
                }

                if (word_count > 0) {
                    sentiment_score /= word_count;
                }

                const subjectivity = Math.min(1, word_count / 20);

                return {
                    score: sentiment_score,
                    subjectivity: subjectivity,
                    word_count: word_count,
                    method: 'rule_based'
                };
            }

            _score_to_sentiment_type(score) {
                const thresholds = this.config.sentiment_thresholds;
                
                if (score <= thresholds.very_bearish) return 'VERY_BEARISH';
                if (score <= thresholds.bearish) return 'BEARISH';
                if (score >= thresholds.bullish) return 'BULLISH';
                if (score >= 0.8) return 'VERY_BULLISH';
                return 'NEUTRAL';
            }

            _create_neutral_sentiment() {
                return {
                    overall_score: 0.0,
                    sentiment_type: 'NEUTRAL',
                    confidence: 0.5,
                    magnitude: 0.0,
                    subjectivity: 0.5,
                    timestamp: new Date()
                };
            }
        }

        class RiskAssessorAgent {
            constructor(config = {}) {
                this.config = {
                    max_portfolio_var: 0.02,
                    max_drawdown_limit: 0.15,
                    ...config
                };
            }

            assess_risk(positions, market_conditions) {
                const var_95 = this._calculate_var(positions, 0.95);
                const max_drawdown = this._calculate_max_drawdown(positions);
                const volatility = this._calculate_volatility(positions);
                const concentration_risk = this._calculate_concentration_risk(positions);

                const overall_risk = this._determine_overall_risk_level({
                    var_95,
                    max_drawdown,
                    volatility,
                    concentration_risk
                });

                const recommendations = this._generate_risk_recommendations({
                    overall_risk,
                    var_95,
                    max_drawdown,
                    concentration_risk
                });

                return {
                    overall_risk,
                    portfolio_var: var_95,
                    max_drawdown,
                    volatility,
                    concentration_risk,
                    recommendations,
                    warnings: this._generate_risk_warnings({
                        var_95,
                        max_drawdown,
                        concentration_risk
                    })
                };
            }

            _calculate_var(positions, confidence_level) {
                const total_value = positions.reduce((sum, pos) => sum + pos.quantity * pos.current_price, 0);
                return total_value * (1 - confidence_level) * 0.1;
            }

            _calculate_max_drawdown(positions) {
                return Math.random() * 0.2;
            }

            _calculate_volatility(positions) {
                const returns = positions.map(p => (p.current_price - p.entry_price) / p.entry_price);
                const avg_return = returns.reduce((sum, ret) => sum + ret, 0) / returns.length;
                return Math.sqrt(returns.reduce((sum, ret) => sum + Math.pow(ret - avg_return, 2), 0) / returns.length);
            }

            _calculate_concentration_risk(positions) {
                const total_value = positions.reduce((sum, pos) => sum + pos.quantity * pos.current_price, 0);
                const max_position_value = Math.max(...positions.map(p => p.quantity * p.current_price));
                return max_position_value / total_value;
            }

            _determine_overall_risk_level(metrics) {
                const risk_score = (
                    metrics.var_95 / this.config.max_portfolio_var +
                    metrics.max_drawdown / this.config.max_drawdown_limit +
                    metrics.volatility * 10
                ) / 3;

                if (risk_score > 1.5) return 'EXTREME';
                if (risk_score > 1.2) return 'VERY_HIGH';
                if (risk_score > 1.0) return 'HIGH';
                if (risk_score > 0.8) return 'MODERATE';
                if (risk_score > 0.5) return 'LOW';
                return 'VERY_LOW';
            }

            _generate_risk_recommendations(metrics) {
                const recommendations = [];
                
                if (metrics.overall_risk === 'EXTREME' || metrics.overall_risk === 'VERY_HIGH') {
                    recommendations.push('کاهش فوری اندازه پورتفوی');
                    recommendations.push('استفاده از استراتژی‌های پوشش ریسک');
                }
                
                if (metrics.var_95 > this.config.max_portfolio_var) {
                    recommendations.push('تنوع‌بخشی بیشتر پورتفوی');
                }
                
                if (metrics.max_drawdown > this.config.max_drawdown_limit) {
                    recommendations.push('تعیین حد ضرر متحرک برای موقعیت‌ها');
                }
                
                if (metrics.concentration_risk > 0.3) {
                    recommendations.push('کاهش تمرکز روی بزرگترین موقعیت');
                }
                
                return recommendations;
            }

            _generate_risk_warnings(metrics) {
                const warnings = [];
                
                if (metrics.var_95 > this.config.max_portfolio_var) {
                    warnings.push('VaR پورتفوی از حد مجاز فراتر رفته است');
                }
                
                if (metrics.max_drawdown > this.config.max_drawdown_limit) {
                    warnings.push('حداکثر افت سرمایه از حد مجاز بیشتر شده است');
                }
                
                if (metrics.concentration_risk > 0.4) {
                    warnings.push('تمرکز پورتفوی بسیار بالا است');
                }
                
                return warnings;
            }
        }

        class PricePredictionTransformer {
            constructor(config = {}) {
                this.config = {
                    prediction_horizon: 5,
                    ...config
                };
            }

            predict(features) {
                const predictions = [];
                for (let i = 0; i < this.config.prediction_horizon; i++) {
                    predictions.push({
                        predicted_price: features.current_price * (1 + (Math.random() - 0.5) * 0.1),
                        confidence: 0.7 + Math.random() * 0.3,
                        upper_bound: features.current_price * (1 + (Math.random() - 0.3) * 0.15),
                        lower_bound: features.current_price * (1 + (Math.random() - 0.7) * 0.15)
                    });
                }
                return predictions;
            }
        }

        // ===============================
        // کلاس اصلی برنامه
        // ===============================
        class FinancialAnalysisApp {
            constructor() {
                if (FinancialAnalysisApp.instance) {
                    return FinancialAnalysisApp.instance;
                }
                FinancialAnalysisApp.instance = this;

                this.errorHandler = ErrorHandler;
                this.securityManager = new SecurityManager();
                this.apiService = new APIService();
                this.uiManager = new UIManager();
                this.monitoringSystem = new APIMonitoringSystem();
                
                this.marketData = {
                    stocks: [],
                    indices: [],
                    crypto: [],
                    gold: [],
                    currency: [],
                    commodities: []
                };

                 this.aiModels = {
            decisionExplainer: new AdvancedDecisionExplainer(),
            featureImportance: new AdvancedFeatureImportance(),
            sentimentAnalyzer: new MarketSentimentTransformer(),
            riskAssessor: new RiskAssessorAgent(),
            pricePredictor: new PricePredictionTransformer(),
            modelInterpreter: new AdvancedModelInterpreter()
        };

                this.init();
            }

            static getInstance() {
                if (!FinancialAnalysisApp.instance) {
                    FinancialAnalysisApp.instance = new FinancialAnalysisApp();
                }
                return FinancialAnalysisApp.instance;
            }

            init() {
                this.errorHandler.init();
                this.uiManager.init();
                this.setupGlobalEventListeners();
                
                this.loadMarketData();
                this.updateTechnicalIndicators();
                this.updateRiskMetrics();
                
                this.monitoringSystem.startAutoMonitoring();
                
                setTimeout(() => {
                    this.securityManager.testSecurity();
                }, 3000);
            }

            setupGlobalEventListeners() {
                document.getElementById('refreshBtn').addEventListener('click', () => this.loadMarketData());
                document.getElementById('analyzeBtn').addEventListener('click', () => this.performAIAnalysis());
                document.getElementById('riskBtn').addEventListener('click', () => this.performRiskAssessment());
                document.getElementById('tradeBtn').addEventListener('click', () => this.generateTradeSuggestions());
                document.getElementById('monitorBtn').addEventListener('click', () => this.monitoringSystem.checkAllAPIs());
                document.getElementById('securityBtn').addEventListener('click', () => this.testSecurity());
                
                document.getElementById('encryptDataBtn')?.addEventListener('click', () => this.encryptAllData());
                document.getElementById('clearCacheBtn')?.addEventListener('click', () => this.clearCache());
                document.getElementById('testSecurityBtn')?.addEventListener('click', () => this.testSecurity());
            }

            async loadMarketData() {
                try {
                    this.uiManager.showLoading('marketStatus', 'در حال بارگذاری داده‌های بازار...');
                    this.uiManager.showNotification('در حال دریافت آخرین اطلاعات بازار...', 'info');

                    const requests = [
                        this.apiService.makeRequest('stockSymbols'),
                        this.apiService.makeRequest('stockIndex'),
                        this.apiService.makeRequest('crypto'),
                        this.apiService.makeRequest('gold'),
                        this.apiService.makeRequest('currency'),
                        this.apiService.makeRequest('commodityMetals')
                    ];

                    const results = await Promise.allSettled(requests);

                    this.processMarketDataResults(results);

                    this.updateMarketStatus();
                    this.updateCharts();
                    this.updateAdvancedAnalysis();
                    this.updateTechnicalIndicators();
                    this.updateRiskMetrics();

                    this.uiManager.showNotification('اطلاعات بازار با موفقیت بروزرسانی شد', 'success');

                } catch (error) {
                    this.errorHandler.handleGlobalError({
                        error: error,
                        message: 'خطا در بارگذاری داده‌های بازار'
                    });
                }
            }

            processMarketDataResults(results) {
                const processors = {
                    0: (data) => this.marketData.stocks = this.processRealStockData(data),
                    1: (data) => this.marketData.indices = this.processRealIndexData(data),
                    2: (data) => this.marketData.crypto = this.processRealCryptoData(data),
                    3: (data) => this.marketData.gold = this.processRealGoldData(data),
                    4: (data) => this.marketData.currency = this.processRealCurrencyData(data),
                    5: (data) => this.marketData.commodities = this.processRealCommodityData(data)
                };

                results.forEach((result, index) => {
                    if (result.status === 'fulfilled' && result.value) {
                        processors[index](result.value);
                    } else {
                        const endpointKey = Object.keys(this.apiService.endpoints)[index];
                        const fallbackData = this.apiService.getFallbackData(endpointKey);
                        processors[index](fallbackData);
                    }
                });
            }

            processRealStockData(apiData) {
                if (!apiData || !Array.isArray(apiData)) {
                    return this.apiService.generateMockStocks();
                }

                return apiData.slice(0, 10).map(item => ({
                    symbol: item.l18 || 'N/A',
                    name: item.l30 || 'N/A',
                    price: item.pl || item.pc || 0,
                    change: item.plc || item.pcc || 0,
                    changePercent: item.plp || item.pcp || 0,
                    volume: item.tvol || 0,
                    value: item.tval || 0
                }));
            }

            processRealIndexData(apiData) {
                if (!apiData || !Array.isArray(apiData)) {
                    return this.apiService.generateMockIndices();
                }

                return apiData.map(item => ({
                    name: item.name || 'N/A',
                    value: item.index || 0,
                    change: item.index_change || 0,
                    changePercent: item.index_change_percent || 0
                }));
            }

            processRealCryptoData(apiData) {
                if (!apiData || !Array.isArray(apiData)) {
                    return this.apiService.generateMockCrypto();
                }

                return apiData.slice(0, 5).map(item => ({
                    name: item.name || 'N/A',
                    price: item.price || 0,
                    changePercent: item.change_percent || 0,
                    marketCap: item.market_cap || 0
                }));
            }

            processRealGoldData(apiData) {
                if (!apiData || !Array.isArray(apiData)) {
                    return this.apiService.generateMockGold();
                }

                return apiData.map(item => ({
                    symbol: item.symbol || 'N/A',
                    name: item.name || 'N/A',
                    price: item.price || 0,
                    change: item.change_value || 0,
                    changePercent: item.change_percent || 0
                }));
            }

            processRealCurrencyData(apiData) {
                if (!apiData || !Array.isArray(apiData)) {
                    return this.apiService.generateMockCurrency();
                }

                return apiData.map(item => ({
                    symbol: item.symbol || 'N/A',
                    name: item.name || 'N/A',
                    price: item.price || 0,
                    change: item.change_value || 0,
                    changePercent: item.change_percent || 0
                }));
            }

            processRealCommodityData(apiData) {
                if (!apiData || !Array.isArray(apiData)) {
                    return this.apiService.generateMockCommodities();
                }

                return apiData.map(item => ({
                    symbol: item.symbol || 'N/A',
                    name: item.name || 'N/A',
                    price: item.price || 0,
                    change: item.change_value || 0,
                    changePercent: item.change_percent || 0
                }));
            }

            updateMarketStatus() {
                const container = document.getElementById('marketStatus');
                const marketType = document.getElementById('marketType').value;
                
                let items = [];
                
                if (marketType === 'all' || marketType === 'stock') {
                    items = items.concat(
                        this.marketData.stocks.slice(0, 6).map(stock => this.createMarketItem(stock, 'stock'))
                    );
                }
                
                if (marketType === 'all' || marketType === 'crypto') {
                    items = items.concat(
                        this.marketData.crypto.slice(0, 6).map(crypto => this.createMarketItem(crypto, 'crypto'))
                    );
                }
                
                if (marketType === 'all' || marketType === 'gold') {
                    items = items.concat(
                        this.marketData.gold.slice(0, 6).map(gold => this.createMarketItem(gold, 'gold'))
                    );
                }
                
                if (marketType === 'all' || marketType === 'currency') {
                    items = items.concat(
                        this.marketData.currency.slice(0, 6).map(currency => this.createMarketItem(currency, 'currency'))
                    );
                }
                
                if (marketType === 'all' || marketType === 'commodity') {
                    items = items.concat(
                        this.marketData.commodities.slice(0, 6).map(commodity => this.createMarketItem(commodity, 'commodity'))
                    );
                }
                
                container.innerHTML = items.join('');
            }

            createMarketItem(item, type) {
                const changeClass = item.changePercent >= 0 ? 'positive' : 'negative';
                const changeSign = item.changePercent >= 0 ? '+' : '';
                const formattedPrice = this.formatNumber(item.price);
                const formattedChange = item.changePercent.toFixed(2);
                
                let typeLabel = '';
                let priceSuffix = '';
                
                switch(type) {
                    case 'stock': 
                        typeLabel = 'بورس'; 
                        priceSuffix = ' تومان';
                        break;
                    case 'crypto': 
                        typeLabel = 'ارز دیجیتال'; 
                        priceSuffix = ' دلار';
                        break;
                    case 'gold': 
                        typeLabel = 'طلا'; 
                        priceSuffix = ' تومان';
                        break;
                    case 'currency': 
                        typeLabel = 'ارز'; 
                        priceSuffix = ' تومان';
                        break;
                    case 'commodity': 
                        typeLabel = 'کامودیتی'; 
                        priceSuffix = ' دلار';
                        break;
                }
                
                return `
                    <div class="market-item" onclick="this.showAssetDetail('${item.symbol}', '${type}')">
                        <div class="market-name">${item.name} <small>(${typeLabel})</small></div>
                        <div class="market-price">${formattedPrice}${priceSuffix}</div>
                        <div class="market-change ${changeClass}">
                            ${changeSign}${formattedChange}%
                        </div>
                    </div>
                `;
            }

            formatNumber(num) {
                return new Intl.NumberFormat('fa-IR').format(Math.round(num));
            }

            updateCharts() {
                this.updateIndicesChart();
                this.updatePriceChart();
                this.updateConnectionChart();
            }

            updateIndicesChart() {
                const indices = this.marketData.indices;
                
                const trace = {
                    x: indices.map(index => index.name),
                    y: indices.map(index => index.value),
                    type: 'bar',
                    marker: {
                        color: indices.map(index => index.changePercent >= 0 ? '#28a745' : '#dc3545')
                    },
                    text: indices.map(index => `${this.formatNumber(index.value)} (${index.changePercent >= 0 ? '+' : ''}${index.changePercent.toFixed(2)}%)`),
                    textposition: 'auto'
                };
                
                const layout = {
                    title: 'شاخص‌های بازار سرمایه',
                    xaxis: { title: 'شاخص' },
                    yaxis: { title: 'مقدار' },
                    font: { family: 'Tahoma' },
                    showlegend: false
                };
                
                Plotly.newPlot('indicesChart', [trace], layout, { responsive: true });
            }

            updatePriceChart() {
                const timePeriods = ['1D', '1W', '1M', '3M', '1Y'];
                
                const generatePriceSeries = (base, volatility) => {
                    let price = base;
                    return timePeriods.map(() => {
                        price = price * (1 + (Math.random() * volatility * 2 - volatility));
                        return Math.round(price);
                    });
                };
                
                const stockPrices = generatePriceSeries(45000, 0.05);
                const cryptoPrices = generatePriceSeries(85000, 0.08);
                const goldPrices = generatePriceSeries(95000000, 0.03);
                
                const trace1 = {
                    x: timePeriods,
                    y: stockPrices,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'بورس',
                    line: { color: '#1e3c72', width: 3 }
                };
                
                const trace2 = {
                    x: timePeriods,
                    y: cryptoPrices,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'ارز دیجیتال',
                    line: { color: '#ff6b6b', width: 3 }
                };
                
                const trace3 = {
                    x: timePeriods,
                    y: goldPrices.map(p => p / 1000),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'طلا (هزار تومان)',
                    line: { color: '#ffd700', width: 3 }
                };
                
                const layout = {
                    title: 'روند قیمت در بازارهای مختلف',
                    xaxis: { title: 'بازه زمانی' },
                    yaxis: { title: 'قیمت' },
                    font: { family: 'Tahoma' },
                    showlegend: true
                };
                
                Plotly.newPlot('priceChart', [trace1, trace2, trace3], layout, { responsive: true });
            }

            updateConnectionChart() {
                const statusData = Object.values(this.monitoringSystem.apiStatus);
                const connected = statusData.filter(api => api.status === 'connected').length;
                const disconnected = statusData.filter(api => api.status === 'disconnected').length;
                const inactive = statusData.filter(api => !api.shouldBeActive).length;
                
                const trace = {
                    x: ['متصل', 'قطع', 'غیرفعال'],
                    y: [connected, disconnected, inactive],
                    type: 'bar',
                    marker: {
                        color: ['#28a745', '#dc3545', '#ffc107']
                    }
                };
                
                const layout = {
                    title: 'وضعیت اتصال APIها',
                    xaxis: { title: 'وضعیت' },
                    yaxis: { title: 'تعداد' },
                    font: { family: 'Tahoma' }
                };
                
                Plotly.newPlot('connectionChart', [trace], layout, { responsive: true });
            }

            updateTechnicalIndicators() {
                const container = document.getElementById('technicalIndicators');
                const indicators = [
                    { name: 'RSI', value: (30 + Math.random() * 40).toFixed(1) },
                    { name: 'MACD', value: (Math.random() - 0.5).toFixed(3) },
                    { name: 'شاخص قدرت', value: (Math.random() * 100).toFixed(1) },
                    { name: 'نوسان', value: (Math.random() * 20).toFixed(1) + '%' }
                ];
                
                const indicatorsHTML = indicators.map(indicator => `
                    <div class="indicator">
                        <div class="indicator-value">${indicator.value}</div>
                        <div class="indicator-name">${indicator.name}</div>
                    </div>
                `).join('');
                
                container.innerHTML = indicatorsHTML;
            }

            updateRiskMetrics() {
                const container = document.getElementById('riskMetrics');
                const metrics = [
                    { name: 'VaR 95%', value: (Math.random() * 5).toFixed(2) + '%', level: 'medium' },
                    { name: 'حداکثر افت', value: (Math.random() * 15).toFixed(2) + '%', level: 'high' },
                    { name: 'نسبت شارپ', value: (0.5 + Math.random() * 2).toFixed(2), level: 'low' },
                    { name: 'بتا', value: (0.8 + Math.random() * 0.8).toFixed(2), level: 'medium' }
                ];
                
                const metricsHTML = metrics.map(metric => {
                    const levelClass = `metric-${metric.level}`;
                    return `
                        <div class="metric">
                            <div class="metric-value ${levelClass}">${metric.value}</div>
                            <div class="indicator-name">${metric.name}</div>
                        </div>
                    `;
                }).join('');
                
                container.innerHTML = metricsHTML;
            }

            async performAIAnalysis() {
                return this.errorHandler.apiCallWithRetry(async () => {
                    this.uiManager.showLoading('aiAnalysis', 'در حال تحلیل داده‌ها با هوش مصنوعی...');
                    
                    await this.errorHandler.delay(2000);
                    
                    const analysisResults = [
                        {
                            title: 'پیش‌بینی روند بورس',
                            content: 'شاخص کل در آستانه شکست مقاومت ۲.۸ میلیونی قرار دارد. حجم معاملات رو به افزایش است.',
                            confidence: 85,
                            type: 'opportunity',
                            recommendation: 'افزایش وزن سهام در پرتفوی'
                        },
                        {
                            title: 'تحلیل ارزهای دیجیتال',
                            content: 'بیت‌کوین در کانال صعودی قرار گرفته و احتمال رشد تا ۹۰,۰۰۰ دلار وجود دارد.',
                            confidence: 78,
                            type: 'opportunity',
                            recommendation: 'ورود پلکانی با رعایت حد ضرر'
                        },
                        {
                            title: 'هشدار ریسک طلا',
                            content: 'قیمت طلا به محدوده اشباع خرید رسیده است. شاخص RSI در محدوده ۷۵ قرار دارد.',
                            confidence: 65,
                            type: 'risk',
                            recommendation: 'کاهش موقیت و انتظار برای اصلاح'
                        }
                    ];
                    
                    this.displayAIAnalysis(analysisResults);
                    this.uiManager.showNotification('تحلیل هوش مصنوعی با موفقیت انجام شد', 'success');
                    
                    return analysisResults;
                }, 2, 'AI Analysis');
            }

            displayAIAnalysis(results) {
                const container = document.getElementById('aiAnalysis');
                
                const analysisHTML = results.map(item => `
                    <div class="analysis-item ${item.type === 'risk' ? 'risk-item' : 'opportunity-item'}">
                        <h3>${item.title}</h3>
                        <p>${item.content}</p>
                        <div class="confidence">
                            <strong>اعتماد تحلیل:</strong> ${item.confidence}%
                        </div>
                        <div class="recommendation">
                            <strong>توصیه:</strong> ${item.recommendation}
                        </div>
                    </div>
                `).join('');
                
                container.innerHTML = analysisHTML;
            }

            updateAdvancedAnalysis() {
                const container = document.getElementById('advancedAnalysis');
                
                const analysisResults = [
                    {
                        title: 'تحلیل رگرسیون چندمتغیره',
                        content: 'مدل رگرسیون نشان می‌دهد شاخص کل تحت تأثیر نرخ ارز و قیمت نفت قرار دارد. ضریب تعیین: ۰.۸۷',
                        type: 'opportunity'
                    },
                    {
                        title: 'تحلیل سری زمانی',
                        content: 'الگوی فصلی قوی در نمادهای پتروشیمی شناسایی شد. اوج خرید در سه ماهه دوم سال مشاهده می‌شود.',
                        type: 'opportunity'
                    },
                    {
                        title: 'تحلیل خوشه‌ای',
                        content: 'نمادها در ۵ خوشه مجزا دسته‌بندی شدند. خوشه فناوری اطلاعات بیشترین پتانسیل رشد را دارد.',
                        type: 'opportunity'
                    }
                ];
                
                const analysisHTML = analysisResults.map(item => `
                    <div class="analysis-item ${item.type === 'risk' ? 'risk-item' : 'opportunity-item'}">
                        <h3>${item.title}</h3>
                        <p>${item.content}</p>
                    </div>
                `).join('');
                
                container.innerHTML = analysisHTML;
            }

            async performRiskAssessment() {
                this.uiManager.showNotification('در حال محاسبه ریسک پرتفوی...', 'info');
                
                setTimeout(() => {
                    const mockPositions = [
                        { symbol: 'شتران', quantity: 1000, entry_price: 42000, current_price: 45000 },
                        { symbol: 'بیت‌کوین', quantity: 0.5, entry_price: 80000, current_price: 85000 }
                    ];
                    
                    const marketConditions = { volatility: 0.15, trend: 'upward' };
                    const riskAssessment = this.aiModels.riskAssessor.assess_risk(mockPositions, marketConditions);
                    
                    this.displayRiskAssessment(riskAssessment);
                    this.uiManager.showNotification('ارزیابی ریسک با موفقیت انجام شد', 'success');
                }, 2000);
            }

            displayRiskAssessment(riskAssessment) {
                const container = document.getElementById('aiAnalysis');
                
                const riskHTML = `
                    <div class="analysis-item risk-item">
                        <h3>ریسک کلی: ${riskAssessment.overall_risk}</h3>
                        <p><strong>VaR پورتفوی:</strong> ${(riskAssessment.portfolio_var * 100).toFixed(2)}%</p>
                        <p><strong>حداکثر افت:</strong> ${(riskAssessment.max_drawdown * 100).toFixed(2)}%</p>
                        <p><strong>ریسک تمرکز:</strong> ${(riskAssessment.concentration_risk * 100).toFixed(2)}%</p>
                    </div>
                    <div class="analysis-item">
                        <h3>توصیه‌ها</h3>
                        <ul>
                            ${riskAssessment.recommendations.map(rec => `<li>${rec}</li>`).join('')}
                        </ul>
                    </div>
                    <div class="analysis-item risk-item">
                        <h3>هشدارها</h3>
                        <ul>
                            ${riskAssessment.warnings.map(warning => `<li>${warning}</li>`).join('')}
                        </ul>
                    </div>
                `;
                
                container.innerHTML = riskHTML;
            }

            loadXAIExplanations() {
                const container = document.getElementById('xaiExplanations');
                this.uiManager.showLoading('xaiExplanations', 'در حال تولید توضیحات هوش مصنوعی...');
                
                setTimeout(() => {
                    const mockFeatures = [0.5, -0.2, 0.8, -0.1, 0.3];
                    const featureNames = ['قیمت', 'حجم', 'RSI', 'MACD', 'نوسان'];
                    
                    const explanation = this.aiModels.decisionExplainer.explain_decision(
                        this.aiModels.pricePredictor,
                        mockFeatures,
                        featureNames
                    );
                    
                    const explanationsHTML = `
                        <div class="analysis-item">
                            <h3>توضیح تصمیم پیش‌بینی</h3>
                            <p><strong>پیش‌بینی:</strong> ${explanation.prediction.toFixed(4)}</p>
                            <p><strong>اطمینان:</strong> ${(explanation.confidence * 100).toFixed(1)}% (${explanation.confidence_level})</p>
                            <p><strong>منطق:</strong> ${explanation.rationale}</p>
                        </div>
                        <div class="analysis-item">
                            <h3>عوامل کلیدی تاثیرگذار</h3>
                            <ul>
                                ${explanation.key_factors.slice(0, 5).map(factor => `
                                    <li>${factor[0]}: ${(factor[1] * 100).toFixed(2)}% (${factor[2]})</li>
                                `).join('')}
                            </ul>
                        </div>
                        <div class="analysis-item">
                            <h3>پیشنهادات متغیر</h3>
                            <ul>
                                ${explanation.counterfactuals.map(cf => `
                                    <li>${cf.description} (تاثیر مورد انتظار: ${(cf.expected_impact * 100).toFixed(2)}%)</li>
                                `).join('')}
                            </ul>
                        </div>
                    `;
                    
                    container.innerHTML = explanationsHTML;
                    
                    this.updateSHAPChart();
                    this.updateLIMEChart();
                    this.updateCounterfactualChart();
                    
                }, 2000);
            }

            updateSHAPChart() {
                const features = ['قیمت', 'حجم', 'RSI', 'MACD', 'نوسان', 'ارزش بازار', 'P/E', 'تغییرات'];
                const shapValues = features.map(() => (Math.random() - 0.5) * 0.3);
                
                const trace = {
                    x: shapValues,
                    y: features,
                    type: 'bar',
                    orientation: 'h',
                    marker: {
                        color: shapValues.map(val => val > 0 ? '#28a745' : '#dc3545')
                    }
                };
                
                const layout = {
                    title: 'تحلیل SHAP - تاثیر ویژگی‌ها بر پیش‌بینی',
                    xaxis: { title: 'مقدار SHAP' },
                    yaxis: { title: 'ویژگی' },
                    font: { family: 'Tahoma' }
                };
                
                Plotly.newPlot('shapChart', [trace], layout, { responsive: true });
            }

            updateLIMEChart() {
                const features = ['قیمت', 'حجم', 'RSI', 'MACD', 'نوسان'];
                const limeWeights = features.map(() => (Math.random() - 0.5) * 0.4);
                
                const trace = {
                    x: limeWeights,
                    y: features,
                    type: 'bar',
                    orientation: 'h',
                    marker: {
                        color: limeWeights.map(val => val > 0 ? '#28a745' : '#dc3545')
                    }
                };
                
                const layout = {
                    title: 'تحلیل LIME - وزن‌های محلی',
                    xaxis: { title: 'وزن LIME' },
                    yaxis: { title: 'ویژگی' },
                    font: { family: 'Tahoma' }
                };
                
                Plotly.newPlot('limeChart', [trace], layout, { responsive: true });
            }

            updateCounterfactualChart() {
                const scenarios = ['سناریو فعلی', 'افزایش قیمت ۱۰٪', 'کاهش نوسان', 'افزایش حجم'];
                const predictions = [0.5, 0.65, 0.45, 0.7];
                
                const trace = {
                    x: scenarios,
                    y: predictions,
                    type: 'bar',
                    marker: {
                        color: predictions.map(pred => pred > 0.6 ? '#28a745' : pred > 0.4 ? '#ffc107' : '#dc3545')
                    }
                };
                
                const layout = {
                    title: 'تحلیل سناریوهای متغیر',
                    xaxis: { title: 'سناریو' },
                    yaxis: { title: 'پیش‌بینی' },
                    font: { family: 'Tahoma' }
                };
                
                Plotly.newPlot('counterfactualChart', [trace], layout, { responsive: true });
            }

            loadTransformerPredictions() {
                const container = document.getElementById('transformerPredictionsChart');
                
                const timePeriods = ['حال', '۱ روز', '۳ روز', '۱ هفته', '۲ هفته'];
                const predictions = [0.5, 0.55, 0.52, 0.58, 0.62];
                const confidence = [1.0, 0.8, 0.7, 0.6, 0.5];
                
                const trace1 = {
                    x: timePeriods,
                    y: predictions,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'پیش‌بینی',
                    line: { color: '#1e3c72', width: 3 }
                };
                
                const trace2 = {
                    x: timePeriods,
                    y: predictions.map((pred, i) => pred + (1 - confidence[i]) * 0.1),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'حد بالا',
                    line: { color: '#28a745', width: 1, dash: 'dash' },
                    fillcolor: 'rgba(40, 167, 69, 0.2)',
                    fill: 'tonexty'
                };
                
                const trace3 = {
                    x: timePeriods,
                    y: predictions.map((pred, i) => pred - (1 - confidence[i]) * 0.1),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'حد پایین',
                    line: { color: '#dc3545', width: 1, dash: 'dash' },
                    fill: 'tonexty'
                };
                
                const layout = {
                    title: 'پیش‌بینی‌های Transformer با محدوده اطمینان',
                    xaxis: { title: 'افق زمانی' },
                    yaxis: { title: 'پیش‌بینی' },
                    font: { family: 'Tahoma' },
                    showlegend: true
                };
                
                Plotly.newPlot('transformerPredictionsChart', [trace1, trace2, trace3], layout, { responsive: true });
            }

            generateTradeSuggestions() {
                this.uiManager.showNotification('در حال تولید پیشنهادات معاملاتی...', 'info');
                
                setTimeout(() => {
                    const suggestions = [
                        {
                            symbol: 'شتران',
                            action: 'خرید',
                            price: '۴۵,۰۰۰ تومان',
                            target: '۵۲,۰۰۰ تومان',
                            stoploss: '۴۲,۰۰۰ تومان',
                            confidence: 78
                        },
                        {
                            symbol: 'بیت‌کوین',
                            action: 'خرید',
                            price: '۸۵,۰۰۰ دلار',
                            target: '۹۵,۰۰۰ دلار',
                            stoploss: '۷۸,۰۰۰ دلار',
                            confidence: 82
                        },
                        {
                            symbol: 'سکه امامی',
                            action: 'فروش',
                            price: '۹۷,۰۰۰,۰۰۰ تومان',
                            target: '۹۲,۰۰۰,۰۰۰ تومان',
                            stoploss: '۱۰۰,۰۰۰,۰۰۰ تومان',
                            confidence: 65
                        }
                    ];
                    
                    let message = 'پیشنهادات معاملاتی:\n\n';
                    suggestions.forEach(suggestion => {
                        message += `📈 ${suggestion.symbol}: ${suggestion.action} در ${suggestion.price}\n`;
                        message += `🎯 هدف: ${suggestion.target} | ⚠️ حد ضرر: ${suggestion.stoploss}\n`;
                        message += `🔍 اطمینان: ${suggestion.confidence}%\n\n`;
                    });
                    
                    alert(message);
                }, 1500);
            }

            async encryptAllData() {
                try {
                    this.uiManager.showNotification('در حال رمزنگاری داده‌ها...', 'info');
                    
                    const encryptedData = this.securityManager.encryptData(JSON.stringify(this.marketData));
                    
                    this.securityManager.logSecurityEvent('DATA_ENCRYPTED', 'All market data encrypted');
                    this.uiManager.showNotification('تمام داده‌ها با موفقیت رمزنگاری شدند', 'success');
                    
                    return encryptedData;
                } catch (error) {
                    this.errorHandler.notifyUser('خطا در رمزنگاری داده‌ها', 'error');
                }
            }

            async clearCache() {
                this.apiService.clearCache();
                this.uiManager.showNotification('کش سیستم با موفقیت پاک شد', 'success');
            }

            async testSecurity() {
                const result = await this.securityManager.testSecurity();
                if (result) {
                    this.uiManager.showNotification('تمام تست‌های امنیتی با موفقیت گذرانده شدند', 'success');
                } else {
                    this.uiManager.showNotification('برخی تست‌های امنیتی ناموفق بودند', 'warning');
                }
            }

            updateSecurityTab() {
                this.updateAPIMonitoringStatus();
            }

            updateAPIMonitoringStatus() {
                const container = document.getElementById('apiMonitoringStatus');
                if (!container) return;

                const statusData = Object.values(this.monitoringSystem.apiStatus);
                const statusHTML = statusData.map(apiInfo => {
                    const status = apiInfo.status === 'connected' ? 'connected' : 'disconnected';
                    const statusText = status === 'connected' ? '✅ متصل' : '❌ قطع';
                    
                    return `
                        <div class="api-status ${status}" style="margin-bottom: 10px;">
                            <div>
                                <strong>${apiInfo.name}</strong>
                                <br>
                                <small>${statusText} - موفقیت: ${apiInfo.successRate.toFixed(1)}%</small>
                            </div>
                            <span class="status-indicator status-${status}"></span>
                        </div>
                    `;
                }).join('');

                container.innerHTML = statusHTML;
            }

            showAssetDetail(symbol, type) {
                alert(`جزییات ${symbol} (${type}) در حال بارگذاری...\n\nاین قابلیت در نسخه کامل سیستم فعال خواهد شد.`);
            }
async performAdvancedFeatureAnalysis() {
        try {
            this.uiManager.showLoading('featureImportanceAnalysis', 
                'در حال محاسبه تحلیل اهمیت ویژگی‌های پیشرفته...');

            // داده‌های نمونه برای تحلیل
            const sampleFeatures = this.generateSampleFeatures();
            const featureNames = ['قیمت', 'حجم', 'RSI', 'MACD', 'نوسان', 'ارزش بازار', 'P/E', 'تغییرات'];
            
            const analysis = this.aiModels.featureImportance.comprehensive_importance_analysis(
                this.aiModels.pricePredictor,
                sampleFeatures,
                Array.from({length: sampleFeatures.length}, () => Math.random() - 0.5),
                featureNames
            );

            this.displayFeatureImportanceAnalysis(analysis);
            this.updateGlobalFeatureImportanceChart(analysis.global_importance);
            this.updateFeatureInteractionChart(analysis.interaction_network);
            
            this.uiManager.showNotification('تحلیل اهمیت ویژگی‌ها با موفقیت انجام شد', 'success');
            
        } catch (error) {
            this.errorHandler.notifyUser('خطا در تحلیل اهمیت ویژگی‌ها', 'error');
        }
    }

    generateSampleFeatures() {
        return Array.from({length: 100}, () => 
            Array.from({length: 8}, () => Math.random() * 100)
        );
    }

    displayFeatureImportanceAnalysis(analysis) {
        const container = document.getElementById('featureImportanceAnalysis');
        
        const globalHTML = `
            <div class="analysis-item">
                <h3>اهمیت سراسری ویژگی‌ها</h3>
                <div style="max-height: 300px; overflow-y: auto;">
                    ${analysis.global_importance.map(feature => `
                        <div style="padding: 8px; border-bottom: 1px solid #eee;">
                            <strong>${feature.feature_name}</strong>: 
                            ${(feature.importance_score * 100).toFixed(2)}% 
                            <small>(${feature.significance}, ${feature.direction})</small>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;

        const stabilityHTML = `
            <div class="analysis-item">
                <h3>تحلیل پایداری</h3>
                <div style="max-height: 200px; overflow-y: auto;">
                    ${Object.entries(analysis.stability_analysis).slice(0, 5).map(([feature, stability]) => `
                        <div style="padding: 5px;">
                            ${feature}: ${(stability * 100).toFixed(1)}%
                        </div>
                    `).join('')}
                </div>
            </div>
        `;

        const interactionsHTML = `
            <div class="analysis-item">
                <h3>تعامل‌های مهم</h3>
                <div style="max-height: 200px; overflow-y: auto;">
                    ${Object.entries(analysis.interaction_network).slice(0, 5).map(([pair, strength]) => `
                        <div style="padding: 5px;">
                            ${pair.replace(',', ' & ')}: ${(strength * 100).toFixed(1)}%
                        </div>
                    `).join('')}
                </div>
            </div>
        `;

        container.innerHTML = globalHTML + stabilityHTML + interactionsHTML;
    }

    updateGlobalFeatureImportanceChart(global_importance) {
        const features = global_importance.map(f => f.feature_name);
        const importance_scores = global_importance.map(f => f.importance_score * 100);
        const colors = global_importance.map(f => 
            f.direction === 'positive' ? '#28a745' : 
            f.direction === 'negative' ? '#dc3545' : '#6c757d'
        );

        const trace = {
            x: importance_scores,
            y: features,
            type: 'bar',
            orientation: 'h',
            marker: { color: colors }
        };

        const layout = {
            title: 'اهمیت سراسری ویژگی‌ها',
            xaxis: { title: 'اهمیت (%)' },
            yaxis: { title: 'ویژگی' },
            font: { family: 'Tahoma' }
        };

        Plotly.newPlot('globalFeatureImportanceChart', [trace], layout, { responsive: true });
    }

    updateFeatureInteractionChart(interaction_network) {
        const interactions = Object.entries(interaction_network).slice(0, 10);
        const features = [...new Set(interactions.flatMap(([pair]) => pair.split(',')))];
        
        const matrix = Array(features.length).fill().map(() => 
            Array(features.length).fill(0)
        );

        interactions.forEach(([pair, strength]) => {
            const [f1, f2] = pair.split(',');
            const i1 = features.indexOf(f1);
            const i2 = features.indexOf(f2);
            if (i1 !== -1 && i2 !== -1) {
                matrix[i1][i2] = strength;
                matrix[i2][i1] = strength;
            }
        });

        const trace = {
            z: matrix,
            x: features,
            y: features,
            type: 'heatmap',
            colorscale: 'Viridis'
        };

        const layout = {
            title: 'ماتریس تعامل ویژگی‌ها',
            font: { family: 'Tahoma' }
        };

        Plotly.newPlot('featureInteractionChart', [trace], layout, { responsive: true });
    }

                    
        }

        // ===============================
        // مقداردهی اولیه برنامه
        // ===============================
        document.addEventListener('DOMContentLoaded', function() {
            window.FinancialAnalysisApp = FinancialAnalysisApp.getInstance();
            window.ErrorHandler = ErrorHandler;
            window.SecurityManager = window.FinancialAnalysisApp.securityManager;
            window.UIManager = window.FinancialAnalysisApp.uiManager;
        });

                    class RealTimeDataService {
    constructor() {
        this.socket = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
    }

    connect() {
        try {
            this.socket = new WebSocket('wss://realtime-api.example.com');
            
            this.socket.onopen = () => {
                console.log('WebSocket connected');
                this.reconnectAttempts = 0;
            };

            this.socket.onmessage = (event) => {
                this.handleRealTimeData(JSON.parse(event.data));
            };

            this.socket.onclose = () => {
                this.handleReconnection();
            };

        } catch (error) {
            console.error('WebSocket connection failed:', error);
        }
    }

    handleRealTimeData(data) {
        // پردازش داده‌های لحظه‌ای
        window.FinancialAnalysisApp.updateRealTimeData(data);
    }

    handleReconnection() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            setTimeout(() => this.connect(), Math.pow(2, this.reconnectAttempts) * 1000);
        }
    }
}

            // فایل service-worker.js
self.addEventListener('install', (event) => {
    event.waitUntil(
        caches.open('financial-app-v1').then((cache) => {
            return cache.addAll([
                '/',
                '/index.html',
                '/ai_models.js',
                // ... سایر فایل‌ها
            ]);
        })
    );
});

self.addEventListener('fetch', (event) => {
    event.respondWith(
        caches.match(event.request).then((response) => {
            return response || fetch(event.request);
        })
    );
});
                    
    </script>
</body>
</html>
