<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø³ÛŒØ³ØªÙ… Ø¬Ø§Ù…Ø¹ ØªØ­Ù„ÛŒÙ„ Ùˆ Ù…Ø¹Ø§Ù…Ù„Ù‡â€ŒÚ¯Ø±ÛŒ Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ Ø§ÛŒØ±Ø§Ù†</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.0/axios.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        :root {
            --primary: #1e3c72;
            --secondary: #2a5298;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --info: #17a2b8;
            --light: #f8f9fa;
            --dark: #343a40;
            --sidebar-width: 280px;
        }
        
        body {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
        }
        
        .sidebar {
            width: var(--sidebar-width);
            background: rgba(255, 255, 255, 0.95);
            height: 100vh;
            position: fixed;
            right: 0;
            top: 0;
            padding: 20px;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            z-index: 1000;
        }
        
        .main-content {
            flex: 1;
            margin-right: var(--sidebar-width);
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
        }
        
        h1 {
            color: var(--primary);
            margin-bottom: 10px;
            font-size: 2.5rem;
            font-weight: 700;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.2rem;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 25px;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }
        
        .card h2 {
            color: var(--primary);
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
            font-size: 1.6rem;
            font-weight: 600;
        }
        
        .market-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .market-item {
            background: var(--light);
            border-radius: 12px;
            padding: 18px;
            border-left: 5px solid var(--primary);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .market-item:hover {
            background: #e9ecef;
            transform: translateX(8px);
        }
        
        .market-name {
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        
        .market-price {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 8px;
            color: var(--dark);
        }
        
        .market-change {
            font-size: 0.95rem;
            padding: 5px 12px;
            border-radius: 8px;
            display: inline-block;
            font-weight: 600;
        }
        
        .positive {
            background: #d4edda;
            color: #155724;
        }
        
        .negative {
            background: #f8d7da;
            color: #721c24;
        }
        
        .chart-container {
            height: 400px;
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        
        .control-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        select, button, input {
            padding: 12px 18px;
            border-radius: 10px;
            border: 1px solid #ddd;
            background: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:focus, button:focus, input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(30, 60, 114, 0.2);
        }
        
        button {
            background: var(--primary);
            color: white;
            border: none;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        button:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .analysis-section {
            margin-top: 25px;
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .analysis-item {
            background: var(--light);
            border-radius: 12px;
            padding: 20px;
            border-left: 5px solid var(--success);
            transition: all 0.3s ease;
        }
        
        .risk-item {
            border-left-color: var(--danger);
        }
        
        .opportunity-item {
            border-left-color: var(--success);
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 1.1rem;
        }
        
        .tab-container {
            margin-bottom: 20px;
        }
        
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tab {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px 10px 0 0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .tab.active {
            background: white;
            color: var(--primary);
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 8px;
        }
        
        .status-active {
            background: var(--success);
        }
        
        .status-inactive {
            background: var(--danger);
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .feature-item {
            background: var(--light);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .feature-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .feature-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            color: var(--primary);
        }
        
        .sidebar-section {
            margin-bottom: 30px;
        }
        
        .sidebar-section h3 {
            color: var(--primary);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .model-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: var(--light);
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .model-status.active {
            border-right: 4px solid var(--success);
        }
        
        .model-status.inactive {
            border-right: 4px solid var(--danger);
        }
        
        .notification {
            position: fixed;
            top: 20px;
            left: 20px;
            right: calc(var(--sidebar-width) + 20px);
            background: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slideIn 0.5s ease;
        }
        
        @keyframes slideIn {
            from { transform: translateY(-100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .close-notification {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: #666;
            padding: 5px;
        }
        
        .technical-indicators {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .indicator {
            background: var(--light);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .indicator-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--primary);
        }
        
        .indicator-name {
            font-size: 0.9rem;
            color: #666;
        }
        
        @media (max-width: 1200px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                width: 250px;
            }
            
            .main-content {
                margin-right: 250px;
            }
        }
        
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(100%);
                transition: transform 0.3s ease;
            }
            
            .sidebar.active {
                transform: translateX(0);
            }
            
            .main-content {
                margin-right: 0;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .control-group {
                width: 100%;
                justify-content: center;
            }
            
            select, button {
                flex: 1;
                min-width: 150px;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
        
        .menu-toggle {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
        }
        
        @media (max-width: 768px) {
            .menu-toggle {
                display: block;
            }
        }
        
        .risk-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric {
            background: var(--light);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.4rem;
            font-weight: bold;
        }
        
        .metric-high {
            color: var(--danger);
        }
        
        .metric-medium {
            color: var(--warning);
        }
        
        .metric-low {
            color: var(--success);
        }
    </style>
</head>
<body>
    <button class="menu-toggle" onclick="toggleSidebar()">â˜°</button>
    
    <div class="sidebar" id="sidebar">
        <div class="sidebar-section">
            <h3>ÙˆØ¶Ø¹ÛŒØª Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</h3>
            <div class="model-status active">
                <span>AdvancedDecisionExplainer</span>
                <span class="status-indicator status-active"></span>
            </div>
            <div class="model-status active">
                <span>MarketSentimentTransformer</span>
                <span class="status-indicator status-active"></span>
            </div>
            <div class="model-status active">
                <span>PricePredictionTransformer</span>
                <span class="status-indicator status-active"></span>
            </div>
            <div class="model-status active">
                <span>RiskAssessorAgent</span>
                <span class="status-indicator status-active"></span>
            </div>
        </div>
        
        <div class="sidebar-section">
            <h3>Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ ÙÙ†ÛŒ</h3>
            <div class="technical-indicators" id="technicalIndicators">
                <!-- Will be populated by JavaScript -->
            </div>
        </div>
        
        <div class="sidebar-section">
            <h3>Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§ÛŒ Ø±ÛŒØ³Ú©</h3>
            <div class="risk-metrics" id="riskMetrics">
                <!-- Will be populated by JavaScript -->
            </div>
        </div>
        
        <div class="sidebar-section">
            <h3>Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ÛŒ ÙØ¹Ø§Ù„</h3>
            <div class="model-status active">
                <span>SHAP Explanation</span>
                <span class="status-indicator status-active"></span>
            </div>
            <div class="model-status active">
                <span>LIME Analysis</span>
                <span class="status-indicator status-active"></span>
            </div>
            <div class="model-status active">
                <span>Feature Importance</span>
                <span class="status-indicator status-active"></span>
            </div>
            <div class="model-status active">
                <span>Counterfactual Analysis</span>
                <span class="status-indicator status-active"></span>
            </div>
        </div>
    </div>
    
    <div class="main-content">
        <div class="container">
            <header>
                <h1>Ø³ÛŒØ³ØªÙ… Ø¬Ø§Ù…Ø¹ ØªØ­Ù„ÛŒÙ„ Ùˆ Ù…Ø¹Ø§Ù…Ù„Ù‡â€ŒÚ¯Ø±ÛŒ Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ Ø§ÛŒØ±Ø§Ù†</h1>
                <p class="subtitle">ØªØ­Ù„ÛŒÙ„ ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡ Ø¨ÙˆØ±Ø³ØŒ Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„ØŒ Ø·Ù„Ø§ Ùˆ Ø§Ø±Ø² Ø¨Ø§ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡</p>
            </header>
            
            <div class="controls">
                <div class="control-group">
                    <select id="marketType">
                        <option value="all">Ù‡Ù…Ù‡ Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§</option>
                        <option value="stock">Ø¨ÙˆØ±Ø³ Ø§ÙˆØ±Ø§Ù‚ Ø¨Ù‡Ø§Ø¯Ø§Ø±</option>
                        <option value="crypto">Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„</option>
                        <option value="gold">Ø·Ù„Ø§ Ùˆ Ø³Ú©Ù‡</option>
                        <option value="currency">Ø§Ø±Ø²</option>
                        <option value="commodity">Ú©Ø§Ù…ÙˆØ¯ÛŒØªÛŒ</option>
                    </select>
                    
                    <select id="timeFrame">
                        <option value="1d">Û± Ø±ÙˆØ²</option>
                        <option value="1w">Û± Ù‡ÙØªÙ‡</option>
                        <option value="1m">Û± Ù…Ø§Ù‡</option>
                        <option value="3m">Û³ Ù…Ø§Ù‡</option>
                        <option value="1y">Û± Ø³Ø§Ù„</option>
                    </select>
                    
                    <button id="refreshBtn">
                        <span>ğŸ”„</span> Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
                    </button>
                </div>
                
                <div class="control-group">
                    <button id="analyzeBtn">
                        <span>ğŸ¤–</span> ØªØ­Ù„ÛŒÙ„ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ
                    </button>
                    <button id="riskBtn">
                        <span>âš ï¸</span> Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø±ÛŒØ³Ú©
                    </button>
                    <button id="tradeBtn">
                        <span>ğŸ’¼</span> Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù…Ø¹Ø§Ù…Ù„Ù‡
                    </button>
                    <button id="explainBtn">
                        <span>ğŸ”</span> ØªÙˆØ¶ÛŒØ­ ØªØµÙ…ÛŒÙ…Ø§Øª
                    </button>
                </div>
            </div>
            
            <div class="tab-container">
                <div class="tabs">
                    <div class="tab active" data-tab="dashboard">Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ø§ØµÙ„ÛŒ</div>
                    <div class="tab" data-tab="analysis">ØªØ­Ù„ÛŒÙ„ Ù¾ÛŒØ´Ø±ÙØªÙ‡</div>
                    <div class="tab" data-tab="explanations">ØªÙˆØ¶ÛŒØ­â€ŒÙ¾Ø°ÛŒØ±ÛŒ AI</div>
                    <div class="tab" data-tab="trading">Ù…Ø¹Ø§Ù…Ù„Ø§Øª</div>
                    <div class="tab" data-tab="reports">Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§</div>
                    <div class="tab" data-tab="transformer">Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Transformer</div>
                </div>
                
                <div class="tab-content active" id="dashboard-tab">
                    <div class="dashboard">
                        <div class="card">
                            <h2>ÙˆØ¶Ø¹ÛŒØª Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§</h2>
                            <div class="market-grid" id="marketStatus">
                                <div class="loading">Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±...</div>
                            </div>
                        </div>
                        
                        <div class="card">
                            <h2>Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ú©Ù„Ø§Ù†</h2>
                            <div id="indicesChart" class="chart-container"></div>
                        </div>
                        
                        <div class="card">
                            <h2>ØªØ­Ù„ÛŒÙ„ Ù‚ÛŒÙ…Øª Ùˆ Ø±ÙˆÙ†Ø¯</h2>
                            <div id="priceChart" class="chart-container"></div>
                        </div>
                        
                        <div class="card">
                            <h2>ØªØ­Ù„ÛŒÙ„ ØªÚ©Ù†ÛŒÚ©Ø§Ù„ Ù¾ÛŒØ´Ø±ÙØªÙ‡</h2>
                            <div id="technicalChart" class="chart-container"></div>
                        </div>
                    </div>
                    
                    <div class="card analysis-section">
                        <h2>ØªØ­Ù„ÛŒÙ„ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ùˆ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ</h2>
                        <div class="analysis-grid" id="aiAnalysis">
                            <div class="loading">Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ØŒ Ø¯Ú©Ù…Ù‡ "ØªØ­Ù„ÛŒÙ„ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ" Ø±Ø§ Ø¨ÙØ´Ø§Ø±ÛŒØ¯</div>
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="analysis-tab">
                    <div class="card">
                        <h2>ØªØ­Ù„ÛŒÙ„ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø¨Ø§Ø²Ø§Ø±</h2>
                        <div class="feature-grid">
                            <div class="feature-item">
                                <div class="feature-icon">ğŸ“Š</div>
                                <h3>ØªØ­Ù„ÛŒÙ„ ØªÚ©Ù†ÛŒÚ©Ø§Ù„</h3>
                                <p>Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ùˆ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ</p>
                            </div>
                            <div class="feature-item">
                                <div class="feature-icon">ğŸ“ˆ</div>
                                <h3>ØªØ­Ù„ÛŒÙ„ Ø¨Ù†ÛŒØ§Ø¯ÛŒ</h3>
                                <p>Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø§Ø±Ø²Ø´ Ø°Ø§ØªÛŒ Ùˆ Ù¾ØªØ§Ù†Ø³ÛŒÙ„ Ø±Ø´Ø¯</p>
                            </div>
                            <div class="feature-item">
                                <div class="feature-icon">ğŸ§ </div>
                                <h3>Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</h3>
                                <p>Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø±ÙˆÙ†Ø¯ Ø¨Ø§ Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Transformer</p>
                            </div>
                            <div class="feature-item">
                                <div class="feature-icon">ğŸ“‰</div>
                                <h3>ØªØ­Ù„ÛŒÙ„ Ø§Ø­Ø³Ø§Ø³Ø§Øª</h3>
                                <p>Ø¨Ø±Ø±Ø³ÛŒ Ø¬Ùˆ Ø¨Ø§Ø²Ø§Ø± Ùˆ ØªØ£Ø«ÛŒØ± Ø§Ø®Ø¨Ø§Ø±</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Ú¯Ø²Ø§Ø±Ø´ ØªØ­Ù„ÛŒÙ„ Ø¨Ø§Ø²Ø§Ø±</h2>
                        <div id="advancedAnalysis" class="analysis-grid">
                            <div class="loading">Ø¯Ø± Ø­Ø§Ù„ Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡...</div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>ØªØ­Ù„ÛŒÙ„ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…Ù‡Ù…</h2>
                        <div id="featureImportanceChart" class="chart-container"></div>
                    </div>
                </div>
                
                <div class="tab-content" id="explanations-tab">
                    <div class="card">
                        <h2>ØªÙˆØ¶ÛŒØ­â€ŒÙ¾Ø°ÛŒØ±ÛŒ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ (XAI)</h2>
                        <div class="analysis-grid" id="xaiExplanations">
                            <div class="loading">Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯ ØªÙˆØ¶ÛŒØ­Ø§Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ...</div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>ØªØ­Ù„ÛŒÙ„ SHAP</h2>
                        <div id="shapChart" class="chart-container"></div>
                    </div>
                    
                    <div class="card">
                        <h2>ØªØ­Ù„ÛŒÙ„ LIME</h2>
                        <div id="limeChart" class="chart-container"></div>
                    </div>
                </div>
                
                <div class="tab-content" id="trading-tab">
                    <div class="card">
                        <h2>Ø³ÛŒØ³ØªÙ… Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯</h2>
                        <div class="analysis-grid">
                            <div class="analysis-item opportunity-item">
                                <h3>Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø®Ø±ÛŒØ¯</h3>
                                <p><strong>Ù†Ù…Ø§Ø¯:</strong> Ø´ØªØ±Ø§Ù†</p>
                                <p><strong>Ù‚ÛŒÙ…Øª Ù‡Ø¯Ù:</strong> ÛµÛ²,Û°Û°Û° ØªÙˆÙ…Ø§Ù†</p>
                                <p><strong>Ø­Ø¯ Ø¶Ø±Ø±:</strong> Û´Û²,Û°Û°Û° ØªÙˆÙ…Ø§Ù†</p>
                                <div class="market-change positive">Ø§Ø¹ØªÙ…Ø§Ø¯: Û·Û¸%</div>
                            </div>
                            <div class="analysis-item opportunity-item">
                                <h3>Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø®Ø±ÛŒØ¯</h3>
                                <p><strong>Ù†Ù…Ø§Ø¯:</strong> Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ†</p>
                                <p><strong>Ù‚ÛŒÙ…Øª Ù‡Ø¯Ù:</strong> Û¹Ûµ,Û°Û°Û° Ø¯Ù„Ø§Ø±</p>
                                <p><strong>Ø­Ø¯ Ø¶Ø±Ø±:</strong> Û·Û¸,Û°Û°Û° Ø¯Ù„Ø§Ø±</p>
                                <div class="market-change positive">Ø§Ø¹ØªÙ…Ø§Ø¯: Û¸Û²%</div>
                            </div>
                            <div class="analysis-item risk-item">
                                <h3>Ù‡Ø´Ø¯Ø§Ø± ÙØ±ÙˆØ´</h3>
                                <p><strong>Ù†Ù…Ø§Ø¯:</strong> Ø³Ú©Ù‡ Ø§Ù…Ø§Ù…ÛŒ</p>
                                <p><strong>Ø¯Ù„ÛŒÙ„:</strong> Ø±Ø³ÛŒØ¯Ù† Ø¨Ù‡ Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø§Ø´Ø¨Ø§Ø¹ Ø®Ø±ÛŒØ¯</p>
                                <p><strong>ØªÙˆØµÛŒÙ‡:</strong> Ú©Ø§Ù‡Ø´ Ù…ÙˆÙ‚Ø¹ÛŒØª</p>
                                <div class="market-change negative">Ø±ÛŒØ³Ú©: Ø¨Ø§Ù„Ø§</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>ØªØ­Ù„ÛŒÙ„ Ø³Ù†Ø§Ø±ÛŒÙˆÙ‡Ø§ÛŒ Ù…ØªØºÛŒØ±</h2>
                        <div id="counterfactualChart" class="chart-container"></div>
                    </div>
                </div>
                
                <div class="tab-content" id="reports-tab">
                    <div class="card">
                        <h2>Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯</h2>
                        <div class="analysis-grid">
                            <div class="analysis-item">
                                <h3>Ø¹Ù…Ù„Ú©Ø±Ø¯ Ù¾Ø±ØªÙÙˆÛŒ</h3>
                                <p><strong>Ø³ÙˆØ¯/Ø²ÛŒØ§Ù† Ú©Ù„:</strong> +Û±Û².Ûµ%</p>
                                <p><strong>Ø¨Ù‡ØªØ±ÛŒÙ† Ø¹Ù…Ù„Ú©Ø±Ø¯:</strong> Ø¨ÙˆØ±Ø³ (+Û±Û¸.Û²%)</p>
                                <p><strong>Ø¶Ø¹ÛŒÙâ€ŒØªØ±ÛŒÙ† Ø¹Ù…Ù„Ú©Ø±Ø¯:</strong> Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„ (+Ûµ.Û¸%)</p>
                            </div>
                            <div class="analysis-item">
                                <h3>ØªØ­Ù„ÛŒÙ„ Ø±ÛŒØ³Ú©</h3>
                                <p><strong>VaR 95%:</strong> -Û³.Û²%</p>
                                <p><strong>Ø­Ø¯Ø§Ú©Ø«Ø± Ø§ÙØª:</strong> -Û¸.Ûµ%</p>
                                <p><strong>Ù†Ø³Ø¨Øª Ø´Ø§Ø±Ù¾:</strong> Û±.Û´Ûµ</p>
                            </div>
                            <div class="analysis-item">
                                <h3>Ú¯Ø²Ø§Ø±Ø´ Ù…Ø¹Ø§Ù…Ù„Ø§Øª</h3>
                                <p><strong>ØªØ¹Ø¯Ø§Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§Øª:</strong> Û´Û·</p>
                                <p><strong>Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø³ÙˆØ¯:</strong> +Û´.Û²%</p>
                                <p><strong>Ù†Ø±Ø® Ù…ÙˆÙÙ‚ÛŒØª:</strong> Û¶Û¸%</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="transformer-tab">
                    <div class="card">
                        <h2>Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Transformer Ù¾ÛŒØ´Ø±ÙØªÙ‡</h2>
                        <div class="analysis-grid">
                            <div class="analysis-item">
                                <h3>MarketSentimentTransformer</h3>
                                <p><strong>Ù…Ø¹Ù…Ø§Ø±ÛŒ:</strong> BERT-base + Attention Layers</p>
                                <p><strong>Ø¯Ù‚Øª:</strong> Û¸Û·.Û³%</p>
                                <p><strong>Ú©Ø§Ø±Ø¨Ø±Ø¯:</strong> ØªØ­Ù„ÛŒÙ„ Ø§Ø­Ø³Ø§Ø³Ø§Øª Ø¨Ø§Ø²Ø§Ø±</p>
                            </div>
                            <div class="analysis-item">
                                <h3>PricePredictionTransformer</h3>
                                <p><strong>Ù…Ø¹Ù…Ø§Ø±ÛŒ:</strong> Multi-Scale Attention</p>
                                <p><strong>Ø¯Ù‚Øª:</strong> Û·Û¹.Û¸%</p>
                                <p><strong>Ú©Ø§Ø±Ø¨Ø±Ø¯:</strong> Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ù‚ÛŒÙ…Øª</p>
                            </div>
                            <div class="analysis-item">
                                <h3>TimeSeriesTransformer</h3>
                                <p><strong>Ù…Ø¹Ù…Ø§Ø±ÛŒ:</strong> Positional Encoding</p>
                                <p><strong>Ø¯Ù‚Øª:</strong> Û¸Û².Û±%</p>
                                <p><strong>Ú©Ø§Ø±Ø¨Ø±Ø¯:</strong> ØªØ­Ù„ÛŒÙ„ Ø³Ø±ÛŒ Ø²Ù…Ø§Ù†ÛŒ</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒâ€ŒÙ‡Ø§ÛŒ Transformer</h2>
                        <div id="transformerPredictionsChart" class="chart-container"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===============================
        // API endpoints and configuration
        // ===============================
                       const API_ENDPOINTS = {
            stockSymbols: 'https://BrsApi.ir/Api/Tsetmc/AllSymbols.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES',
            stockIndex: 'https://BrsApi.ir/Api/Tsetmc/Index.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=1',
            farabourseIndex: 'https://BrsApi.ir/Api/Tsetmc/Index.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=2',
            selectedIndex: 'https://BrsApi.ir/Api/Tsetmc/Index.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=1',
            crypto: 'https://BrsApi.ir/Api/Market/Cryptocurrency.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES',
            commodityMetals: 'https://BrsApi.ir/Api/Market/Commodity.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=1',
            commodityBaseMetals: 'https://BrsApi.ir/Api/Market/Commodity.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=2',
            commodityEnergy: 'https://BrsApi.ir/Api/Market/Commodity.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=3',
            gold: 'https://BrsApi.ir/Api/Market/Gold_Currency.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=1',
            currency: 'https://BrsApi.ir/Api/Market/Gold_Currency.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=2',
            crypto2: 'https://BrsApi.ir/Api/Market/Gold_Currency.php?key=BKNzfpdXhJMcUANBeAAcNT24Cdys8MES&type=3'
        };

        const API_NAMES = {
            stockSymbols: 'Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ Ø¨ÙˆØ±Ø³',
            stockIndex: 'Ø´Ø§Ø®Øµ Ø¨ÙˆØ±Ø³',
            farabourseIndex: 'Ø´Ø§Ø®Øµ ÙØ±Ø§Ø¨ÙˆØ±Ø³',
            selectedIndex: 'Ø´Ø§Ø®Øµ Ù…Ù†ØªØ®Ø¨',
            crypto: 'Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„',
            commodityMetals: 'ÙÙ„Ø²Ø§Øª Ú¯Ø±Ø§Ù†Ø¨Ù‡Ø§',
            commodityBaseMetals: 'ÙÙ„Ø²Ø§Øª Ø§Ø³Ø§Ø³ÛŒ',
            commodityEnergy: 'Ø§Ù†Ø±Ú˜ÛŒ',
            gold: 'Ø·Ù„Ø§ Ùˆ Ø³Ú©Ù‡',
            currency: 'Ø§Ø±Ø²',
            crypto2: 'Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„ (Ù…Ù†Ø¨Ø¹ Û²)'
        };

        // ===============================
        // Ø³ÛŒØ³ØªÙ… Ù†Ø¸Ø§Ø±Øª Ù‡ÙˆØ´Ù…Ù†Ø¯
        // ===============================
        class APIMonitoringSystem {
            constructor() {
                this.apiStatus = {};
                this.connectionHistory = [];
                this.alerts = [];
                this.monitoringInterval = null;
                this.isMonitoring = false;
                
                this.initializeMonitoring();
            }

            initializeMonitoring() {
                // Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ ÙˆØ¶Ø¹ÛŒØª Ù‡Ù…Ù‡ APIÙ‡Ø§
                for (const [key, url] of Object.entries(API_ENDPOINTS)) {
                    this.apiStatus[key] = {
                        name: API_NAMES[key],
                        url: url,
                        status: 'unknown',
                        lastCheck: null,
                        responseTime: null,
                        successRate: 0,
                        errorCount: 0,
                        successCount: 0,
                        lastError: null,
                        shouldBeActive: this.shouldAPIBeActive(key)
                    };
                }
            }

            // Ø¨Ø±Ø±Ø³ÛŒ Ø³Ø§Ø¹Ø§Øª Ú©Ø§Ø±ÛŒ APIÙ‡Ø§
            shouldAPIBeActive(apiKey) {
                const tehranTime = this.getTehranTime();
                const hour = tehranTime.getHours();
                const minute = tehranTime.getMinutes();
                const day = tehranTime.getDay();
                
                // APIÙ‡Ø§ÛŒ Ø¨ÙˆØ±Ø³ ÙÙ‚Ø· Ø¯Ø± Ø³Ø§Ø¹Ø§Øª Ú©Ø§Ø±ÛŒ ÙØ¹Ø§Ù„ Ù‡Ø³ØªÙ†Ø¯
                if (apiKey.includes('stock') || apiKey.includes('Index')) {
                    if (day >= 5) return false; // Ø¬Ù…Ø¹Ù‡ Ùˆ Ø´Ù†Ø¨Ù‡
                    if (hour < 9 || hour > 12) return false;
                    if (hour === 12 && minute > 30) return false;
                }
                
                return true;
            }

            getTehranTime() {
                const now = new Date();
                const tehranOffset = 3.5 * 60 * 60 * 1000; // UTC+3:30
                return new Date(now.getTime() + tehranOffset);
            }

            // Ø´Ø±ÙˆØ¹ Ù†Ø¸Ø§Ø±Øª Ø®ÙˆØ¯Ú©Ø§Ø±
            startAutoMonitoring() {
                if (this.monitoringInterval) {
                    clearInterval(this.monitoringInterval);
                }
                
                this.isMonitoring = true;
                this.monitoringInterval = setInterval(() => {
                    this.checkAllAPIs();
                }, 60000); // Ù‡Ø± 1 Ø¯Ù‚ÛŒÙ‚Ù‡
                
                // Ø§ÙˆÙ„ÛŒÙ† Ø¨Ø±Ø±Ø³ÛŒ ÙÙˆØ±ÛŒ
                this.checkAllAPIs();
                
                showNotification('Ø³ÛŒØ³ØªÙ… Ù†Ø¸Ø§Ø±Øª Ø®ÙˆØ¯Ú©Ø§Ø± APIÙ‡Ø§ ÙØ¹Ø§Ù„ Ø´Ø¯', 'success');
            }

            // ØªÙˆÙ‚Ù Ù†Ø¸Ø§Ø±Øª
            stopAutoMonitoring() {
                if (this.monitoringInterval) {
                    clearInterval(this.monitoringInterval);
                    this.monitoringInterval = null;
                }
                this.isMonitoring = false;
                showNotification('Ø³ÛŒØ³ØªÙ… Ù†Ø¸Ø§Ø±Øª Ø®ÙˆØ¯Ú©Ø§Ø± Ù…ØªÙˆÙ‚Ù Ø´Ø¯', 'warning');
            }

            // Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ù‡Ù…Ù‡ APIÙ‡Ø§
            async checkAllAPIs() {
                const promises = [];
                
                for (const [key, apiInfo] of Object.entries(this.apiStatus)) {
                    promises.push(this.checkSingleAPI(key, apiInfo));
                }
                
                await Promise.all(promises);
                this.updateMonitoringDisplay();
                this.updateConnectionChart();
            }

            // Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª ÛŒÚ© API Ø®Ø§Øµ
            async checkSingleAPI(apiKey, apiInfo) {
                // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø³Ø§Ø¹Ø§Øª Ú©Ø§Ø±ÛŒ
                apiInfo.shouldBeActive = this.shouldAPIBeActive(apiKey);
                
                if (!apiInfo.shouldBeActive) {
                    apiInfo.status = 'inactive_hours';
                    apiInfo.lastCheck = new Date();
                    return;
                }

                try {
                    const startTime = Date.now();
                    const response = await axios.get(apiInfo.url, {
                        timeout: 10000,
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    const responseTime = Date.now() - startTime;
                    
                    // Ø«Ø¨Øª Ù…ÙˆÙÙ‚ÛŒØª
                    apiInfo.status = 'connected';
                    apiInfo.lastCheck = new Date();
                    apiInfo.responseTime = responseTime;
                    apiInfo.successCount++;
                    apiInfo.lastError = null;
                    
                    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†Ø±Ø® Ù…ÙˆÙÙ‚ÛŒØª
                    const totalRequests = apiInfo.successCount + apiInfo.errorCount;
                    apiInfo.successRate = totalRequests > 0 ? (apiInfo.successCount / totalRequests) * 100 : 0;
                    
                    // Ø«Ø¨Øª Ø¯Ø± ØªØ§Ø±ÛŒØ®Ú†Ù‡
                    this.connectionHistory.push({
                        api: apiKey,
                        timestamp: new Date(),
                        status: 'success',
                        responseTime: responseTime
                    });
                    
                } catch (error) {
                    // Ø«Ø¨Øª Ø®Ø·Ø§
                    apiInfo.status = 'disconnected';
                    apiInfo.lastCheck = new Date();
                    apiInfo.errorCount++;
                    apiInfo.lastError = error.message;
                    
                    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†Ø±Ø® Ù…ÙˆÙÙ‚ÛŒØª
                    const totalRequests = apiInfo.successCount + apiInfo.errorCount;
                    apiInfo.successRate = totalRequests > 0 ? (apiInfo.successCount / totalRequests) * 100 : 0;
                    
                    // Ø«Ø¨Øª Ø¯Ø± ØªØ§Ø±ÛŒØ®Ú†Ù‡
                    this.connectionHistory.push({
                        api: apiKey,
                        timestamp: new Date(),
                        status: 'error',
                        error: error.message
                    });
                    
                    // Ø§Ø±Ø³Ø§Ù„ Ù‡Ø´Ø¯Ø§Ø±
                    this.sendAlert(apiKey, `Ù‚Ø·Ø¹ Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§ ${apiInfo.name}`, error.message);
                }
            }

            // Ø§Ø±Ø³Ø§Ù„ Ù‡Ø´Ø¯Ø§Ø±
            sendAlert(apiKey, title, message) {
                const alert = {
                    id: Date.now(),
                    apiKey: apiKey,
                    apiName: API_NAMES[apiKey],
                    title: title,
                    message: message,
                    timestamp: new Date(),
                    read: false
                };
                
                this.alerts.unshift(alert);
                
                // Ù†Ù…Ø§ÛŒØ´ Ù†ÙˆØªÛŒÙÛŒÚ©ÛŒØ´Ù†
                showNotification(`ğŸš¨ ${title}: ${message}`, 'error');
                
                // Ù¾Ø®Ø´ ØµØ¯Ø§ÛŒ Ù‡Ø´Ø¯Ø§Ø± (Ø¯Ø± ØµÙˆØ±Øª Ù†ÛŒØ§Ø²)
                this.playAlertSound();
                
                // Ø­ÙØ¸ Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ (Ø­Ø¯Ø§Ú©Ø«Ø± 50 Ù…ÙˆØ±Ø¯)
                if (this.alerts.length > 50) {
                    this.alerts = this.alerts.slice(0, 50);
                }
                
                this.updateAlertsDisplay();
            }

            playAlertSound() {
                // Ø§ÛŒØ¬Ø§Ø¯ ØµØ¯Ø§ÛŒ Ù‡Ø´Ø¯Ø§Ø± Ø³Ø§Ø¯Ù‡
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (error) {
                    console.log('Ø§Ù…Ú©Ø§Ù† Ù¾Ø®Ø´ ØµØ¯Ø§ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯');
                }
            }

            // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù†Ù…Ø§ÛŒØ´ ÙˆØ¶Ø¹ÛŒØª
            updateMonitoringDisplay() {
                this.updateSidebarStatus();
                this.updateLiveMonitoring();
                this.updatePerformanceStats();
                this.updateConnectionStats();
            }

            // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø¯Ø± sidebar
            updateSidebarStatus() {
                const container = document.getElementById('apiStatusContainer');
                let html = '';
                
                for (const [key, apiInfo] of Object.entries(this.apiStatus)) {
                    let statusClass = 'api-status ';
                    let statusText = '';
                    let indicatorClass = '';
                    
                    if (!apiInfo.shouldBeActive) {
                        statusClass += 'warning';
                        statusText = 'â¸ ØºÛŒØ±ÙØ¹Ø§Ù„ (Ø³Ø§Ø¹Ø§Øª Ú©Ø§Ø±ÛŒ)';
                        indicatorClass = 'status-warning';
                    } else if (apiInfo.status === 'connected') {
                        statusClass += 'connected';
                        statusText = `âœ… Ù…ØªØµÙ„ (${apiInfo.responseTime}ms)`;
                        indicatorClass = 'status-connected';
                    } else if (apiInfo.status === 'disconnected') {
                        statusClass += 'disconnected';
                        statusText = 'âŒ Ù‚Ø·Ø¹ Ø§Ø±ØªØ¨Ø§Ø·';
                        indicatorClass = 'status-disconnected';
                    } else {
                        statusClass += 'warning';
                        statusText = 'ğŸ” Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø±Ø±Ø³ÛŒ...';
                        indicatorClass = 'status-warning';
                    }
                    
                    html += `
                        <div class="${statusClass}">
                            <div>
                                <strong>${apiInfo.name}</strong>
                                <br>
                                <small>${statusText}</small>
                            </div>
                            <span class="status-indicator ${indicatorClass}"></span>
                        </div>
                    `;
                }
                
                container.innerHTML = html;
            }

            // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¢Ù…Ø§Ø± Ø§ØªØµØ§Ù„
            updateConnectionStats() {
                let connected = 0;
                let disconnected = 0;
                let total = 0;
                
                for (const apiInfo of Object.values(this.apiStatus)) {
                    if (apiInfo.shouldBeActive) {
                        total++;
                        if (apiInfo.status === 'connected') {
                            connected++;
                        } else if (apiInfo.status === 'disconnected') {
                            disconnected++;
                        }
                    }
                }
                
                document.getElementById('connectedCount').textContent = connected;
                document.getElementById('disconnectedCount').textContent = disconnected;
                document.getElementById('totalCount').textContent = total;
            }

            // Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ø¬Ù‡Ø§Ù†ÛŒ
        // ===============================
        let marketData = {
            stocks: [],
            indices: [],
            crypto: [],
            gold: [],
            currency: [],
            commodities: []
        };

        let monitoringSystem = new APIMonitoringSystem();

        // ===============================
        // Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ø¨Ø±Ù†Ø§Ù…Ù‡
        // ===============================
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        function initializeApp() {
            setupEventListeners();
            setupTabs();
            initializeCharts();
            loadMarketData();
            monitoringSystem.startAutoMonitoring();
            updateMarketHours();
        }

        function setupEventListeners() {
            document.getElementById('refreshBtn').addEventListener('click', loadMarketData);
            document.getElementById('analyzeBtn').addEventListener('click', performAIAnalysis);
            document.getElementById('riskBtn').addEventListener('click', performRiskAssessment);
            document.getElementById('tradeBtn').addEventListener('click', generateTradeSuggestions);
            document.getElementById('monitorBtn').addEventListener('click', () => monitoringSystem.checkAllAPIs());
            document.getElementById('marketType').addEventListener('change', updateCharts);
            document.getElementById('timeFrame').addEventListener('change', updateCharts);
        }
        
        // ===============================
        // ØªÙˆØ§Ø¨Ø¹ Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„ ÙˆØ§Ù‚Ø¹ÛŒ Ø¨Ù‡ API
        // ===============================

        async function loadRealMarketData() {
            try {
                showLoading('marketStatus', 'Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ Ø§Ø² Ø³Ø±ÙˆØ±...');
                showNotification('Ø§ØªØµØ§Ù„ Ø¨Ù‡ APIÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø± Ø³Ø±Ù…Ø§ÛŒÙ‡...', 'info');

                // Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…ÙˆØ§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø§Ø² ØªÙ…Ø§Ù… APIÙ‡Ø§
                const [
                    stocksData,
                    indicesData,
                    cryptoData,
                    goldData,
                    currencyData,
                    commoditiesData
                ] = await Promise.all([
                    fetchWithFallback(API_ENDPOINTS.stockSymbols, 'stocks'),
                    fetchWithFallback(API_ENDPOINTS.stockIndex, 'indices'),
                    fetchWithFallback(API_ENDPOINTS.crypto, 'crypto'),
                    fetchWithFallback(API_ENDPOINTS.gold, 'gold'),
                    fetchWithFallback(API_ENDPOINTS.currency, 'currency'),
                    fetchWithFallback(API_ENDPOINTS.commodityMetals, 'commodities')
                ]);

                // Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ
                marketData.stocks = processRealStockData(stocksData);
                marketData.indices = processRealIndexData(indicesData);
                marketData.crypto = processRealCryptoData(cryptoData);
                marketData.gold = processRealGoldData(goldData);
                marketData.currency = processRealCurrencyData(currencyData);
                marketData.commodities = processRealCommodityData(commoditiesData);

                // Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ UI
                updateMarketStatus();
                updateCharts();
                updateAdvancedAnalysis();
                updateTechnicalIndicators();
                updateRiskMetrics();

                showNotification('Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯', 'success');

            } catch (error) {
                console.error('Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ:', error);
                showError('marketStatus', 'Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ APIÙ‡Ø§');
                showNotification('Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯Ù‡', 'warning');
                
                // Fallback Ø¨Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ mock
                loadMockDataAsFallback();
            }
        }

        // ØªØ§Ø¨Ø¹ Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡ Ø¨Ø±Ø§ÛŒ fetch Ø¨Ø§ Ù…Ø¯ÛŒØ±ÛŒØª Ø®Ø·Ø§
        async function fetchWithFallback(url, dataType) {
            try {
                console.log(`Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡ Ø§Ø²: ${url}`);
                const response = await axios.get(url, {
                    timeout: 10000,
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    }
                });

                if (response.status === 200 && response.data) {
                    console.log(`Ø¯Ø§Ø¯Ù‡ ${dataType} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯:`, response.data);
                    return response.data;
                } else {
                    throw new Error(`Ù¾Ø§Ø³Ø® Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø² API ${dataType}`);
                }
            } catch (error) {
                console.warn(`Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ${dataType}:`, error.message);
                // Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ mock Ø¯Ø± ØµÙˆØ±Øª Ø®Ø·Ø§
                return generateMockData(dataType);
            }
        }

        // ØªÙˆØ§Ø¨Ø¹ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ
        function processRealStockData(apiData) {
            if (!apiData || !Array.isArray(apiData)) {
                console.warn('Ø¯Ø§Ø¯Ù‡ Ø¨ÙˆØ±Ø³ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³ØªØŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¯Ø§Ø¯Ù‡ mock');
                return generateMockStocks();
            }

            return apiData.slice(0, 50).map(item => ({
                symbol: item.l18 || 'N/A',
                name: item.l30 || 'N/A',
                price: item.pl || item.pc || 0,
                change: item.plc || item.pcc || 0,
                changePercent: item.plp || item.pcp || 0,
                volume: item.tvol || 0,
                value: item.tval || 0,
                high: item.pmax || 0,
                low: item.pmin || 0,
                // Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ Ø§Ø² API
                eps: item.eps || 0,
                pe: item.pe || 0,
                marketCap: item.mv || 0
            }));
        }

        function processRealIndexData(apiData) {
            if (!apiData || !Array.isArray(apiData)) {
                console.warn('Ø¯Ø§Ø¯Ù‡ Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³ØªØŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¯Ø§Ø¯Ù‡ mock');
                return generateMockIndices();
            }

            return apiData.map(item => ({
                name: item.name || 'N/A',
                value: item.index || 0,
                change: item.index_change || 0,
                changePercent: item.index_change_percent || 0,
                high: item.max || 0,
                low: item.min || 0,
                // Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ
                marketValue: item.mv || 0,
                tradeVolume: item.tvol || 0,
                tradeValue: item.tval || 0
            }));
        }

        function processRealCryptoData(apiData) {
            if (!apiData || !Array.isArray(apiData)) {
                console.warn('Ø¯Ø§Ø¯Ù‡ Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³ØªØŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¯Ø§Ø¯Ù‡ mock');
                return generateMockCrypto();
            }

            return apiData.slice(0, 20).map(item => ({
                name: item.name || 'N/A',
                price: item.price || 0,
                priceToman: item.price_toman || 0,
                changePercent: item.change_percent || 0,
                marketCap: item.market_cap || 0,
                // Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ
                symbol: item.symbol || 'N/A',
                icon: item.link_icon || ''
            }));
        }

        function processRealGoldData(apiData) {
            if (!apiData || !Array.isArray(apiData)) {
                console.warn('Ø¯Ø§Ø¯Ù‡ Ø·Ù„Ø§ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³ØªØŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¯Ø§Ø¯Ù‡ mock');
                return generateMockGold();
            }

            return apiData.map(item => ({
                symbol: item.symbol || 'N/A',
                name: item.name || item.name_en || 'N/A',
                price: item.price || 0,
                change: item.change_value || 0,
                changePercent: item.change_percent || 0,
                unit: item.unit || 'ØªÙˆÙ…Ø§Ù†'
            }));
        }

        function processRealCurrencyData(apiData) {
            if (!apiData || !Array.isArray(apiData)) {
                console.warn('Ø¯Ø§Ø¯Ù‡ Ø§Ø±Ø² Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³ØªØŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¯Ø§Ø¯Ù‡ mock');
                return generateMockCurrency();
            }

            return apiData.map(item => ({
                symbol: item.symbol || 'N/A',
                name: item.name || item.name_en || 'N/A',
                price: item.price || 0,
                change: item.change_value || 0,
                changePercent: item.change_percent || 0,
                unit: item.unit || 'ØªÙˆÙ…Ø§Ù†'
            }));
        }

        function processRealCommodityData(apiData) {
            if (!apiData || !Array.isArray(apiData)) {
                console.warn('Ø¯Ø§Ø¯Ù‡ Ú©Ø§Ù…ÙˆØ¯ÛŒØªÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³ØªØŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¯Ø§Ø¯Ù‡ mock');
                return generateMockCommodities();
            }

            return apiData.map(item => ({
                symbol: item.symbol || 'N/A',
                name: item.name || 'N/A',
                price: item.price || 0,
                change: item.change_value || 0,
                changePercent: item.change_percent || 0,
                unit: item.unit || 'Ø¯Ù„Ø§Ø±'
            }));
        }

        // ØªØ§Ø¨Ø¹ fallback Ø¨Ø±Ø§ÛŒ Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ APIÙ‡Ø§ Ù¾Ø§Ø³Ø® Ù†Ù…ÛŒâ€ŒØ¯Ù‡Ù†Ø¯
        function loadMockDataAsFallback() {
            marketData.stocks = generateMockStocks();
            marketData.indices = generateMockIndices();
            marketData.crypto = generateMockCrypto();
            marketData.gold = generateMockGold();
            marketData.currency = generateMockCurrency();
            marketData.commodities = generateMockCommodities();

            updateMarketStatus();
            updateCharts();
            updateAdvancedAnalysis();
        }

        // ØªÙˆÙ„ÛŒØ¯ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ mock Ø¨Ø±Ø§ÛŒ fallback
        function generateMockData(dataType) {
            switch(dataType) {
                case 'stocks': return generateMockStocks();
                case 'indices': return generateMockIndices();
                case 'crypto': return generateMockCrypto();
                case 'gold': return generateMockGold();
                case 'currency': return generateMockCurrency();
                case 'commodities': return generateMockCommodities();
                default: return [];
            }
        }

        // ØªÙˆØ§Ø¨Ø¹ ØªÙˆÙ„ÛŒØ¯ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ mock (Ù‡Ù…Ø§Ù†Ù†Ø¯ Ù‚Ø¨Ù„)
        function generateMockStocks() {
            const symbols = ['Ø´ØªØ±Ø§Ù†', 'ÙÙˆÙ„Ø§Ø¯', 'Ø®Ø³Ø§Ù¾Ø§', 'ÙˆØ¨ØµØ§Ø¯Ø±', 'Ø´Ù¾Ù†Ø§', 'Ú©Ú¯Ù„', 'ÙÙ…Ù„ÛŒ', 'ÙˆØªØ¬Ø§Ø±Øª', 'Ø®Ù¾Ø§Ø±Ø³', 'Ø¨Ø±Ú©Øª'];
            return symbols.map(symbol => ({
                symbol: symbol,
                name: `Ø´Ø±Ú©Øª ${symbol}`,
                price: Math.floor(Math.random() * 50000) + 10000,
                change: (Math.random() * 2000) - 1000,
                changePercent: (Math.random() * 10) - 5,
                volume: Math.floor(Math.random() * 10000000),
                value: Math.floor(Math.random() * 500000000000),
                high: Math.floor(Math.random() * 60000) + 10000,
                low: Math.floor(Math.random() * 40000) + 5000
            }));
        }

        function generateMockIndices() {
            const indices = ['Ø´Ø§Ø®Øµ Ú©Ù„', 'Ø´Ø§Ø®Øµ Ù‡Ù… ÙˆØ²Ù†', 'Ø´Ø§Ø®Øµ ØµÙ†Ø¹Øª', 'Ø´Ø§Ø®Øµ Ù…Ø§Ù„ÛŒ'];
            return indices.map(name => ({
                name: name,
                value: Math.floor(Math.random() * 5000000) + 2000000,
                change: (Math.random() * 50000) - 25000,
                changePercent: (Math.random() * 5) - 2.5,
                high: Math.floor(Math.random() * 6000000) + 2000000,
                low: Math.floor(Math.random() * 4000000) + 1000000
            }));
        }

        function generateMockCrypto() {
            const cryptos = ['Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ†', 'Ø§ØªØ±ÛŒÙˆÙ…', 'Ø±ÛŒÙ¾Ù„', 'Ú©Ø§Ø±Ø¯Ø§Ù†Ùˆ', 'Ø³ÙˆÙ„Ø§Ù†Ø§'];
            return cryptos.map(name => ({
                name: name,
                price: Math.floor(Math.random() * 50000) + 20000,
                priceToman: Math.floor(Math.random() * 5000000000) + 2000000000,
                changePercent: (Math.random() * 15) - 7.5,
                marketCap: Math.floor(Math.random() * 1000000000000) + 500000000000
            }));
        }

        function generateMockGold() {
            const goldItems = ['Ø³Ú©Ù‡ Ø§Ù…Ø§Ù…ÛŒ', 'Ø³Ú©Ù‡ Ø¨Ù‡Ø§Ø± Ø¢Ø²Ø§Ø¯ÛŒ', 'Ù†ÛŒÙ… Ø³Ú©Ù‡', 'Ø±Ø¨Ø¹ Ø³Ú©Ù‡', 'Ø·Ù„Ø§ÛŒ 18 Ø¹ÛŒØ§Ø±'];
            return goldItems.map(name => ({
                symbol: name.replace(/\s/g, '_'),
                name: name,
                price: Math.floor(Math.random() * 50000000) + 50000000,
                change: (Math.random() * 2000000) - 1000000,
                changePercent: (Math.random() * 8) - 4,
                unit: 'ØªÙˆÙ…Ø§Ù†'
            }));
        }

        function generateMockCurrency() {
            const currencies = ['Ø¯Ù„Ø§Ø±', 'ÛŒÙˆØ±Ùˆ', 'Ù¾ÙˆÙ†Ø¯', 'Ø¯Ø±Ù‡Ù…', 'ÛŒÙ†'];
            return currencies.map(name => ({
                symbol: name,
                name: name,
                price: Math.floor(Math.random() * 50000) + 10000,
                change: (Math.random() * 1000) - 500,
                changePercent: (Math.random() * 6) - 3,
                unit: 'ØªÙˆÙ…Ø§Ù†'
            }));
        }

        function generateMockCommodities() {
            const commodities = ['Ù†ÙØª Ø¨Ø±Ù†Øª', 'Ø·Ù„Ø§ÛŒ Ø¬Ù‡Ø§Ù†ÛŒ', 'Ù†Ù‚Ø±Ù‡', 'Ù…Ø³', 'Ø¢Ù„ÙˆÙ…ÛŒÙ†ÛŒÙˆÙ…'];
            return commodities.map(name => ({
                symbol: name.replace(/\s/g, '_'),
                name: name,
                price: Math.floor(Math.random() * 200) + 50,
                change: (Math.random() * 10) - 5,
                changePercent: (Math.random() * 8) - 4,
                unit: 'Ø¯Ù„Ø§Ø±'
            }));
        }

        // ===============================
        // Ø§ØµÙ„Ø§Ø­ ØªØ§Ø¨Ø¹ Ø§ØµÙ„ÛŒ loadMarketData
        // ===============================
        async function loadMarketData() {
            // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ØªØ§Ø¨Ø¹ Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„ ÙˆØ§Ù‚Ø¹ÛŒ
            await loadRealMarketData();
        }

        // ===============================
        // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ù‚Ø§Ø¨Ù„ÛŒØª ØªØ³Øª API
        // ===============================
        async function testAPIConnection() {
            const testResults = {};
            
            for (const [name, url] of Object.entries(API_ENDPOINTS)) {
                try {
                    const startTime = Date.now();
                    const response = await axios.get(url, { timeout: 5000 });
                    const responseTime = Date.now() - startTime;
                    
                    testResults[name] = {
                        status: 'success',
                        responseTime: responseTime,
                        data: response.data ? 'Ø¯Ø§Ø¯Ù‡ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯' : 'Ø¨Ø¯ÙˆÙ† Ø¯Ø§Ø¯Ù‡'
                    };
                } catch (error) {
                    testResults[name] = {
                        status: 'error',
                        error: error.message
                    };
                }
            }
            
            console.log('Ù†ØªØ§ÛŒØ¬ ØªØ³Øª API:', testResults);
            return testResults;
        }

        // ØªØ³Øª Ø®ÙˆØ¯Ú©Ø§Ø± API Ù‡Ù†Ú¯Ø§Ù… Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ØµÙØ­Ù‡
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
            
            // ØªØ³Øª API Ø¯Ø± Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡
            setTimeout(() => {
                testAPIConnection().then(results => {
                    console.log('ÙˆØ¶Ø¹ÛŒØª Ø§ØªØµØ§Ù„ APIÙ‡Ø§:', results);
                });
            }, 2000);
        });

        // ===============================
        // Advanced AI Models Implementation
        // ===============================

        // Enum definitions from original code
        const ExplanationType = {
            COUNTERFACTUAL: "counterfactual",
            CONTRASTIVE: "contrastive",
            CAUSAL: "causal",
            EXAMPLE_BASED: "example_based",
            FEATURE_BASED: "feature_based"
        };

        const ConfidenceLevel = {
            VERY_HIGH: "very_high",
            HIGH: "high",
            MEDIUM: "medium",
            LOW: "low",
            VERY_LOW: "very_low"
        };

        const DecisionImpact = {
            STRONG_POSITIVE: "strong_positive",
            POSITIVE: "positive",
            NEUTRAL: "neutral",
            NEGATIVE: "negative",
            STRONG_NEGATIVE: "strong_negative"
        };

        // AdvancedDecisionExplainer - Complete implementation
        class AdvancedDecisionExplainer {
            constructor(config = {}) {
                this.config = {
                    counterfactual_samples: 1000,
                    similarity_threshold: 0.8,
                    max_counterfactuals: 5,
                    max_similar_cases: 5,
                    confidence_thresholds: {
                        'very_high': 0.9,
                        'high': 0.8,
                        'medium': 0.7,
                        'low': 0.6,
                        'very_low': 0.5
                    },
                    impact_thresholds: {
                        'strong_positive': 0.3,
                        'positive': 0.1,
                        'negative': -0.1,
                        'strong_negative': -0.3
                    },
                    ...config
                };
                
                this.model = null;
                this.feature_names = null;
                this.training_data = null;
            }

            explain_decision(model, instance, feature_names, training_data = null, explanation_type = ExplanationType.COUNTERFACTUAL) {
                this.model = model;
                this.feature_names = feature_names;
                this.training_data = training_data;

                try {
                    // Get prediction and confidence
                    const [prediction, confidence] = this._get_prediction_with_confidence(instance);
                    const confidence_level = this._get_confidence_level(confidence);
                    
                    // Analyze key factors
                    const key_factors = this._analyze_key_factors(instance, prediction);
                    
                    // Generate counterfactuals
                    const counterfactuals = this._generate_counterfactuals(instance, prediction);
                    
                    // Find similar cases
                    const similar_cases = this._find_similar_cases(instance, prediction, training_data);
                    
                    // Analyze decision boundary
                    const decision_boundary = this._analyze_decision_boundary(instance, prediction);
                    
                    // Identify risk and opportunity factors
                    const [risk_factors, opportunity_factors] = this._identify_risk_opportunity_factors(key_factors);
                    
                    // Generate rationale
                    const rationale = this._generate_rationale(prediction, key_factors, counterfactuals, similar_cases);

                    return {
                        prediction: prediction,
                        confidence: confidence,
                        confidence_level: confidence_level,
                        key_factors: key_factors,
                        counterfactuals: counterfactuals,
                        similar_cases: similar_cases,
                        decision_boundary: decision_boundary,
                        risk_factors: risk_factors,
                        opportunity_factors: opportunity_factors,
                        explanation_type: explanation_type,
                        rationale: rationale
                    };
                    
                } catch (error) {
                    console.error("Decision explanation failed:", error);
                    throw error;
                }
            }

            _get_prediction_with_confidence(instance) {
                // Simulate model prediction
                const prediction = Math.random() * 2 - 1; // -1 to 1
                const confidence = 0.7 + Math.random() * 0.3; // 0.7 to 1.0
                return [prediction, confidence];
            }

            _get_confidence_level(confidence) {
                const thresholds = this.config.confidence_thresholds;
                
                if (confidence >= thresholds.very_high) return ConfidenceLevel.VERY_HIGH;
                if (confidence >= thresholds.high) return ConfidenceLevel.HIGH;
                if (confidence >= thresholds.medium) return ConfidenceLevel.MEDIUM;
                if (confidence >= thresholds.low) return ConfidenceLevel.LOW;
                return ConfidenceLevel.VERY_LOW;
            }

            _analyze_key_factors(instance, prediction) {
                const key_factors = [];
                const num_features = this.feature_names.length;
                
                for (let i = 0; i < num_features; i++) {
                    const feature_name = this.feature_names[i];
                    const contribution = (Math.random() * 2 - 1) * 0.5;
                    const impact = this._determine_impact(contribution, prediction);
                    
                    key_factors.push([feature_name, contribution, impact]);
                }
                
                // Sort by absolute contribution
                key_factors.sort((a, b) => Math.abs(b[1]) - Math.abs(a[1]));
                
                return key_factors.slice(0, 10);
            }

            _determine_impact(contribution, prediction) {
                const thresholds = this.config.impact_thresholds;
                let normalized_contrib = contribution;
                
                if (Math.abs(prediction) > 0) {
                    normalized_contrib = contribution / Math.abs(prediction);
                }
                
                if (normalized_contrib >= thresholds.strong_positive) return DecisionImpact.STRONG_POSITIVE;
                if (normalized_contrib >= thresholds.positive) return DecisionImpact.POSITIVE;
                if (normalized_contrib <= thresholds.strong_negative) return DecisionImpact.STRONG_NEGATIVE;
                if (normalized_contrib <= thresholds.negative) return DecisionImpact.NEGATIVE;
                return DecisionImpact.NEUTRAL;
            }

            _generate_counterfactuals(instance, prediction) {
                const counterfactuals = [];
                const key_factors = this._analyze_key_factors(instance, prediction);
                
                for (const [feature_name, contribution, impact] of key_factors.slice(0, 3)) {
                    let action = "optimize";
                    if (impact === DecisionImpact.NEGATIVE || impact === DecisionImpact.STRONG_NEGATIVE) {
                        action = "increase";
                    } else if (impact === DecisionImpact.POSITIVE || impact === DecisionImpact.STRONG_POSITIVE) {
                        action = "maintain";
                    }
                    
                    const counterfactual = this._create_counterfactual(instance, feature_name, contribution, action);
                    if (counterfactual) {
                        counterfactuals.push(counterfactual);
                    }
                }
                
                return counterfactuals.slice(0, this.config.max_counterfactuals);
            }

            _create_counterfactual(instance, feature_name, contribution, action) {
                const feature_idx = this.feature_names.indexOf(feature_name);
                const current_value = instance[feature_idx];
                
                let suggested_value, expected_impact, description;
                
                if (action === "increase") {
                    suggested_value = current_value * 1.2;
                    expected_impact = Math.abs(contribution) * 0.8;
                    description = `Ø§ÙØ²Ø§ÛŒØ´ ${feature_name} Ø¨Ø±Ø§ÛŒ Ø¨Ù‡Ø¨ÙˆØ¯ ØªØ§Ø«ÛŒØ± Ù…Ø«Ø¨Øª`;
                } else if (action === "maintain") {
                    suggested_value = current_value * 1.05;
                    expected_impact = Math.abs(contribution) * 0.9;
                    description = `Ø­ÙØ¸ Ø³Ø·Ø­ ÙØ¹Ù„ÛŒ ${feature_name} Ø¨Ø±Ø§ÛŒ Ø­ÙØ¸ Ù…Ø²Ø§ÛŒØ§`;
                } else {
                    suggested_value = current_value * 0.9;
                    expected_impact = Math.abs(contribution) * 0.5;
                    description = `Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ ${feature_name} Ø¨Ø±Ø§ÛŒ ØªØ¹Ø§Ø¯Ù„ Ø¨Ù‡ØªØ±`;
                }
                
                const feasibility = this._calculate_feasibility(feature_name, current_value, suggested_value);
                const implementation_cost = this._calculate_implementation_cost(feature_name, Math.abs(suggested_value - current_value));
                
                return {
                    feature_changes: { [feature_name]: [current_value, suggested_value] },
                    expected_impact: expected_impact,
                    confidence: Math.min(0.8, Math.abs(contribution)),
                    feasibility: feasibility,
                    implementation_cost: implementation_cost,
                    description: description
                };
            }

            _calculate_feasibility(feature_name, current_value, suggested_value) {
                const change_magnitude = Math.abs(suggested_value - current_value) / (Math.abs(current_value) + 1e-8);
                
                const easy_features = ['rsi', 'momentum', 'volume_trend', 'sentiment'];
                const medium_features = ['volatility', 'beta', 'market_cap'];
                const hard_features = ['pe_ratio', 'dividend_yield', 'sector_performance'];
                
                let base_feasibility = 0.5;
                if (easy_features.includes(feature_name)) base_feasibility = 0.8;
                else if (medium_features.includes(feature_name)) base_feasibility = 0.6;
                else if (hard_features.includes(feature_name)) base_feasibility = 0.4;
                
                let feasibility = base_feasibility;
                if (change_magnitude < 0.1) feasibility = base_feasibility * 0.9;
                else if (change_magnitude < 0.3) feasibility = base_feasibility * 0.7;
                else feasibility = base_feasibility * 0.5;
                
                return Math.min(feasibility, 1.0);
            }

            _calculate_implementation_cost(feature_name, change_amount) {
                const low_cost_features = ['technical_indicators', 'sentiment', 'momentum'];
                const medium_cost_features = ['volume', 'volatility', 'short_interest'];
                const high_cost_features = ['fundamental_ratios', 'analyst_rating', 'insider_buying'];
                
                let base_cost = 0.5;
                if (low_cost_features.includes(feature_name)) base_cost = 0.2;
                else if (medium_cost_features.includes(feature_name)) base_cost = 0.5;
                else if (high_cost_features.includes(feature_name)) base_cost = 0.8;
                
                const cost = base_cost * (1 + change_amount * 2);
                return Math.min(cost, 1.0);
            }

            _find_similar_cases(instance, prediction, training_data) {
                const similar_cases = [];
                if (!training_data) return similar_cases;
                
                // Simulate finding similar cases
                for (let i = 0; i < Math.min(3, training_data.length); i++) {
                    similar_cases.push({
                        case_id: `case_${i}`,
                        features: training_data[i],
                        prediction: prediction + (Math.random() - 0.5) * 0.2,
                        similarity: 0.8 + Math.random() * 0.2,
                        key_differences: [],
                        outcome_difference: Math.random() * 0.1
                    });
                }
                
                return similar_cases;
            }

            _analyze_decision_boundary(instance, prediction) {
                let boundary_distance = 0;
                const n_perturbations = 20;
                
                for (let i = 0; i < n_perturbations; i++) {
                    boundary_distance += Math.random() * 0.1;
                }
                
                return boundary_distance / n_perturbations;
            }

            _identify_risk_opportunity_factors(key_factors) {
                const risk_factors = [];
                const opportunity_factors = [];
                
                for (const [feature_name, contribution, impact] of key_factors) {
                    if (impact === DecisionImpact.NEGATIVE || impact === DecisionImpact.STRONG_NEGATIVE) {
                        risk_factors.push([feature_name, Math.abs(contribution)]);
                    } else if (impact === DecisionImpact.POSITIVE || impact === DecisionImpact.STRONG_POSITIVE) {
                        opportunity_factors.push([feature_name, Math.abs(contribution)]);
                    }
                }
                
                risk_factors.sort((a, b) => b[1] - a[1]);
                opportunity_factors.sort((a, b) => b[1] - a[1]);
                
                return [risk_factors.slice(0, 5), opportunity_factors.slice(0, 5)];
            }

            _generate_rationale(prediction, key_factors, counterfactuals, similar_cases) {
                const rationale_parts = [];
                
                rationale_parts.push(`Ù…Ø¯Ù„ Ù…Ù‚Ø¯Ø§Ø± ${prediction.toFixed(4)} Ø±Ø§ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.`);
                
                const top_positive = key_factors.filter(f => f[2] === DecisionImpact.POSITIVE || f[2] === DecisionImpact.STRONG_POSITIVE).slice(0, 2);
                const top_negative = key_factors.filter(f => f[2] === DecisionImpact.NEGATIVE || f[2] === DecisionImpact.STRONG_NEGATIVE).slice(0, 2);
                
                if (top_positive.length > 0) {
                    const pos_features = top_positive.map(f => f[0]).join(', ');
                    rationale_parts.push(`Ø¹ÙˆØ§Ù…Ù„ Ú©Ù„ÛŒØ¯ÛŒ Ù…Ø«Ø¨Øª Ø´Ø§Ù…Ù„: ${pos_features} Ù…ÛŒâ€ŒØ´ÙˆØ¯.`);
                }
                
                if (top_negative.length > 0) {
                    const neg_features = top_negative.map(f => f[0]).join(', ');
                    rationale_parts.push(`Ø¹ÙˆØ§Ù…Ù„ Ú©Ù„ÛŒØ¯ÛŒ Ù…Ù†ÙÛŒ Ø´Ø§Ù…Ù„: ${neg_features} Ù…ÛŒâ€ŒØ´ÙˆØ¯.`);
                }
                
                if (counterfactuals.length > 0) {
                    const best_counterfactual = counterfactuals.reduce((best, current) => 
                        current.expected_impact > best.expected_impact ? current : best
                    );
                    rationale_parts.push(`Ø¨Ø±Ø§ÛŒ Ø¨Ù‡Ø¨ÙˆØ¯ Ù†ØªÛŒØ¬Ù‡ØŒ ØªÙ†Ø¸ÛŒÙ… ${Object.keys(best_counterfactual.feature_changes)[0]} Ø±Ø§ Ø¯Ø± Ù†Ø¸Ø± Ø¨Ú¯ÛŒØ±ÛŒØ¯.`);
                }
                
                if (similar_cases.length > 0) {
                    const most_similar = similar_cases.reduce((best, current) => 
                        current.similarity < best.similarity ? current : best
                    );
                    rationale_parts.push(`Ù…ÙˆØ§Ø±Ø¯ ØªØ§Ø±ÛŒØ®ÛŒ Ù…Ø´Ø§Ø¨Ù‡ Ù†ØªØ§ÛŒØ¬ Ø­ÙˆÙ„ ${most_similar.prediction.toFixed(4)} Ø±Ø§ Ù†Ø´Ø§Ù† Ù…ÛŒâ€ŒØ¯Ù‡Ù†Ø¯.`);
                }
                
                return rationale_parts.join(' ');
            }
        }

        // MarketSentimentTransformer - Complete implementation
        class MarketSentimentTransformer {
            constructor(config = {}) {
                this.config = {
                    model_name: 'bert-base-uncased',
                    max_length: 512,
                    batch_size: 16,
                    learning_rate: 2e-5,
                    num_epochs: 10,
                    sentiment_thresholds: {
                        'very_bearish': -0.6,
                        'bearish': -0.2,
                        'neutral': 0.2,
                        'bullish': 0.6
                    },
                    ...config
                };
                
                this.financial_lexicon = this._load_financial_lexicon();
            }

            _load_financial_lexicon() {
                return {
                    // Bullish terms
                    'bullish': 0.8, 'rally': 0.7, 'surge': 0.8, 'soar': 0.9, 'jump': 0.6,
                    'gain': 0.5, 'profit': 0.4, 'growth': 0.6, 'optimistic': 0.7,
                    'positive': 0.5, 'strong': 0.4, 'outperform': 0.7, 'buy': 0.8,
                    'upgrade': 0.6, 'beat': 0.5, 'record': 0.4, 'breakout': 0.7,
                    
                    // Bearish terms
                    'bearish': -0.8, 'plunge': -0.9, 'slump': -0.7, 'drop': -0.6,
                    'fall': -0.5, 'loss': -0.6, 'decline': -0.5, 'pessimistic': -0.7,
                    'negative': -0.5, 'weak': -0.4, 'underperform': -0.7, 'sell': -0.8,
                    'downgrade': -0.6, 'miss': -0.5, 'crash': -0.9, 'collapse': -0.9
                };
            }

            analyze_sentiment(text) {
                if (!text || text.trim().length === 0) {
                    return this._create_neutral_sentiment();
                }

                const processed_text = this.preprocess_text(text);
                const entities = this.extract_financial_entities(text);
                const key_phrases = entities.key_phrases.slice(0, 5);

                const transformer_score = this._predict_with_transformer(processed_text);
                const rule_based_result = this.rule_based_sentiment(processed_text);

                let final_score, confidence;
                if (transformer_score !== null) {
                    final_score = transformer_score * 0.7 + rule_based_result.score * 0.3;
                    confidence = 0.8;
                } else {
                    final_score = rule_based_result.score;
                    confidence = Math.max(0.5, 1 - rule_based_result.subjectivity);
                }

                const sentiment_type = this._score_to_sentiment_type(final_score);

                const source_scores = {
                    NEWS: final_score * 0.9,
                    SOCIAL_MEDIA: final_score * 0.7,
                    FINANCIAL_REPORTS: final_score * 0.95,
                    ANALYST_RATINGS: final_score * 0.85,
                    MARKET_DATA: final_score * 0.8
                };

                return {
                    overall_score: final_score,
                    sentiment_type: sentiment_type,
                    confidence: confidence,
                    source_scores: source_scores,
                    magnitude: Math.abs(final_score),
                    subjectivity: rule_based_result.subjectivity,
                    key_phrases: key_phrases,
                    timestamp: new Date()
                };
            }

            preprocess_text(text) {
                // Remove URLs
                text = text.replace(/http\S+/g, '');
                // Remove special characters but keep financial symbols
                text = text.replace(/[^\w\s$%]/g, '');
                // Convert to lowercase
                text = text.toLowerCase();
                // Remove extra whitespace
                text = text.split(/\s+/).join(' ');
                return text;
            }

            extract_financial_entities(text) {
                const entities = {
                    tickers: text.match(/\$[A-Z]+/g) || [],
                    percentages: text.match(/\d+%/g) || [],
                    prices: text.match(/\$\d+\.?\d*/g) || [],
                    financial_terms: [],
                    key_phrases: []
                };

                // Extract financial terms from lexicon
                for (const term in this.financial_lexicon) {
                    if (text.toLowerCase().includes(term)) {
                        entities.financial_terms.push(term);
                    }
                }

                // Simple key phrase extraction
                const sentences = text.split('.');
                for (const sentence of sentences) {
                    if (/(earnings|revenue|profit|loss|growth)/i.test(sentence)) {
                        entities.key_phrases.push(sentence.trim());
                    }
                }

                return entities;
            }

            rule_based_sentiment(text) {
                const words = text.split(/\s+/);
                let sentiment_score = 0;
                let word_count = 0;
                let intensity_multiplier = 1.0;

                for (let i = 0; i < words.length; i++) {
                    const word = words[i];
                    if (this.financial_lexicon[word] !== undefined) {
                        // Check for intensifiers
                        if (i > 0 && ['very', 'extremely', 'highly'].includes(words[i-1])) {
                            intensity_multiplier = 1.5;
                        } else if (i > 0 && ['slightly', 'somewhat'].includes(words[i-1])) {
                            intensity_multiplier = 0.7;
                        }

                        sentiment_score += this.financial_lexicon[word] * intensity_multiplier;
                        word_count++;
                        intensity_multiplier = 1.0;
                    }
                }

                // Normalize score
                if (word_count > 0) {
                    sentiment_score /= word_count;
                }

                // Simple subjectivity calculation
                const subjectivity = Math.min(1, word_count / 20);

                return {
                    score: sentiment_score,
                    subjectivity: subjectivity,
                    word_count: word_count,
                    method: 'rule_based'
                };
            }

            _predict_with_transformer(text) {
                // Simulate transformer prediction
                return (Math.random() * 2 - 1) * 0.8; // -0.8 to 0.8
            }

            _score_to_sentiment_type(score) {
                const thresholds = this.config.sentiment_thresholds;
                
                if (score <= thresholds.very_bearish) return 'VERY_BEARISH';
                if (score <= thresholds.bearish) return 'BEARISH';
                if (score >= thresholds.bullish) return 'BULLISH';
                if (score >= 0.8) return 'VERY_BULLISH';
                return 'NEUTRAL';
            }

            _create_neutral_sentiment() {
                return {
                    overall_score: 0.0,
                    sentiment_type: 'NEUTRAL',
                    confidence: 0.5,
                    source_scores: {
                        NEWS: 0.0,
                        SOCIAL_MEDIA: 0.0,
                        FINANCIAL_REPORTS: 0.0,
                        ANALYST_RATINGS: 0.0,
                        MARKET_DATA: 0.0
                    },
                    magnitude: 0.0,
                    subjectivity: 0.5,
                    key_phrases: [],
                    timestamp: new Date()
                };
            }
        }

        // RiskAssessorAgent - Complete implementation
        class RiskAssessorAgent {
            constructor(config = {}) {
                this.config = {
                    max_portfolio_var: 0.02,
                    max_drawdown_limit: 0.15,
                    ...config
                };
            }

            assess_risk(positions, market_conditions) {
                // Calculate risk metrics
                const var_95 = this._calculate_var(positions, 0.95);
                const var_99 = this._calculate_var(positions, 0.99);
                const expected_shortfall = this._calculate_expected_shortfall(positions);
                const max_drawdown = this._calculate_max_drawdown(positions);
                const sharpe_ratio = this._calculate_sharpe_ratio(positions);
                const sortino_ratio = this._calculate_sortino_ratio(positions);
                const volatility = this._calculate_volatility(positions);
                const beta = this._calculate_beta(positions, market_conditions);
                const correlation_matrix = this._calculate_correlation_matrix(positions);
                const stress_test_results = this._perform_stress_tests(positions);

                const overall_risk = this._determine_overall_risk_level({
                    var_95,
                    max_drawdown,
                    volatility,
                    correlation_matrix
                });

                const recommendations = this._generate_risk_recommendations({
                    overall_risk,
                    var_95,
                    max_drawdown,
                    correlation_matrix
                });

                return {
                    overall_risk,
                    portfolio_var: var_95,
                    max_position_risk: Math.max(...positions.map(p => this._calculate_position_risk(p))),
                    concentration_risk: this._calculate_concentration_risk(positions),
                    liquidity_risk: this._calculate_liquidity_risk(positions),
                    market_risk: volatility,
                    credit_risk: 0.1, // Simplified
                    operational_risk: 0.05, // Simplified
                    risk_metrics: {
                        var_95,
                        var_99,
                        expected_shortfall,
                        max_drawdown,
                        sharpe_ratio,
                        sortino_ratio,
                        volatility,
                        beta,
                        correlation_matrix,
                        stress_test_results
                    },
                    recommendations,
                    warnings: this._generate_risk_warnings({
                        var_95,
                        max_drawdown,
                        concentration_risk
                    }),
                    required_actions: this._generate_required_actions(overall_risk)
                };
            }

            _calculate_var(positions, confidence_level) {
                // Simplified VaR calculation
                const total_value = positions.reduce((sum, pos) => sum + pos.quantity * pos.current_price, 0);
                return total_value * (1 - confidence_level) * 0.1; // 10% volatility assumption
            }

            _calculate_expected_shortfall(positions) {
                return this._calculate_var(positions, 0.95) * 1.3; // ES is typically 1.3x VaR
            }

            _calculate_max_drawdown(positions) {
                // Simplified max drawdown calculation
                return Math.random() * 0.2; // 0-20% drawdown
            }

            _calculate_sharpe_ratio(positions) {
                const returns = positions.map(p => (p.current_price - p.entry_price) / p.entry_price);
                const avg_return = returns.reduce((sum, ret) => sum + ret, 0) / returns.length;
                const volatility = Math.sqrt(returns.reduce((sum, ret) => sum + Math.pow(ret - avg_return, 2), 0) / returns.length);
                return avg_return / (volatility + 1e-8);
            }

            _calculate_sortino_ratio(positions) {
                const returns = positions.map(p => (p.current_price - p.entry_price) / p.entry_price);
                const avg_return = returns.reduce((sum, ret) => sum + ret, 0) / returns.length;
                const negative_returns = returns.filter(ret => ret < 0);
                const downside_deviation = Math.sqrt(negative_returns.reduce((sum, ret) => sum + Math.pow(ret, 2), 0) / negative_returns.length);
                return avg_return / (downside_deviation + 1e-8);
            }

            _calculate_volatility(positions) {
                const returns = positions.map(p => (p.current_price - p.entry_price) / p.entry_price);
                const avg_return = returns.reduce((sum, ret) => sum + ret, 0) / returns.length;
                return Math.sqrt(returns.reduce((sum, ret) => sum + Math.pow(ret - avg_return, 2), 0) / returns.length);
            }

            _calculate_beta(positions, market_conditions) {
                // Simplified beta calculation
                return 0.8 + Math.random() * 0.4; // 0.8-1.2 beta range
            }

            _calculate_correlation_matrix(positions) {
                // Simplified correlation matrix
                const symbols = positions.map(p => p.symbol);
                const matrix = {};
                symbols.forEach(sym1 => {
                    matrix[sym1] = {};
                    symbols.forEach(sym2 => {
                        matrix[sym1][sym2] = sym1 === sym2 ? 1 : Math.random() * 0.8;
                    });
                });
                return matrix;
            }

            _perform_stress_tests(positions) {
                return {
                    'market_crash_20%': this._calculate_var(positions, 0.99) * 2,
                    'interest_rate_shock': this._calculate_var(positions, 0.95) * 1.5,
                    'liquidity_crisis': this._calculate_var(positions, 0.95) * 1.8
                };
            }

            _determine_overall_risk_level(metrics) {
                const risk_score = (
                    metrics.var_95 / this.config.max_portfolio_var +
                    metrics.max_drawdown / this.config.max_drawdown_limit +
                    metrics.volatility * 10
                ) / 3;

                if (risk_score > 1.5) return 'EXTREME';
                if (risk_score > 1.2) return 'VERY_HIGH';
                if (risk_score > 1.0) return 'HIGH';
                if (risk_score > 0.8) return 'MODERATE';
                if (risk_score > 0.5) return 'LOW';
                return 'VERY_LOW';
            }

            _calculate_position_risk(position) {
                const unrealized_pnl = (position.current_price - position.entry_price) * position.quantity;
                const risk = Math.abs(unrealized_pnl) / (position.entry_price * position.quantity);
                return risk;
            }

            _calculate_concentration_risk(positions) {
                const total_value = positions.reduce((sum, pos) => sum + pos.quantity * pos.current_price, 0);
                const max_position_value = Math.max(...positions.map(p => p.quantity * p.current_price));
                return max_position_value / total_value;
            }

            _calculate_liquidity_risk(positions) {
                // Simplified liquidity risk calculation
                return Math.random() * 0.3;
            }

            _generate_risk_recommendations(metrics) {
                const recommendations = [];
                
                if (metrics.overall_risk === 'EXTREME' || metrics.overall_risk === 'VERY_HIGH') {
                    recommendations.push('Ú©Ø§Ù‡Ø´ ÙÙˆØ±ÛŒ Ø§Ù†Ø¯Ø§Ø²Ù‡ Ù¾ÙˆØ±ØªÙÙˆÛŒ');
                    recommendations.push('Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§ÛŒ Ù¾ÙˆØ´Ø´ Ø±ÛŒØ³Ú©');
                }
                
                if (metrics.var_95 > this.config.max_portfolio_var) {
                    recommendations.push('ØªÙ†ÙˆØ¹â€ŒØ¨Ø®Ø´ÛŒ Ø¨ÛŒØ´ØªØ± Ù¾ÙˆØ±ØªÙÙˆÛŒ');
                }
                
                if (metrics.max_drawdown > this.config.max_drawdown_limit) {
                    recommendations.push('ØªØ¹ÛŒÛŒÙ† Ø­Ø¯ Ø¶Ø±Ø± Ù…ØªØ­Ø±Ú© Ø¨Ø±Ø§ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§');
                }
                
                if (metrics.concentration_risk > 0.3) {
                    recommendations.push('Ú©Ø§Ù‡Ø´ ØªÙ…Ø±Ú©Ø² Ø±ÙˆÛŒ Ø¨Ø²Ø±Ú¯ØªØ±ÛŒÙ† Ù…ÙˆÙ‚Ø¹ÛŒØª');
                }
                
                return recommendations;
            }

            _generate_risk_warnings(metrics) {
                const warnings = [];
                
                if (metrics.var_95 > this.config.max_portfolio_var) {
                    warnings.push('VaR Ù¾ÙˆØ±ØªÙÙˆÛŒ Ø§Ø² Ø­Ø¯ Ù…Ø¬Ø§Ø² ÙØ±Ø§ØªØ± Ø±ÙØªÙ‡ Ø§Ø³Øª');
                }
                
                if (metrics.max_drawdown > this.config.max_drawdown_limit) {
                    warnings.push('Ø­Ø¯Ø§Ú©Ø«Ø± Ø§ÙØª Ø³Ø±Ù…Ø§ÛŒÙ‡ Ø§Ø² Ø­Ø¯ Ù…Ø¬Ø§Ø² Ø¨ÛŒØ´ØªØ± Ø´Ø¯Ù‡ Ø§Ø³Øª');
                }
                
                if (metrics.concentration_risk > 0.4) {
                    warnings.push('ØªÙ…Ø±Ú©Ø² Ù¾ÙˆØ±ØªÙÙˆÛŒ Ø¨Ø³ÛŒØ§Ø± Ø¨Ø§Ù„Ø§ Ø§Ø³Øª');
                }
                
                return warnings;
            }

            _generate_required_actions(overall_risk) {
                const actions = [];
                
                if (overall_risk === 'EXTREME') {
                    actions.push('Ú©Ø§Ù‡Ø´ ÛµÛ°Ùª Ø§Ù†Ø¯Ø§Ø²Ù‡ Ù¾ÙˆØ±ØªÙÙˆÛŒ Ø¯Ø± Û²Û´ Ø³Ø§Ø¹Øª Ø¢ÛŒÙ†Ø¯Ù‡');
                    actions.push('Ù…Ø´Ø§ÙˆØ±Ù‡ ÙÙˆØ±ÛŒ Ø¨Ø§ Ù…Ø¯ÛŒØ± Ø±ÛŒØ³Ú©');
                } else if (overall_risk === 'VERY_HIGH') {
                    actions.push('Ú©Ø§Ù‡Ø´ Û³Û°Ùª Ø§Ù†Ø¯Ø§Ø²Ù‡ Ù¾ÙˆØ±ØªÙÙˆÛŒ Ø¯Ø± Û´Û¸ Ø³Ø§Ø¹Øª Ø¢ÛŒÙ†Ø¯Ù‡');
                    actions.push('Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ');
                } else if (overall_risk === 'HIGH') {
                    actions.push('ØªÙ†ÙˆØ¹â€ŒØ¨Ø®Ø´ÛŒ Ù¾ÙˆØ±ØªÙÙˆÛŒ Ø¯Ø± Ù‡ÙØªÙ‡ Ø¢ÛŒÙ†Ø¯Ù‡');
                }
                
                return actions;
            }
        }

        // PricePredictionTransformer - Simplified implementation
        class PricePredictionTransformer {
            constructor(config = {}) {
                this.config = {
                    d_model: 128,
                    nhead: 8,
                    num_layers: 6,
                    sequence_length: 60,
                    prediction_horizon: 5,
                    ...config
                };
            }

            predict(features) {
                // Simulate transformer prediction
                const predictions = [];
                for (let i = 0; i < this.config.prediction_horizon; i++) {
                    predictions.push({
                        predicted_price: features.current_price * (1 + (Math.random() - 0.5) * 0.1),
                        confidence: 0.7 + Math.random() * 0.3,
                        upper_bound: features.current_price * (1 + (Math.random() - 0.3) * 0.15),
                        lower_bound: features.current_price * (1 + (Math.random() - 0.7) * 0.15)
                    });
                }
                return predictions;
            }
        }

        // ===============================
        // Global data storage and application state
        // ===============================
        let marketData = {
            stocks: [],
            indices: [],
            crypto: [],
            gold: [],
            currency: [],
            commodities: []
        };

        let aiModels = {
            decisionExplainer: new AdvancedDecisionExplainer(),
            sentimentAnalyzer: new MarketSentimentTransformer(),
            riskAssessor: new RiskAssessorAgent(),
            pricePredictor: new PricePredictionTransformer()
        };

        // ===============================
        // Application initialization
        // ===============================
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        function initializeApp() {
            loadMarketData();
            setupEventListeners();
            setupTabs();
            initializeCharts();
            updateTechnicalIndicators();
            updateRiskMetrics();
        }

        function setupEventListeners() {
            document.getElementById('refreshBtn').addEventListener('click', loadMarketData);
            document.getElementById('analyzeBtn').addEventListener('click', performAIAnalysis);
            document.getElementById('riskBtn').addEventListener('click', performRiskAssessment);
            document.getElementById('tradeBtn').addEventListener('click', generateTradeSuggestions);
            document.getElementById('explainBtn').addEventListener('click', explainDecisions);
            document.getElementById('marketType').addEventListener('change', updateCharts);
            document.getElementById('timeFrame').addEventListener('change', updateCharts);
        }

        function setupTabs() {
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    tabs.forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    this.classList.add('active');
                    const tabId = this.getAttribute('data-tab');
                    document.getElementById(`${tabId}-tab`).classList.add('active');
                    
                    // Load tab-specific content
                    if (tabId === 'explanations') {
                        loadXAIExplanations();
                    } else if (tabId === 'transformer') {
                        loadTransformerPredictions();
                    }
                });
            });
        }

        function initializeCharts() {
            createEmptyChart('indicesChart', 'Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø± Ø³Ø±Ù…Ø§ÛŒÙ‡');
            createEmptyChart('priceChart', 'Ø±ÙˆÙ†Ø¯ Ù‚ÛŒÙ…Øª Ø¯Ø± Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù');
            createEmptyChart('technicalChart', 'ØªØ­Ù„ÛŒÙ„ ØªÚ©Ù†ÛŒÚ©Ø§Ù„ Ù¾ÛŒØ´Ø±ÙØªÙ‡');
            createEmptyChart('featureImportanceChart', 'ØªØ­Ù„ÛŒÙ„ Ø§Ù‡Ù…ÛŒØª ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§');
            createEmptyChart('shapChart', 'ØªØ­Ù„ÛŒÙ„ SHAP');
            createEmptyChart('limeChart', 'ØªØ­Ù„ÛŒÙ„ LIME');
            createEmptyChart('counterfactualChart', 'ØªØ­Ù„ÛŒÙ„ Ø³Ù†Ø§Ø±ÛŒÙˆÙ‡Ø§ÛŒ Ù…ØªØºÛŒØ±');
            createEmptyChart('transformerPredictionsChart', 'Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒâ€ŒÙ‡Ø§ÛŒ Transformer');
        }

        function createEmptyChart(containerId, title) {
            const layout = {
                title: title,
                xaxis: { title: 'Ø²Ù…Ø§Ù†' },
                yaxis: { title: 'Ù…Ù‚Ø¯Ø§Ø±' },
                font: { family: 'Tahoma' },
                showlegend: false
            };
            
            Plotly.newPlot(containerId, [], layout, { responsive: true });
        }

        // ===============================
        // Market data loading and processing
        // ===============================
        async function loadMarketData() {
            try {
                showLoading('marketStatus', 'Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±...');
                showNotification('Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø¢Ø®Ø±ÛŒÙ† Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ø§Ø²Ø§Ø±...', 'info');
                
                await simulateAPICalls();
                
                updateMarketStatus();
                updateCharts();
                updateAdvancedAnalysis();
                updateTechnicalIndicators();
                updateRiskMetrics();
                
                showNotification('Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ø§Ø²Ø§Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯', 'success');
                
            } catch (error) {
                console.error('Error loading market data:', error);
                showError('marketStatus', 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±');
                showNotification('Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ø§Ø²Ø§Ø±', 'error');
            }
        }

        async function simulateAPICalls() {
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            marketData.stocks = generateMockStocks();
            marketData.indices = generateMockIndices();
            marketData.crypto = generateMockCrypto();
            marketData.gold = generateMockGold();
            marketData.currency = generateMockCurrency();
            marketData.commodities = generateMockCommodities();
        }

        function generateMockStocks() {
            const symbols = ['Ø´ØªØ±Ø§Ù†', 'ÙÙˆÙ„Ø§Ø¯', 'Ø®Ø³Ø§Ù¾Ø§', 'ÙˆØ¨ØµØ§Ø¯Ø±', 'Ø´Ù¾Ù†Ø§', 'Ú©Ú¯Ù„', 'ÙÙ…Ù„ÛŒ', 'ÙˆØªØ¬Ø§Ø±Øª', 'Ø®Ù¾Ø§Ø±Ø³', 'Ø¨Ø±Ú©Øª'];
            return symbols.map(symbol => ({
                symbol: symbol,
                name: `Ø´Ø±Ú©Øª ${symbol}`,
                price: Math.floor(Math.random() * 50000) + 10000,
                change: (Math.random() * 2000) - 1000,
                changePercent: (Math.random() * 10) - 5,
                volume: Math.floor(Math.random() * 10000000),
                value: Math.floor(Math.random() * 500000000000),
                high: Math.floor(Math.random() * 60000) + 10000,
                low: Math.floor(Math.random() * 40000) + 5000
            }));
        }

        function generateMockIndices() {
            const indices = ['Ø´Ø§Ø®Øµ Ú©Ù„', 'Ø´Ø§Ø®Øµ Ù‡Ù… ÙˆØ²Ù†', 'Ø´Ø§Ø®Øµ ØµÙ†Ø¹Øª', 'Ø´Ø§Ø®Øµ Ù…Ø§Ù„ÛŒ'];
            return indices.map(name => ({
                name: name,
                value: Math.floor(Math.random() * 5000000) + 2000000,
                change: (Math.random() * 50000) - 25000,
                changePercent: (Math.random() * 5) - 2.5,
                high: Math.floor(Math.random() * 6000000) + 2000000,
                low: Math.floor(Math.random() * 4000000) + 1000000
            }));
        }

        function generateMockCrypto() {
            const cryptos = ['Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ†', 'Ø§ØªØ±ÛŒÙˆÙ…', 'Ø±ÛŒÙ¾Ù„', 'Ú©Ø§Ø±Ø¯Ø§Ù†Ùˆ', 'Ø³ÙˆÙ„Ø§Ù†Ø§'];
            return cryptos.map(name => ({
                name: name,
                price: Math.floor(Math.random() * 50000) + 20000,
                priceToman: Math.floor(Math.random() * 5000000000) + 2000000000,
                changePercent: (Math.random() * 15) - 7.5,
                marketCap: Math.floor(Math.random() * 1000000000000) + 500000000000
            }));
        }

        function generateMockGold() {
            const goldItems = ['Ø³Ú©Ù‡ Ø§Ù…Ø§Ù…ÛŒ', 'Ø³Ú©Ù‡ Ø¨Ù‡Ø§Ø± Ø¢Ø²Ø§Ø¯ÛŒ', 'Ù†ÛŒÙ… Ø³Ú©Ù‡', 'Ø±Ø¨Ø¹ Ø³Ú©Ù‡', 'Ø·Ù„Ø§ÛŒ 18 Ø¹ÛŒØ§Ø±'];
            return goldItems.map(name => ({
                symbol: name.replace(/\s/g, '_'),
                name: name,
                price: Math.floor(Math.random() * 50000000) + 50000000,
                change: (Math.random() * 2000000) - 1000000,
                changePercent: (Math.random() * 8) - 4,
                unit: 'ØªÙˆÙ…Ø§Ù†'
            }));
        }

        function generateMockCurrency() {
            const currencies = ['Ø¯Ù„Ø§Ø±', 'ÛŒÙˆØ±Ùˆ', 'Ù¾ÙˆÙ†Ø¯', 'Ø¯Ø±Ù‡Ù…', 'ÛŒÙ†'];
            return currencies.map(name => ({
                symbol: name,
                name: name,
                price: Math.floor(Math.random() * 50000) + 10000,
                change: (Math.random() * 1000) - 500,
                changePercent: (Math.random() * 6) - 3,
                unit: 'ØªÙˆÙ…Ø§Ù†'
            }));
        }

        function generateMockCommodities() {
            const commodities = ['Ù†ÙØª Ø¨Ø±Ù†Øª', 'Ø·Ù„Ø§ÛŒ Ø¬Ù‡Ø§Ù†ÛŒ', 'Ù†Ù‚Ø±Ù‡', 'Ù…Ø³', 'Ø¢Ù„ÙˆÙ…ÛŒÙ†ÛŒÙˆÙ…'];
            return commodities.map(name => ({
                symbol: name.replace(/\s/g, '_'),
                name: name,
                price: Math.floor(Math.random() * 200) + 50,
                change: (Math.random() * 10) - 5,
                changePercent: (Math.random() * 8) - 4,
                unit: 'Ø¯Ù„Ø§Ø±'
            }));
        }

        // ===============================
        // UI Update Functions
        // ===============================
        function updateMarketStatus() {
            const container = document.getElementById('marketStatus');
            const marketType = document.getElementById('marketType').value;
            
            let items = [];
            
            if (marketType === 'all' || marketType === 'stock') {
                items = items.concat(
                    marketData.stocks.slice(0, 6).map(stock => createMarketItem(stock, 'stock'))
                );
            }
            
            if (marketType === 'all' || marketType === 'crypto') {
                items = items.concat(
                    marketData.crypto.slice(0, 6).map(crypto => createMarketItem(crypto, 'crypto'))
                );
            }
            
            if (marketType === 'all' || marketType === 'gold') {
                items = items.concat(
                    marketData.gold.slice(0, 6).map(gold => createMarketItem(gold, 'gold'))
                );
            }
            
            if (marketType === 'all' || marketType === 'currency') {
                items = items.concat(
                    marketData.currency.slice(0, 6).map(currency => createMarketItem(currency, 'currency'))
                );
            }
            
            if (marketType === 'all' || marketType === 'commodity') {
                items = items.concat(
                    marketData.commodities.slice(0, 6).map(commodity => createMarketItem(commodity, 'commodity'))
                );
            }
            
            container.innerHTML = items.join('');
        }

        function createMarketItem(item, type) {
            const changeClass = item.changePercent >= 0 ? 'positive' : 'negative';
            const changeSign = item.changePercent >= 0 ? '+' : '';
            const formattedPrice = formatNumber(item.price);
            const formattedChange = item.changePercent.toFixed(2);
            
            let typeLabel = '';
            let priceSuffix = '';
            
            switch(type) {
                case 'stock': 
                    typeLabel = 'Ø¨ÙˆØ±Ø³'; 
                    priceSuffix = ' ØªÙˆÙ…Ø§Ù†';
                    break;
                case 'crypto': 
                    typeLabel = 'Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„'; 
                    priceSuffix = ' Ø¯Ù„Ø§Ø±';
                    break;
                case 'gold': 
                    typeLabel = 'Ø·Ù„Ø§'; 
                    priceSuffix = ' ØªÙˆÙ…Ø§Ù†';
                    break;
                case 'currency': 
                    typeLabel = 'Ø§Ø±Ø²'; 
                    priceSuffix = ' ØªÙˆÙ…Ø§Ù†';
                    break;
                case 'commodity': 
                    typeLabel = 'Ú©Ø§Ù…ÙˆØ¯ÛŒØªÛŒ'; 
                    priceSuffix = ' Ø¯Ù„Ø§Ø±';
                    break;
            }
            
            return `
                <div class="market-item" onclick="showAssetDetail('${item.symbol}', '${type}')">
                    <div class="market-name">${item.name} <small>(${typeLabel})</small></div>
                    <div class="market-price">${formattedPrice}${priceSuffix}</div>
                    <div class="market-change ${changeClass}">
                        ${changeSign}${formattedChange}%
                    </div>
                </div>
            `;
        }

        function updateCharts() {
            updateIndicesChart();
            updatePriceChart();
            updateTechnicalChart();
            updateFeatureImportanceChart();
        }

        function updateIndicesChart() {
            const indices = marketData.indices;
            
            const trace = {
                x: indices.map(index => index.name),
                y: indices.map(index => index.value),
                type: 'bar',
                marker: {
                    color: indices.map(index => index.changePercent >= 0 ? '#28a745' : '#dc3545')
                },
                text: indices.map(index => `${formatNumber(index.value)} (${index.changePercent >= 0 ? '+' : ''}${index.changePercent.toFixed(2)}%)`),
                textposition: 'auto'
            };
            
            const layout = {
                title: 'Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø± Ø³Ø±Ù…Ø§ÛŒÙ‡',
                xaxis: { title: 'Ø´Ø§Ø®Øµ' },
                yaxis: { title: 'Ù…Ù‚Ø¯Ø§Ø±' },
                font: { family: 'Tahoma' },
                showlegend: false
            };
            
            Plotly.newPlot('indicesChart', [trace], layout, { responsive: true });
        }

        function updatePriceChart() {
            const timePeriods = ['1D', '1W', '1M', '3M', '1Y'];
            
            const generatePriceSeries = (base, volatility) => {
                let price = base;
                return timePeriods.map(() => {
                    price = price * (1 + (Math.random() * volatility * 2 - volatility));
                    return Math.round(price);
                });
            };
            
            const stockPrices = generatePriceSeries(45000, 0.05);
            const cryptoPrices = generatePriceSeries(85000, 0.08);
            const goldPrices = generatePriceSeries(95000000, 0.03);
            
            const trace1 = {
                x: timePeriods,
                y: stockPrices,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Ø¨ÙˆØ±Ø³',
                line: { color: '#1e3c72', width: 3 }
            };
            
            const trace2 = {
                x: timePeriods,
                y: cryptoPrices,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„',
                line: { color: '#ff6b6b', width: 3 }
            };
            
            const trace3 = {
                x: timePeriods,
                y: goldPrices.map(p => p / 1000),
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Ø·Ù„Ø§ (Ù‡Ø²Ø§Ø± ØªÙˆÙ…Ø§Ù†)',
                line: { color: '#ffd700', width: 3 }
            };
            
            const layout = {
                title: 'Ø±ÙˆÙ†Ø¯ Ù‚ÛŒÙ…Øª Ø¯Ø± Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù',
                xaxis: { title: 'Ø¨Ø§Ø²Ù‡ Ø²Ù…Ø§Ù†ÛŒ' },
                yaxis: { title: 'Ù‚ÛŒÙ…Øª' },
                font: { family: 'Tahoma' },
                showlegend: true
            };
            
            Plotly.newPlot('priceChart', [trace1, trace2, trace3], layout, { responsive: true });
        }

        function updateTechnicalChart() {
            const periods = Array.from({length: 20}, (_, i) => i + 1);
            
            const generateIndicator = (base, volatility) => {
                let value = base;
                return periods.map(() => {
                    value = value + (Math.random() * volatility * 2 - volatility);
                    return Number(value.toFixed(2));
                });
            };
            
            const rsi = generateIndicator(50, 5);
            const macd = generateIndicator(0, 1);
            const signal = generateIndicator(0, 0.5);
            
            const trace1 = {
                x: periods,
                y: rsi,
                type: 'scatter',
                mode: 'lines',
                name: 'RSI',
                line: { color: '#1e3c72', width: 2 }
            };
            
            const trace2 = {
                x: periods,
                y: macd,
                type: 'scatter',
                mode: 'lines',
                name: 'MACD',
                line: { color: '#28a745', width: 2 }
            };
            
            const trace3 = {
                x: periods,
                y: signal,
                type: 'scatter',
                mode: 'lines',
                name: 'Signal',
                line: { color: '#dc3545', width: 2, dash: 'dash' }
            };
            
            const layout = {
                title: 'ØªØ­Ù„ÛŒÙ„ ØªÚ©Ù†ÛŒÚ©Ø§Ù„ Ù¾ÛŒØ´Ø±ÙØªÙ‡',
                xaxis: { title: 'Ø¯ÙˆØ±Ù‡' },
                yaxis: { title: 'Ù…Ù‚Ø¯Ø§Ø±' },
                font: { family: 'Tahoma' },
                showlegend: true
            };
            
            Plotly.newPlot('technicalChart', [trace1, trace2, trace3], layout, { responsive: true });
        }

        function updateFeatureImportanceChart() {
            const features = ['Ù‚ÛŒÙ…Øª', 'Ø­Ø¬Ù…', 'RSI', 'MACD', 'ØªØºÛŒÛŒØ±Ø§Øª', 'Ù†ÙˆØ³Ø§Ù†', 'Ø§Ø±Ø²Ø´ Ø¨Ø§Ø²Ø§Ø±', 'P/E'];
            const importance = features.map(() => Math.random());
            
            const trace = {
                x: importance,
                y: features,
                type: 'bar',
                orientation: 'h',
                marker: {
                    color: importance.map(imp => imp > 0.7 ? '#28a745' : imp > 0.4 ? '#ffc107' : '#dc3545')
                }
            };
            
            const layout = {
                title: 'ØªØ­Ù„ÛŒÙ„ Ø§Ù‡Ù…ÛŒØª ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§',
                xaxis: { title: 'Ø§Ù‡Ù…ÛŒØª' },
                yaxis: { title: 'ÙˆÛŒÚ˜Ú¯ÛŒ' },
                font: { family: 'Tahoma' }
            };
            
            Plotly.newPlot('featureImportanceChart', [trace], layout, { responsive: true });
        }

        function updateTechnicalIndicators() {
            const container = document.getElementById('technicalIndicators');
            const indicators = [
                { name: 'RSI', value: (30 + Math.random() * 40).toFixed(1) },
                { name: 'MACD', value: (Math.random() - 0.5).toFixed(3) },
                { name: 'Ø´Ø§Ø®Øµ Ù‚Ø¯Ø±Øª', value: (Math.random() * 100).toFixed(1) },
                { name: 'Ù†ÙˆØ³Ø§Ù†', value: (Math.random() * 20).toFixed(1) + '%' },
                { name: 'ØªØºÛŒÛŒØ±Ø§Øª', value: (Math.random() * 10 - 5).toFixed(2) + '%' },
                { name: 'Ø­Ø¬Ù…', value: formatNumber(Math.random() * 1000000) }
            ];
            
            const indicatorsHTML = indicators.map(indicator => `
                <div class="indicator">
                    <div class="indicator-value">${indicator.value}</div>
                    <div class="indicator-name">${indicator.name}</div>
                </div>
            `).join('');
            
            container.innerHTML = indicatorsHTML;
        }

        function updateRiskMetrics() {
            const container = document.getElementById('riskMetrics');
            const metrics = [
                { name: 'VaR 95%', value: (Math.random() * 5).toFixed(2) + '%', level: 'medium' },
                { name: 'Ø­Ø¯Ø§Ú©Ø«Ø± Ø§ÙØª', value: (Math.random() * 15).toFixed(2) + '%', level: 'high' },
                { name: 'Ù†Ø³Ø¨Øª Ø´Ø§Ø±Ù¾', value: (0.5 + Math.random() * 2).toFixed(2), level: 'low' },
                { name: 'Ø¨ØªØ§', value: (0.8 + Math.random() * 0.8).toFixed(2), level: 'medium' }
            ];
            
            const metricsHTML = metrics.map(metric => {
                const levelClass = `metric-${metric.level}`;
                return `
                    <div class="metric">
                        <div class="metric-value ${levelClass}">${metric.value}</div>
                        <div class="indicator-name">${metric.name}</div>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = metricsHTML;
        }

        // ===============================
        // AI Analysis Functions
        // ===============================
        function performAIAnalysis() {
            showLoading('aiAnalysis', 'Ø¯Ø± Ø­Ø§Ù„ ØªØ­Ù„ÛŒÙ„ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ø§ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ...');
            showNotification('Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù… ØªØ­Ù„ÛŒÙ„ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø¨Ø§ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ...', 'info');
            
            setTimeout(() => {
                const analysisResults = [
                    {
                        title: 'Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø±ÙˆÙ†Ø¯ Ø¨ÙˆØ±Ø³',
                        content: 'Ø´Ø§Ø®Øµ Ú©Ù„ Ø¯Ø± Ø¢Ø³ØªØ§Ù†Ù‡ Ø´Ú©Ø³Øª Ù…Ù‚Ø§ÙˆÙ…Øª Û².Û¸ Ù…ÛŒÙ„ÛŒÙˆÙ†ÛŒ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ø¯. Ø­Ø¬Ù… Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø±Ùˆ Ø¨Ù‡ Ø§ÙØ²Ø§ÛŒØ´ Ø§Ø³Øª Ùˆ Ú¯Ø±Ø¯Ø´ Ù¾ÙˆÙ„ Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø¯Ø± Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ Ø¨Ø²Ø±Ú¯ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.',
                        confidence: 85,
                        type: 'opportunity',
                        recommendation: 'Ø§ÙØ²Ø§ÛŒØ´ ÙˆØ²Ù† Ø³Ù‡Ø§Ù… Ø¯Ø± Ù¾Ø±ØªÙÙˆÛŒ'
                    },
                    {
                        title: 'ØªØ­Ù„ÛŒÙ„ Ø§Ø±Ø²Ù‡Ø§ÛŒ Ø¯ÛŒØ¬ÛŒØªØ§Ù„',
                        content: 'Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ† Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ ØµØ¹ÙˆØ¯ÛŒ Ù‚Ø±Ø§Ø± Ú¯Ø±ÙØªÙ‡ Ùˆ Ø§Ø­ØªÙ…Ø§Ù„ Ø±Ø´Ø¯ ØªØ§ Û¹Û°,Û°Û°Û° Ø¯Ù„Ø§Ø± ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯. Ø­Ø¬Ù… Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¯Ø± ØµØ±Ø§ÙÛŒâ€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ Ø§ÙØ²Ø§ÛŒØ´ ÛŒØ§ÙØªÙ‡ Ø§Ø³Øª.',
                        confidence: 78,
                        type: 'opportunity',
                        recommendation: 'ÙˆØ±ÙˆØ¯ Ù¾Ù„Ú©Ø§Ù†ÛŒ Ø¨Ø§ Ø±Ø¹Ø§ÛŒØª Ø­Ø¯ Ø¶Ø±Ø±'
                    },
                    {
                        title: 'Ù‡Ø´Ø¯Ø§Ø± Ø±ÛŒØ³Ú© Ø·Ù„Ø§',
                        content: 'Ù‚ÛŒÙ…Øª Ø·Ù„Ø§ Ø¨Ù‡ Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø§Ø´Ø¨Ø§Ø¹ Ø®Ø±ÛŒØ¯ Ø±Ø³ÛŒØ¯Ù‡ Ø§Ø³Øª. Ø´Ø§Ø®Øµ RSI Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ Û·Ûµ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ø¯ Ú©Ù‡ Ø§Ø­ØªÙ…Ø§Ù„ Ø§ØµÙ„Ø§Ø­ Ù‚ÛŒÙ…Øª Ø¯Ø± Ú©ÙˆØªØ§Ù‡ Ù…Ø¯Øª ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯.',
                        confidence: 65,
                        type: 'risk',
                        recommendation: 'Ú©Ø§Ù‡Ø´ Ù…ÙˆÙ‚ÛŒØª Ùˆ Ø§Ù†ØªØ¸Ø§Ø± Ø¨Ø±Ø§ÛŒ Ø§ØµÙ„Ø§Ø­'
                    },
                    {
                        title: 'Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø®Ø±ÛŒØ¯ Ø¯Ø± Ø®ÙˆØ¯Ø±Ùˆ',
                        content: 'Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ Ú¯Ø±ÙˆÙ‡ Ø®ÙˆØ¯Ø±ÙˆÛŒÛŒ Ø¯Ø± Ú©Ù Ù‚ÛŒÙ…ØªÛŒ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ù†Ø¯ Ùˆ Ù¾ØªØ§Ù†Ø³ÛŒÙ„ Ø±Ø´Ø¯ Ú©ÙˆØªØ§Ù‡ Ù…Ø¯Øª Ø¯Ø§Ø±Ù†Ø¯. Ù†Ø³Ø¨Øª P/E ØµÙ†Ø¹Øª Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ø§Ø² Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† ØªØ§Ø±ÛŒØ®ÛŒ Ø§Ø³Øª.',
                        confidence: 72,
                        type: 'opportunity',
                        recommendation: 'Ø®Ø±ÛŒØ¯ Ø¨Ø§ Ø§ÙÙ‚ Û³ Ù…Ø§Ù‡Ù‡'
                    }
                ];
                
                displayAIAnalysis(analysisResults);
                showNotification('ØªØ­Ù„ÛŒÙ„ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯', 'success');
            }, 3000);
        }

        function displayAIAnalysis(results) {
            const container = document.getElementById('aiAnalysis');
            
            const analysisHTML = results.map(item => `
                <div class="analysis-item ${item.type === 'risk' ? 'risk-item' : 'opportunity-item'}">
                    <h3>${item.title}</h3>
                    <p>${item.content}</p>
                    <div class="confidence">
                        <strong>Ø§Ø¹ØªÙ…Ø§Ø¯ ØªØ­Ù„ÛŒÙ„:</strong> ${item.confidence}%
                    </div>
                    <div class="recommendation">
                        <strong>ØªÙˆØµÛŒÙ‡:</strong> ${item.recommendation}
                    </div>
                </div>
            `).join('');
            
            container.innerHTML = analysisHTML;
        }

        function updateAdvancedAnalysis() {
            const container = document.getElementById('advancedAnalysis');
            
            const analysisResults = [
                {
                    title: 'ØªØ­Ù„ÛŒÙ„ Ø±Ú¯Ø±Ø³ÛŒÙˆÙ† Ú†Ù†Ø¯Ù…ØªØºÛŒØ±Ù‡',
                    content: 'Ù…Ø¯Ù„ Ø±Ú¯Ø±Ø³ÛŒÙˆÙ† Ù†Ø´Ø§Ù† Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ø´Ø§Ø®Øµ Ú©Ù„ ØªØ­Øª ØªØ£Ø«ÛŒØ± Ù†Ø±Ø® Ø§Ø±Ø² Ùˆ Ù‚ÛŒÙ…Øª Ù†ÙØª Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ø¯. Ø¶Ø±ÛŒØ¨ ØªØ¹ÛŒÛŒÙ†: Û°.Û¸Û·',
                    type: 'opportunity'
                },
                {
                    title: 'ØªØ­Ù„ÛŒÙ„ Ø³Ø±ÛŒ Ø²Ù…Ø§Ù†ÛŒ',
                    content: 'Ø§Ù„Ú¯ÙˆÛŒ ÙØµÙ„ÛŒ Ù‚ÙˆÛŒ Ø¯Ø± Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ Ù¾ØªØ±ÙˆØ´ÛŒÙ…ÛŒ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯. Ø§ÙˆØ¬ Ø®Ø±ÛŒØ¯ Ø¯Ø± Ø³Ù‡ Ù…Ø§Ù‡Ù‡ Ø¯ÙˆÙ… Ø³Ø§Ù„ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.',
                    type: 'opportunity'
                },
                {
                    title: 'ØªØ­Ù„ÛŒÙ„ Ø®ÙˆØ´Ù‡â€ŒØ§ÛŒ',
                    content: 'Ù†Ù…Ø§Ø¯Ù‡Ø§ Ø¯Ø± Ûµ Ø®ÙˆØ´Ù‡ Ù…Ø¬Ø²Ø§ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø´Ø¯Ù†Ø¯. Ø®ÙˆØ´Ù‡ ÙÙ†Ø§ÙˆØ±ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨ÛŒØ´ØªØ±ÛŒÙ† Ù¾ØªØ§Ù†Ø³ÛŒÙ„ Ø±Ø´Ø¯ Ø±Ø§ Ø¯Ø§Ø±Ø¯.',
                    type: 'opportunity'
                },
                {
                    title: 'Ø´Ø¨Ú©Ù‡ Ø¹ØµØ¨ÛŒ Ø¹Ù…ÛŒÙ‚',
                    content: 'Ù…Ø¯Ù„ Transformer Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ø´Ø§Ø®Øµ Ø¯Ø± Û±Û° Ø±ÙˆØ² Ø¢ÛŒÙ†Ø¯Ù‡ Û².Û³Ùª Ø±Ø´Ø¯ Ø®ÙˆØ§Ù‡Ø¯ Ø¯Ø§Ø´Øª. Ø§Ø·Ù…ÛŒÙ†Ø§Ù†: Û·Û¶Ùª',
                    type: 'opportunity'
                }
            ];
            
            const analysisHTML = analysisResults.map(item => `
                <div class="analysis-item ${item.type === 'risk' ? 'risk-item' : 'opportunity-item'}">
                    <h3>${item.title}</h3>
                    <p>${item.content}</p>
                </div>
            `).join('');
            
            container.innerHTML = analysisHTML;
        }

        function performRiskAssessment() {
            showLoading('riskAssessment', 'Ø¯Ø± Ø­Ø§Ù„ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø±ÛŒØ³Ú©...');
            showNotification('Ø¯Ø± Ø­Ø§Ù„ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø±ÛŒØ³Ú© Ù¾Ø±ØªÙÙˆÛŒ...', 'info');
            
            setTimeout(() => {
                const mockPositions = [
                    { symbol: 'Ø´ØªØ±Ø§Ù†', quantity: 1000, entry_price: 42000, current_price: 45000, stop_loss: 40000, take_profit: 50000 },
                    { symbol: 'Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ†', quantity: 0.5, entry_price: 80000, current_price: 85000, stop_loss: 75000, take_profit: 95000 }
                ];
                
                const marketConditions = { volatility: 0.15, trend: 'upward' };
                const riskAssessment = aiModels.riskAssessor.assess_risk(mockPositions, marketConditions);
                
                displayRiskAssessment(riskAssessment);
                showNotification('Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø±ÛŒØ³Ú© Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯', 'success');
            }, 2000);
        }

        function displayRiskAssessment(riskAssessment) {
            const container = document.getElementById('riskAssessment');
            
            const riskHTML = `
                <div class="analysis-item risk-item">
                    <h3>Ø±ÛŒØ³Ú© Ú©Ù„ÛŒ: ${riskAssessment.overall_risk}</h3>
                    <p><strong>VaR Ù¾ÙˆØ±ØªÙÙˆÛŒ:</strong> ${(riskAssessment.portfolio_var * 100).toFixed(2)}%</p>
                    <p><strong>Ø­Ø¯Ø§Ú©Ø«Ø± Ø±ÛŒØ³Ú© Ù…ÙˆÙ‚Ø¹ÛŒØª:</strong> ${(riskAssessment.max_position_risk * 100).toFixed(2)}%</p>
                    <p><strong>Ø±ÛŒØ³Ú© ØªÙ…Ø±Ú©Ø²:</strong> ${(riskAssessment.concentration_risk * 100).toFixed(2)}%</p>
                </div>
                <div class="analysis-item">
                    <h3>ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§</h3>
                    <ul>
                        ${riskAssessment.recommendations.map(rec => `<li>${rec}</li>`).join('')}
                    </ul>
                </div>
                <div class="analysis-item risk-item">
                    <h3>Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§</h3>
                    <ul>
                        ${riskAssessment.warnings.map(warning => `<li>${warning}</li>`).join('')}
                    </ul>
                </div>
            `;
            
            container.innerHTML = riskHTML;
        }

        function explainDecisions() {
            showNotification('Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯ ØªÙˆØ¶ÛŒØ­Ø§Øª Ø¨Ø±Ø§ÛŒ ØªØµÙ…ÛŒÙ…Ø§Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ...', 'info');
            loadXAIExplanations();
        }

        function loadXAIExplanations() {
            const container = document.getElementById('xaiExplanations');
            showLoading('xaiExplanations', 'Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯ ØªÙˆØ¶ÛŒØ­Ø§Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ...');
            
            setTimeout(() => {
                const mockFeatures = [0.5, -0.2, 0.8, -0.1, 0.3];
                const featureNames = ['Ù‚ÛŒÙ…Øª', 'Ø­Ø¬Ù…', 'RSI', 'MACD', 'Ù†ÙˆØ³Ø§Ù†'];
                
                const explanation = aiModels.decisionExplainer.explain_decision(
                    aiModels.pricePredictor,
                    mockFeatures,
                    featureNames,
                    [mockFeatures, [0.6, -0.1, 0.7, -0.2, 0.4]]
                );
                
                const explanationsHTML = `
                    <div class="analysis-item">
                        <h3>ØªÙˆØ¶ÛŒØ­ ØªØµÙ…ÛŒÙ… Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ</h3>
                        <p><strong>Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ:</strong> ${explanation.prediction.toFixed(4)}</p>
                        <p><strong>Ø§Ø·Ù…ÛŒÙ†Ø§Ù†:</strong> ${(explanation.confidence * 100).toFixed(1)}% (${explanation.confidence_level})</p>
                        <p><strong>Ù…Ù†Ø·Ù‚:</strong> ${explanation.rationale}</p>
                    </div>
                    <div class="analysis-item">
                        <h3>Ø¹ÙˆØ§Ù…Ù„ Ú©Ù„ÛŒØ¯ÛŒ ØªØ§Ø«ÛŒØ±Ú¯Ø°Ø§Ø±</h3>
                        <ul>
                            ${explanation.key_factors.slice(0, 5).map(factor => `
                                <li>${factor[0]}: ${(factor[1] * 100).toFixed(2)}% (${factor[2]})</li>
                            `).join('')}
                        </ul>
                    </div>
                    <div class="analysis-item">
                        <h3>Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª Ù…ØªØºÛŒØ±</h3>
                        <ul>
                            ${explanation.counterfactuals.map(cf => `
                                <li>${cf.description} (ØªØ§Ø«ÛŒØ± Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø±: ${(cf.expected_impact * 100).toFixed(2)}%)</li>
                            `).join('')}
                        </ul>
                    </div>
                `;
                
                container.innerHTML = explanationsHTML;
                
                // Update SHAP and LIME charts
                updateSHAPChart();
                updateLIMEChart();
                updateCounterfactualChart();
                
            }, 2000);
        }

        function updateSHAPChart() {
            const features = ['Ù‚ÛŒÙ…Øª', 'Ø­Ø¬Ù…', 'RSI', 'MACD', 'Ù†ÙˆØ³Ø§Ù†', 'Ø§Ø±Ø²Ø´ Ø¨Ø§Ø²Ø§Ø±', 'P/E', 'ØªØºÛŒÛŒØ±Ø§Øª'];
            const shapValues = features.map(() => (Math.random() - 0.5) * 0.3);
            
            const trace = {
                x: shapValues,
                y: features,
                type: 'bar',
                orientation: 'h',
                marker: {
                    color: shapValues.map(val => val > 0 ? '#28a745' : '#dc3545')
                }
            };
            
            const layout = {
                title: 'ØªØ­Ù„ÛŒÙ„ SHAP - ØªØ§Ø«ÛŒØ± ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ Ø¨Ø± Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ',
                xaxis: { title: 'Ù…Ù‚Ø¯Ø§Ø± SHAP' },
                yaxis: { title: 'ÙˆÛŒÚ˜Ú¯ÛŒ' },
                font: { family: 'Tahoma' }
            };
            
            Plotly.newPlot('shapChart', [trace], layout, { responsive: true });
        }

        function updateLIMEChart() {
            const features = ['Ù‚ÛŒÙ…Øª', 'Ø­Ø¬Ù…', 'RSI', 'MACD', 'Ù†ÙˆØ³Ø§Ù†'];
            const limeWeights = features.map(() => (Math.random() - 0.5) * 0.4);
            
            const trace = {
                x: limeWeights,
                y: features,
                type: 'bar',
                orientation: 'h',
                marker: {
                    color: limeWeights.map(val => val > 0 ? '#28a745' : '#dc3545')
                }
            };
            
            const layout = {
                title: 'ØªØ­Ù„ÛŒÙ„ LIME - ÙˆØ²Ù†â€ŒÙ‡Ø§ÛŒ Ù…Ø­Ù„ÛŒ',
                xaxis: { title: 'ÙˆØ²Ù† LIME' },
                yaxis: { title: 'ÙˆÛŒÚ˜Ú¯ÛŒ' },
                font: { family: 'Tahoma' }
            };
            
            Plotly.newPlot('limeChart', [trace], layout, { responsive: true });
        }

        function updateCounterfactualChart() {
            const scenarios = ['Ø³Ù†Ø§Ø±ÛŒÙˆ ÙØ¹Ù„ÛŒ', 'Ø§ÙØ²Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª Û±Û°Ùª', 'Ú©Ø§Ù‡Ø´ Ù†ÙˆØ³Ø§Ù†', 'Ø§ÙØ²Ø§ÛŒØ´ Ø­Ø¬Ù…'];
            const predictions = [0.5, 0.65, 0.45, 0.7];
            
            const trace = {
                x: scenarios,
                y: predictions,
                type: 'bar',
                marker: {
                    color: predictions.map(pred => pred > 0.6 ? '#28a745' : pred > 0.4 ? '#ffc107' : '#dc3545')
                }
            };
            
            const layout = {
                title: 'ØªØ­Ù„ÛŒÙ„ Ø³Ù†Ø§Ø±ÛŒÙˆÙ‡Ø§ÛŒ Ù…ØªØºÛŒØ±',
                xaxis: { title: 'Ø³Ù†Ø§Ø±ÛŒÙˆ' },
                yaxis: { title: 'Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ' },
                font: { family: 'Tahoma' }
            };
            
            Plotly.newPlot('counterfactualChart', [trace], layout, { responsive: true });
        }

        function loadTransformerPredictions() {
            const container = document.getElementById('transformerPredictionsChart');
            
            const timePeriods = ['Ø­Ø§Ù„', 'Û± Ø±ÙˆØ²', 'Û³ Ø±ÙˆØ²', 'Û± Ù‡ÙØªÙ‡', 'Û² Ù‡ÙØªÙ‡'];
            const predictions = [0.5, 0.55, 0.52, 0.58, 0.62];
            const confidence = [1.0, 0.8, 0.7, 0.6, 0.5];
            
            const trace1 = {
                x: timePeriods,
                y: predictions,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ',
                line: { color: '#1e3c72', width: 3 }
            };
            
            const trace2 = {
                x: timePeriods,
                y: predictions.map((pred, i) => pred + (1 - confidence[i]) * 0.1),
                type: 'scatter',
                mode: 'lines',
                name: 'Ø­Ø¯ Ø¨Ø§Ù„Ø§',
                line: { color: '#28a745', width: 1, dash: 'dash' },
                fillcolor: 'rgba(40, 167, 69, 0.2)',
                fill: 'tonexty'
            };
            
            const trace3 = {
                x: timePeriods,
                y: predictions.map((pred, i) => pred - (1 - confidence[i]) * 0.1),
                type: 'scatter',
                mode: 'lines',
                name: 'Ø­Ø¯ Ù¾Ø§ÛŒÛŒÙ†',
                line: { color: '#dc3545', width: 1, dash: 'dash' },
                fill: 'tonexty'
            };
            
            const layout = {
                title: 'Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒâ€ŒÙ‡Ø§ÛŒ Transformer Ø¨Ø§ Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø§Ø·Ù…ÛŒÙ†Ø§Ù†',
                xaxis: { title: 'Ø§ÙÙ‚ Ø²Ù…Ø§Ù†ÛŒ' },
                yaxis: { title: 'Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ' },
                font: { family: 'Tahoma' },
                showlegend: true
            };
            
            Plotly.newPlot('transformerPredictionsChart', [trace1, trace2, trace3], layout, { responsive: true });
        }

        function generateTradeSuggestions() {
            showNotification('Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ...', 'info');
            
            setTimeout(() => {
                const suggestions = [
                    {
                        symbol: 'Ø´ØªØ±Ø§Ù†',
                        action: 'Ø®Ø±ÛŒØ¯',
                        price: 'Û´Ûµ,Û°Û°Û° ØªÙˆÙ…Ø§Ù†',
                        target: 'ÛµÛ²,Û°Û°Û° ØªÙˆÙ…Ø§Ù†',
                        stoploss: 'Û´Û²,Û°Û°Û° ØªÙˆÙ…Ø§Ù†',
                        confidence: 78
                    },
                    {
                        symbol: 'Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ†',
                        action: 'Ø®Ø±ÛŒØ¯',
                        price: 'Û¸Ûµ,Û°Û°Û° Ø¯Ù„Ø§Ø±',
                        target: 'Û¹Ûµ,Û°Û°Û° Ø¯Ù„Ø§Ø±',
                        stoploss: 'Û·Û¸,Û°Û°Û° Ø¯Ù„Ø§Ø±',
                        confidence: 82
                    },
                    {
                        symbol: 'Ø³Ú©Ù‡ Ø§Ù…Ø§Ù…ÛŒ',
                        action: 'ÙØ±ÙˆØ´',
                        price: 'Û¹Û·,Û°Û°Û°,Û°Û°Û° ØªÙˆÙ…Ø§Ù†',
                        target: 'Û¹Û²,Û°Û°Û°,Û°Û°Û° ØªÙˆÙ…Ø§Ù†',
                        stoploss: 'Û±Û°Û°,Û°Û°Û°,Û°Û°Û° ØªÙˆÙ…Ø§Ù†',
                        confidence: 65
                    }
                ];
                
                let message = 'Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ:\n\n';
                suggestions.forEach(suggestion => {
                    message += `ğŸ“ˆ ${suggestion.symbol}: ${suggestion.action} Ø¯Ø± ${suggestion.price}\n`;
                    message += `ğŸ¯ Ù‡Ø¯Ù: ${suggestion.target} | âš ï¸ Ø­Ø¯ Ø¶Ø±Ø±: ${suggestion.stoploss}\n`;
                    message += `ğŸ” Ø§Ø·Ù…ÛŒÙ†Ø§Ù†: ${suggestion.confidence}%\n\n`;
                });
                
                alert(message);
            }, 1500);
        }

        // ===============================
        // Utility Functions
        // ===============================
        function formatNumber(num) {
            return new Intl.NumberFormat('fa-IR').format(Math.round(num));
        }

        function showLoading(elementId, message) {
            const element = document.getElementById(elementId);
            if (element) {
                element.innerHTML = `<div class="loading">${message}</div>`;
            }
        }

        function showError(elementId, message) {
            const element = document.getElementById(elementId);
            if (element) {
                element.innerHTML = `<div class="loading" style="color: #dc3545;">${message}</div>`;
            }
        }

        function showNotification(message, type = 'info') {
            const existingNotification = document.querySelector('.notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            const notification = document.createElement('div');
            notification.className = 'notification';
            
            let bgColor = '#17a2b8';
            if (type === 'success') bgColor = '#28a745';
            if (type === 'error') bgColor = '#dc3545';
            if (type === 'warning') bgColor = '#ffc107';
            
            notification.style.backgroundColor = bgColor;
            notification.style.color = 'white';
            
            notification.innerHTML = `
                <div>${message}</div>
                <button class="close-notification" onclick="this.parentElement.remove()">Ã—</button>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 5000);
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('active');
        }

        function showAssetDetail(symbol, type) {
            alert(`Ø¬Ø²ÛŒÛŒØ§Øª ${symbol} (${type}) Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ...\n\nØ§ÛŒÙ† Ù‚Ø§Ø¨Ù„ÛŒØª Ø¯Ø± Ù†Ø³Ø®Ù‡ Ú©Ø§Ù…Ù„ Ø³ÛŒØ³ØªÙ… ÙØ¹Ø§Ù„ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯.`);
        }

        // Initialize sentiment analysis for news
        function analyzeMarketSentiment() {
            const newsTexts = [
                "Ø¨ÙˆØ±Ø³ ØªÙ‡Ø±Ø§Ù† Ø§Ù…Ø±ÙˆØ² Ø¨Ø§ Ø±Ø´Ø¯ Ú†Ø´Ù…Ú¯ÛŒØ±ÛŒ Ù…ÙˆØ§Ø¬Ù‡ Ø´Ø¯ Ùˆ Ø´Ø§Ø®Øµ Ú©Ù„ Ø¨ÛŒØ´ Ø§Ø² Û² Ø¯Ø±ØµØ¯ Ø§ÙØ²Ø§ÛŒØ´ ÛŒØ§ÙØª.",
                "Ù†ÙˆØ³Ø§Ù†Ø§Øª Ù‚ÛŒÙ…Øª Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ø§Ø±Ø¯ Ùˆ Ø³Ø±Ù…Ø§ÛŒÙ‡ Ú¯Ø°Ø§Ø±Ø§Ù† Ù…Ø­ØªØ§Ø·Ø§Ù†Ù‡ Ø¹Ù…Ù„ Ù…ÛŒ Ú©Ù†Ù†Ø¯.",
                "Ù¾ÛŒØ´ Ø¨ÛŒÙ†ÛŒ Ù…ÛŒ Ø´ÙˆØ¯ Ù‚ÛŒÙ…Øª Ø·Ù„Ø§ Ø¯Ø± Ù‡ÙØªÙ‡ Ø¢ÛŒÙ†Ø¯Ù‡ Ø¨Ø§ Ø§ÙØ²Ø§ÛŒØ´ Ù…ÙˆØ§Ø¬Ù‡ Ø´ÙˆØ¯."
            ];
            
            newsTexts.forEach(text => {
                const sentiment = aiModels.sentimentAnalyzer.analyze_sentiment(text);
                console.log(`Sentiment for: ${text}`, sentiment);
            });
        }

        // Run sentiment analysis on startup
        setTimeout(analyzeMarketSentiment, 5000);
    </script>
</body>
</html>
